diff --git a/Makefile.vita.dolce b/Makefile.vita.dolce
new file mode 100644
index 000000000..4e2a6430b
--- /dev/null
+++ b/Makefile.vita.dolce
@@ -0,0 +1,60 @@
+# Based on port by xerpi
+# Makefile to build the SDL library
+
+TARGET_LIB = libSDL2.a
+
+SOURCES = \
+	src/*.c \
+	src/atomic/*.c \
+	src/audio/*.c \
+	src/audio/vita/*.c \
+	src/cpuinfo/*.c \
+	src/events/*.c \
+	src/file/*.c \
+	src/haptic/*.c \
+	src/haptic/dummy/*.c \
+	src/joystick/*.c \
+	src/joystick/vita/*.c \
+	src/loadso/dummy/*.c \
+	src/power/*.c \
+	src/power/vita/*.c \
+	src/filesystem/vita/*.c \
+	src/render/*.c \
+	src/render/software/*.c \
+	src/render/vitagxm/*.c \
+	src/render/vitagles2/*.c \
+	src/sensor/*.c \
+	src/sensor/vita/*.c \
+	src/stdlib/*.c \
+	src/thread/*.c \
+	src/thread/generic/SDL_systls.c \
+	src/thread/vita/*.c \
+	src/timer/*.c \
+	src/timer/vita/*.c \
+	src/video/*.c \
+	src/video/vita/*.c \
+	src/video/yuv2rgb/*.c \
+	src/video/arm/*.S \
+
+OBJS = $(shell echo $(SOURCES) | sed -e 's,\.c,\.o,g' | sed -e 's,\.S,\.o,g')
+
+PREFIX  = arm-dolce-eabi
+CC      = $(PREFIX)-gcc
+AR      = $(PREFIX)-ar
+CFLAGS  = -g -Wl,-q -Wall -O3 -Iinclude \
+                        -D__VITA__ -D__ARM_ARCH=7 -D__ARM_ARCH_7A__ \
+                        -mfpu=neon -mcpu=cortex-a9 -mfloat-abi=hard
+ASFLAGS = $(CFLAGS)
+
+$(TARGET_LIB): $(OBJS)
+	$(AR) rcs $@ $^
+
+clean:
+	@rm -f $(TARGET_LIB) $(OBJS)
+
+install: $(TARGET_LIB)
+	@mkdir -p "$(DESTDIR)$(DOLCESDK)/arm-dolce-eabi/lib"
+	@cp  $(TARGET_LIB) $(DESTDIR)$(DOLCESDK)/arm-dolce-eabi/lib
+	@mkdir -p "$(DESTDIR)$(DOLCESDK)/arm-dolce-eabi/include/SDL2"
+	@cp include/*.h "$(DESTDIR)$(DOLCESDK)/arm-dolce-eabi/include/SDL2"
+	@echo "Installed!"
diff --git a/include/SDL_config.h b/include/SDL_config.h
index 3937dbc38..66ca07312 100644
--- a/include/SDL_config.h
+++ b/include/SDL_config.h
@@ -43,6 +43,8 @@
 #include "SDL_config_psp.h"
 #elif defined(__OS2__)
 #include "SDL_config_os2.h"
+#elif defined(__VITA__)
+#include "SDL_config_vita.h"
 #else
 /* This is a minimal configuration just to get SDL running on new platforms. */
 #include "SDL_config_minimal.h"
diff --git a/include/SDL_config_vita.h b/include/SDL_config_vita.h
new file mode 100644
index 000000000..dee71f5dc
--- /dev/null
+++ b/include/SDL_config_vita.h
@@ -0,0 +1,163 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2016 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_config_vita_h
+#define _SDL_config_vita_h
+#define SDL_config_h_
+
+#include "SDL_platform.h"
+
+/* include stdint.h here, needed on Vita to compile the yuv_rgb.h */
+#include <stdint.h>
+
+#ifdef __GNUC__
+#define HAVE_GCC_SYNC_LOCK_TEST_AND_SET 1
+#endif
+
+#define HAVE_GCC_ATOMICS    1
+
+#define STDC_HEADERS    1
+#define HAVE_ALLOCA_H       1
+#define HAVE_CTYPE_H    1
+#define HAVE_INTTYPES_H 1
+#define HAVE_LIMITS_H   1
+#define HAVE_MATH_H 1
+#define HAVE_SIGNAL_H   1
+#define HAVE_STDINT_H   1
+#define HAVE_STDIO_H    1
+#define HAVE_STRING_H   1
+#define HAVE_SYS_TYPES_H    1
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC    1
+#define HAVE_FREE   1
+#define HAVE_ALLOCA 1
+#define HAVE_GETENV 1
+#define HAVE_SETENV 1
+#define HAVE_PUTENV 1
+#define HAVE_SETENV 1
+#define HAVE_UNSETENV   1
+#define HAVE_QSORT  1
+#define HAVE_ABS    1
+#define HAVE_BCOPY  1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE    1
+#define HAVE_MEMCMP 1
+#define HAVE_STRLEN 1
+#define HAVE_STRLCPY    1
+#define HAVE_STRLCAT    1
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR    1
+#define HAVE_STRSTR 1
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL    1
+#define HAVE_STRTOLL    1
+#define HAVE_STRTOULL   1
+#define HAVE_STRTOD 1
+#define HAVE_ATOI   1
+#define HAVE_ATOF   1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP    1
+#define HAVE_STRCASECMP 1
+#define HAVE_STRNCASECMP 1
+#define HAVE_VSSCANF 1
+#define HAVE_VSNPRINTF  1
+#define HAVE_M_PI   1
+#define HAVE_ACOS   1
+#define HAVE_ACOSF  1
+#define HAVE_ASIN   1
+#define HAVE_ASINF  1
+#define HAVE_ATAN   1
+#define HAVE_ATANF  1
+#define HAVE_ATAN2  1
+#define HAVE_ATAN2F 1
+#define HAVE_CEIL   1
+#define HAVE_CEILF  1
+#define HAVE_COPYSIGN   1
+#define HAVE_COPYSIGNF  1
+#define HAVE_COS    1
+#define HAVE_COSF   1
+#define HAVE_EXP    1
+#define HAVE_EXPF   1
+#define HAVE_FABS   1
+#define HAVE_FABSF  1
+#define HAVE_FLOOR  1
+#define HAVE_FLOORF 1
+#define HAVE_FMOD   1
+#define HAVE_FMODF  1
+#define HAVE_LOG    1
+#define HAVE_LOGF   1
+#define HAVE_POW    1
+#define HAVE_POWF   1
+#define HAVE_SCALBN 1
+#define HAVE_SCALBNF    1
+#define HAVE_SIN    1
+#define HAVE_SINF   1
+#define HAVE_SQRT   1
+#define HAVE_SQRTF  1
+#define HAVE_TAN    1
+#define HAVE_TANF   1
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP  1
+#define HAVE_LOG10 1
+#define HAVE_LOG10F 1
+/* #define HAVE_SYSCONF  1 */
+/* #define HAVE_SIGACTION    1 */
+
+
+/* VITA isn't that sophisticated */
+#define LACKS_SYS_MMAN_H 1
+
+/* enable optimized blitters */
+#define SDL_ARM_SIMD_BLITTERS 1
+#define SDL_ARM_NEON_BLITTERS 1
+
+#define SDL_AUDIO_DRIVER_VITA  1
+#define SDL_THREAD_VITA    1
+#define SDL_JOYSTICK_VITA   1
+#define SDL_TIMERS_VITA 1
+#define SDL_POWER_VITA 1
+#define SDL_VIDEO_DRIVER_VITA  1
+#define SDL_FILESYSTEM_VITA   1
+#define SDL_SENSOR_VITA 1
+
+//#if defined(_VITA_GLES2_)
+ #define SDL_VIDEO_RENDER_VITA_GLES2 1
+//#else
+ #define SDL_VIDEO_RENDER_VITA_GXM 1
+//#endif
+
+#if defined(SDL_VIDEO_RENDER_VITA_GLES2) || defined(SDL_VIDEO_RENDER_VITA_GXM)
+ #define SDL_VIDEO_OPENGL_ES2 1
+#endif
+
+
+/* VITA doesn't have haptic device (src/haptic/dummy/\*.c) */
+#define SDL_HAPTIC_DISABLED    1
+
+/* VITA can't load shared object (src/loadso/dummy/\*.c) */
+// that' not true, but oh well
+#define SDL_LOADSO_DISABLED    1
+
+#endif /* _SDL_config_vita_h */
diff --git a/src/SDL.c b/src/SDL.c
index 680ed2e7d..675f07f15 100644
--- a/src/SDL.c
+++ b/src/SDL.c
@@ -510,6 +510,8 @@ SDL_GetPlatform()
     return "iOS";
 #elif __PSP__
     return "PlayStation Portable";
+#elif __VITA__
+    return "PlayStation Vita";
 #else
     return "Unknown (see SDL_platform.h)";
 #endif
diff --git a/src/SDL_log.c b/src/SDL_log.c
index 73c4c14a9..6f16ae11e 100644
--- a/src/SDL_log.c
+++ b/src/SDL_log.c
@@ -422,6 +422,13 @@ SDL_LogOutput(void *userdata, int category, SDL_LogPriority priority,
         fprintf(pFile, "%s: %s\n", SDL_priority_prefixes[priority], message);
         fclose (pFile);
     }
+#elif defined(__VITA__)
+    {
+        FILE*        pFile;
+        pFile = fopen ("ux0:/data/SDL_Log.txt", "a");
+        fprintf(pFile, "%s: %s\n", SDL_priority_prefixes[priority], message);
+        fclose (pFile);
+    }
 #endif
 #if HAVE_STDIO_H
     fprintf(stderr, "%s: %s\n", SDL_priority_prefixes[priority], message);
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index 313749323..6db99a6b5 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -98,6 +98,9 @@ static const AudioBootStrap *const bootstrap[] = {
 #if SDL_AUDIO_DRIVER_PSP
     &PSPAUDIO_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_VITA
+    &VITAAUD_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_EMSCRIPTEN
     &EMSCRIPTENAUDIO_bootstrap,
 #endif
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index 7359adcc9..08f4b2fbf 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -206,6 +206,7 @@ extern AudioBootStrap FUSIONSOUND_bootstrap;
 extern AudioBootStrap openslES_bootstrap;
 extern AudioBootStrap ANDROIDAUDIO_bootstrap;
 extern AudioBootStrap PSPAUDIO_bootstrap;
+extern AudioBootStrap VITAAUD_bootstrap;
 extern AudioBootStrap EMSCRIPTENAUDIO_bootstrap;
 
 #endif /* SDL_sysaudio_h_ */
diff --git a/src/audio/vita/SDL_vitaaudio.c b/src/audio/vita/SDL_vitaaudio.c
new file mode 100644
index 000000000..24aa0f5be
--- /dev/null
+++ b/src/audio/vita/SDL_vitaaudio.c
@@ -0,0 +1,190 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_AUDIO_DRIVER_VITA
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <malloc.h>
+
+#include "SDL_audio.h"
+#include "SDL_error.h"
+#include "SDL_timer.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_audiodev_c.h"
+#include "../SDL_sysaudio.h"
+#include "SDL_vitaaudio.h"
+
+#include <psp2/kernel/threadmgr.h>
+#include <psp2/audioout.h>
+
+#define SCE_AUDIO_SAMPLE_ALIGN(s)   (((s) + 63) & ~63)
+#define SCE_AUDIO_MAX_VOLUME      0x8000
+
+/* The tag name used by VITA audio */
+#define VITAAUD_DRIVER_NAME         "vita"
+
+static int
+VITAAUD_OpenDevice(_THIS, void *handle, const char *devname, int iscapture)
+{
+    int format, mixlen, i, port = SCE_AUDIO_OUT_PORT_TYPE_MAIN;
+
+    this->hidden = (struct SDL_PrivateAudioData *)
+        SDL_malloc(sizeof(*this->hidden));
+    if (this->hidden == NULL) {
+        return SDL_OutOfMemory();
+    }
+    SDL_memset(this->hidden, 0, sizeof(*this->hidden));
+    switch (this->spec.format & 0xff) {
+        case 8:
+        case 16:
+            this->spec.format = AUDIO_S16LSB;
+            break;
+        default:
+            return SDL_SetError("Unsupported audio format");
+    }
+
+    /* The sample count must be a multiple of 64. */
+    this->spec.samples = SCE_AUDIO_SAMPLE_ALIGN(this->spec.samples);
+
+    /* Update the fragment size as size in bytes. */
+    SDL_CalculateAudioSpec(&this->spec);
+
+    /* Allocate the mixing buffer.  Its size and starting address must
+       be a multiple of 64 bytes.  Our sample count is already a multiple of
+       64, so spec->size should be a multiple of 64 as well. */
+    mixlen = this->spec.size * NUM_BUFFERS;
+    this->hidden->rawbuf = (Uint8 *) memalign(64, mixlen);
+    if (this->hidden->rawbuf == NULL) {
+        return SDL_SetError("Couldn't allocate mixing buffer");
+    }
+
+    /* Setup the hardware channel. */
+    if (this->spec.channels == 1) {
+        format = SCE_AUDIO_OUT_MODE_MONO;
+    } else {
+        format = SCE_AUDIO_OUT_MODE_STEREO;
+    }
+
+    if(this->spec.freq < 48000) {
+		port = SCE_AUDIO_OUT_PORT_TYPE_BGM;
+	}
+
+    this->hidden->channel = sceAudioOutOpenPort(port, this->spec.samples, this->spec.freq, format);
+    if (this->hidden->channel < 0) {
+        free(this->hidden->rawbuf);
+        this->hidden->rawbuf = NULL;
+        return SDL_SetError("Couldn't reserve hardware channel");
+    }
+
+    memset(this->hidden->rawbuf, 0, mixlen);
+    for (i = 0; i < NUM_BUFFERS; i++) {
+        this->hidden->mixbufs[i] = &this->hidden->rawbuf[i * this->spec.size];
+    }
+
+    this->hidden->next_buffer = 0;
+    return 0;
+}
+
+static void VITAAUD_PlayDevice(_THIS)
+{
+    Uint8 *mixbuf = this->hidden->mixbufs[this->hidden->next_buffer];
+
+    int vols[2] = {SCE_AUDIO_MAX_VOLUME, SCE_AUDIO_MAX_VOLUME};
+    sceAudioOutSetVolume(this->hidden->channel, SCE_AUDIO_VOLUME_FLAG_L_CH|SCE_AUDIO_VOLUME_FLAG_R_CH, vols);
+    sceAudioOutOutput(this->hidden->channel, mixbuf);
+
+    this->hidden->next_buffer = (this->hidden->next_buffer + 1) % NUM_BUFFERS;
+}
+
+/* This function waits until it is possible to write a full sound buffer */
+static void VITAAUD_WaitDevice(_THIS)
+{
+    /* Because we block when sending audio, there's no need for this function to do anything. */
+}
+static Uint8 *VITAAUD_GetDeviceBuf(_THIS)
+{
+    return this->hidden->mixbufs[this->hidden->next_buffer];
+}
+
+static void VITAAUD_CloseDevice(_THIS)
+{
+    if (this->hidden->channel >= 0) {
+        sceAudioOutReleasePort(this->hidden->channel);
+        this->hidden->channel = -1;
+    }
+
+    if (this->hidden->rawbuf != NULL) {
+        free(this->hidden->rawbuf);
+        this->hidden->rawbuf = NULL;
+    }
+}
+static void VITAAUD_ThreadInit(_THIS)
+{
+    /* Increase the priority of this audio thread by 1 to put it
+       ahead of other SDL threads. */
+    SceUID thid;
+    SceKernelThreadInfo info;
+    thid = sceKernelGetThreadId();
+    info.size = sizeof(SceKernelThreadInfo);
+    if (sceKernelGetThreadInfo(thid, &info) == 0) {
+        sceKernelChangeThreadPriority(thid, info.currentPriority - 1);
+    }
+}
+
+
+static int
+VITAAUD_Init(SDL_AudioDriverImpl * impl)
+{
+
+    /* Set the function pointers */
+    impl->OpenDevice = VITAAUD_OpenDevice;
+    impl->PlayDevice = VITAAUD_PlayDevice;
+    impl->WaitDevice = VITAAUD_WaitDevice;
+    impl->GetDeviceBuf = VITAAUD_GetDeviceBuf;
+    impl->CloseDevice = VITAAUD_CloseDevice;
+    impl->ThreadInit = VITAAUD_ThreadInit;
+
+    /* VITA audio device */
+    impl->OnlyHasDefaultOutputDevice = 1;
+/*
+    impl->HasCaptureSupport = 1;
+
+    impl->OnlyHasDefaultInputDevice = 1;
+*/
+    /*
+    impl->DetectDevices = DSOUND_DetectDevices;
+    impl->Deinitialize = DSOUND_Deinitialize;
+    */
+    return 1;   /* this audio target is available. */
+}
+
+AudioBootStrap VITAAUD_bootstrap = {
+    "vita", "VITA audio driver", VITAAUD_Init, 0
+};
+
+ /* SDL_AUDI */
+
+#endif /* SDL_AUDIO_DRIVER_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/audio/vita/SDL_vitaaudio.h b/src/audio/vita/SDL_vitaaudio.h
new file mode 100644
index 000000000..0c1ad523b
--- /dev/null
+++ b/src/audio/vita/SDL_vitaaudio.h
@@ -0,0 +1,45 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_vitaaudio_h
+#define _SDL_vitaaudio_h
+
+#include "../SDL_sysaudio.h"
+
+/* Hidden "this" pointer for the audio functions */
+#define _THIS   SDL_AudioDevice *this
+
+#define NUM_BUFFERS 2
+
+struct SDL_PrivateAudioData {
+    /* The hardware output channel. */
+    int     channel;
+    /* The raw allocated mixing buffer. */
+    Uint8   *rawbuf;
+    /* Individual mixing buffers. */
+    Uint8   *mixbufs[NUM_BUFFERS];
+    /* Index of the next available mixing buffer. */
+    int     next_buffer;
+};
+
+#endif /* _SDL_vitaaudio_h */
+/* vim: ts=4 sw=4
+ */
diff --git a/src/cpuinfo/SDL_cpuinfo.c b/src/cpuinfo/SDL_cpuinfo.c
index 9cecb4f16..cb801f564 100644
--- a/src/cpuinfo/SDL_cpuinfo.c
+++ b/src/cpuinfo/SDL_cpuinfo.c
@@ -452,6 +452,8 @@ CPU_haveNEON(void)
     return IsProcessorFeaturePresent(PF_ARM_NEON_INSTRUCTIONS_AVAILABLE) != 0;
 #elif defined(__ARM_ARCH) && (__ARM_ARCH >= 8)
     return 1;  /* ARMv8 always has non-optional NEON support. */
+#elif __VITA__
+    return 1;
 #elif defined(__APPLE__) && defined(__ARM_ARCH) && (__ARM_ARCH >= 7)
     /* (note that sysctlbyname("hw.optional.neon") doesn't work!) */
     return 1;  /* all Apple ARMv7 chips and later have NEON. */
diff --git a/src/dynapi/SDL_dynapi.h b/src/dynapi/SDL_dynapi.h
index 764e5d978..25b1fbce7 100644
--- a/src/dynapi/SDL_dynapi.h
+++ b/src/dynapi/SDL_dynapi.h
@@ -57,6 +57,8 @@
 #define SDL_DYNAMIC_API 0
 #elif defined(__clang_analyzer__)
 #define SDL_DYNAMIC_API 0  /* Turn off for static analysis, so reports are more clear. */
+#elif defined(__VITA__)
+#define SDL_DYNAMIC_API 0  /* vitasdk doesn't support dynamic linking */
 #endif
 
 /* everyone else. This is where we turn on the API if nothing forced it off. */
diff --git a/src/file/SDL_rwops.c b/src/file/SDL_rwops.c
index 2dc986bd1..3d8802a57 100644
--- a/src/file/SDL_rwops.c
+++ b/src/file/SDL_rwops.c
@@ -589,7 +589,21 @@ SDL_RWFromFile(const char *file, const char *mode)
     rwops->write = windows_file_write;
     rwops->close = windows_file_close;
     rwops->type = SDL_RWOPS_WINFILE;
-
+#elif defined(__VITA__)
+    /* Try to open the file on the filesystem first */
+    FILE *fp = fopen(file, mode);
+    if (fp) {
+        return SDL_RWFromFP(fp, 1);
+    } else {
+        /* Try opening it from app0:/ container if it's a relative path */
+        char path[4096];
+        SDL_snprintf(path, 4096, "app0:/%s", file);
+        fp = fopen(path, mode);
+        if (fp) {
+            return SDL_RWFromFP(fp, 1);
+        }
+    }
+    SDL_SetError("Couldn't open %s", file);
 #elif HAVE_STDIO_H
     {
         #ifdef __APPLE__
diff --git a/src/filesystem/vita/SDL_sysfilesystem.c b/src/filesystem/vita/SDL_sysfilesystem.c
new file mode 100644
index 000000000..3d21604cf
--- /dev/null
+++ b/src/filesystem/vita/SDL_sysfilesystem.c
@@ -0,0 +1,95 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_FILESYSTEM_VITA
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* System dependent filesystem routines                                */
+
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <psp2/kernel/iofilemgr.h>
+#include <sys/types.h>
+#include <limits.h>
+#include <fcntl.h>
+
+#include "SDL_error.h"
+#include "SDL_stdinc.h"
+#include "SDL_filesystem.h"
+#include "SDL_rwops.h"
+
+char *
+SDL_GetBasePath(void)
+{
+    const char *basepath = "app0:/";
+    char *retval = SDL_strdup(basepath);
+    return retval;
+}
+
+char *
+SDL_GetPrefPath(const char *org, const char *app)
+{
+    const char *envr = "ux0:/data/";
+    char *retval = NULL;
+    char *ptr = NULL;
+    size_t len = 0;
+
+    if (!app) {
+        SDL_InvalidParamError("app");
+        return NULL;
+    }
+    if (!org) {
+        org = "";
+    }
+
+    len = SDL_strlen(envr);
+
+    len += SDL_strlen(org) + SDL_strlen(app) + 3;
+    retval = (char *) SDL_malloc(len);
+    if (!retval) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    if (*org) {
+        SDL_snprintf(retval, len, "%s%s/%s/", envr, org, app);
+    } else {
+        SDL_snprintf(retval, len, "%s%s/", envr, app);
+    }
+
+    for (ptr = retval+1; *ptr; ptr++) {
+        if (*ptr == '/') {
+            *ptr = '\0';
+            sceIoMkdir(retval, 0777);
+            *ptr = '/';
+        }
+    }
+    sceIoMkdir(retval, 0777);
+
+    return retval;
+}
+
+#endif /* SDL_FILESYSTEM_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/joystick/SDL_gamecontrollerdb.h b/src/joystick/SDL_gamecontrollerdb.h
index 45379dabd..bb42c79a7 100644
--- a/src/joystick/SDL_gamecontrollerdb.h
+++ b/src/joystick/SDL_gamecontrollerdb.h
@@ -668,6 +668,9 @@ static const char *s_ControllerMappings [] =
 #endif
 #if defined(SDL_JOYSTICK_EMSCRIPTEN)
     "default,Standard Gamepad,a:b0,b:b1,back:b8,dpdown:b13,dpleft:b14,dpright:b15,dpup:b12,guide:b16,leftshoulder:b4,leftstick:b10,lefttrigger:b6,leftx:a0,lefty:a1,rightshoulder:b5,rightstick:b11,righttrigger:b7,rightx:a2,righty:a3,start:b9,x:b2,y:b3,",
+#endif
+#if defined(SDL_JOYSTICK_VITA)
+    "50535669746120436f6e74726f6c6c65,PSVita Controller,y:b0,b:b1,a:b2,x:b3,leftshoulder:b4,rightshoulder:b5,dpdown:b6,dpleft:b7,dpup:b8,dpright:b9,back:b10,start:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,",
 #endif
     "hidapi,*,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
     NULL
diff --git a/src/joystick/SDL_joystick.c b/src/joystick/SDL_joystick.c
index 95aac9c6f..f99890337 100644
--- a/src/joystick/SDL_joystick.c
+++ b/src/joystick/SDL_joystick.c
@@ -74,6 +74,9 @@ static SDL_JoystickDriver *SDL_joystick_drivers[] = {
 #ifdef SDL_JOYSTICK_HIDAPI
     &SDL_HIDAPI_JoystickDriver,
 #endif
+#ifdef SDL_JOYSTICK_VITA
+    &SDL_VITA_JoystickDriver
+#endif
 #if defined(SDL_JOYSTICK_DUMMY) || defined(SDL_JOYSTICK_DISABLED)
     &SDL_DUMMY_JoystickDriver
 #endif
diff --git a/src/joystick/SDL_sysjoystick.h b/src/joystick/SDL_sysjoystick.h
index 6eb8bf47e..b35d243d7 100644
--- a/src/joystick/SDL_sysjoystick.h
+++ b/src/joystick/SDL_sysjoystick.h
@@ -153,6 +153,7 @@ extern SDL_JoystickDriver SDL_HIDAPI_JoystickDriver;
 extern SDL_JoystickDriver SDL_IOS_JoystickDriver;
 extern SDL_JoystickDriver SDL_LINUX_JoystickDriver;
 extern SDL_JoystickDriver SDL_WINDOWS_JoystickDriver;
+extern SDL_JoystickDriver SDL_VITA_JoystickDriver;
 
 #endif /* SDL_sysjoystick_h_ */
 
diff --git a/src/joystick/vita/SDL_sysjoystick.c b/src/joystick/vita/SDL_sysjoystick.c
new file mode 100644
index 000000000..2ce10907b
--- /dev/null
+++ b/src/joystick/vita/SDL_sysjoystick.c
@@ -0,0 +1,317 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_JOYSTICK_VITA
+
+/* This is the PSVita implementation of the SDL joystick API */
+#include <psp2/types.h>
+#include <psp2/ctrl.h>
+#include <psp2/kernel/threadmgr.h>
+
+#include <stdio.h>      /* For the definition of NULL */
+#include <stdlib.h>
+
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+#include "SDL_events.h"
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "SDL_mutex.h"
+#include "SDL_timer.h"
+
+/* Current pad state */
+static SceCtrlData pad0 = { .lx = 0, .ly = 0, .rx = 0, .ry = 0, .buttons = 0 };
+static SceCtrlData pad1 = { .lx = 0, .ly = 0, .rx = 0, .ry = 0, .buttons = 0 };
+static SceCtrlData pad2 = { .lx = 0, .ly = 0, .rx = 0, .ry = 0, .buttons = 0 };
+static SceCtrlData pad3 = { .lx = 0, .ly = 0, .rx = 0, .ry = 0, .buttons = 0 };
+static int port_map[4]= { 0, 2, 3, 4 }; //index: SDL joy number, entry: Vita port number
+static int SDL_numjoysticks = 1;
+static const unsigned int button_map[] = {
+    SCE_CTRL_TRIANGLE, SCE_CTRL_CIRCLE, SCE_CTRL_CROSS, SCE_CTRL_SQUARE,
+    SCE_CTRL_LTRIGGER, SCE_CTRL_RTRIGGER,
+    SCE_CTRL_DOWN, SCE_CTRL_LEFT, SCE_CTRL_UP, SCE_CTRL_RIGHT,
+    SCE_CTRL_SELECT, SCE_CTRL_START};
+static int analog_map[256];  /* Map analog inputs to -32768 -> 32767 */
+
+typedef struct
+{
+  int x;
+  int y;
+} point;
+
+/* 4 points define the bezier-curve. */
+/* The Vita has a good amount of analog travel, so use a linear curve */
+static point a = { 0, 0 };
+static point b = { 0, 0  };
+static point c = { 128, 32767 };
+static point d = { 128, 32767 };
+
+/* simple linear interpolation between two points */
+static SDL_INLINE void lerp (point *dest, point *a, point *b, float t)
+{
+    dest->x = a->x + (b->x - a->x)*t;
+    dest->y = a->y + (b->y - a->y)*t;
+}
+
+/* evaluate a point on a bezier-curve. t goes from 0 to 1.0 */
+static int calc_bezier_y(float t)
+{
+    point ab, bc, cd, abbc, bccd, dest;
+    lerp (&ab, &a, &b, t);           /* point between a and b */
+    lerp (&bc, &b, &c, t);           /* point between b and c */
+    lerp (&cd, &c, &d, t);           /* point between c and d */
+    lerp (&abbc, &ab, &bc, t);       /* point between ab and bc */
+    lerp (&bccd, &bc, &cd, t);       /* point between bc and cd */
+    lerp (&dest, &abbc, &bccd, t);   /* point on the bezier-curve */
+    return dest.y;
+}
+
+/* Function to scan the system for joysticks.
+ * Joystick 0 should be the system default joystick.
+ * It should return number of joysticks, or -1 on an unrecoverable fatal error.
+ */
+int VITA_JoystickInit(void)
+{
+    int i;
+
+    /* Setup input */
+    sceCtrlSetSamplingMode(SCE_CTRL_MODE_ANALOG_WIDE);
+
+    /* Create an accurate map from analog inputs (0 to 255)
+       to SDL joystick positions (-32768 to 32767) */
+    for (i = 0; i < 128; i++)
+    {
+        float t = (float)i/127.0f;
+        analog_map[i+128] = calc_bezier_y(t);
+        analog_map[127-i] = -1 * analog_map[i+128];
+    }
+
+	SceCtrlPortInfo myPortInfo;
+
+	// Assume we have at least one controller, even when nothing is paired
+	// This way the user can jump in, pair a controller
+	// and control things immediately even if it is paired
+	// after the app has already started.
+
+	SDL_numjoysticks = 1;
+
+	//How many additional paired controllers are there?
+	sceCtrlGetControllerPortInfo(&myPortInfo);
+	//On Vita TV, port 0 and 1 are the same controller
+	//and that is the first one, so start at port 2
+	for (i=2; i<=4; i++)
+	{
+		if (myPortInfo.port[i]!=SCE_CTRL_TYPE_UNPAIRED)
+		{
+			SDL_numjoysticks++;
+		}
+	}
+  return SDL_numjoysticks;
+}
+
+int VITA_JoystickGetCount()
+{
+    return SDL_numjoysticks;
+}
+
+void VITA_JoystickDetect()
+{
+}
+
+/* Function to perform the mapping from device index to the instance id for this index */
+SDL_JoystickID VITA_JoystickGetDeviceInstanceID(int device_index)
+{
+    return device_index;
+}
+
+/* Function to get the device-dependent name of a joystick */
+const char *VITA_JoystickGetDeviceName(int index)
+{
+    if (index == 0)
+        return "PSVita Controller";
+
+    if (index == 1)
+        return "PSVita Controller";
+
+    if (index == 2)
+        return "PSVita Controller";
+
+    if (index == 3)
+        return "PSVita Controller";
+
+    SDL_SetError("No joystick available with that index");
+    return(NULL);
+}
+
+static int
+VITA_JoystickGetDevicePlayerIndex(int device_index)
+{
+    return -1;
+}
+
+static void
+VITA_JoystickSetDevicePlayerIndex(int device_index, int player_index)
+{
+}
+
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the device index.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+int VITA_JoystickOpen(SDL_Joystick *joystick, int device_index)
+{
+    joystick->nbuttons = sizeof(button_map)/sizeof(*button_map);
+    joystick->naxes = 4;
+    joystick->nhats = 0;
+    joystick->instance_id = device_index;
+
+    return 0;
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+void VITA_JoystickUpdate(SDL_Joystick *joystick)
+{
+    int i;
+    unsigned int buttons;
+    unsigned int changed;
+    unsigned char lx, ly, rx, ry;
+    static unsigned int old_buttons[] = { 0, 0, 0, 0 };
+    static unsigned char old_lx[] = { 0, 0, 0, 0 };
+    static unsigned char old_ly[] = { 0, 0, 0, 0 };
+    static unsigned char old_rx[] = { 0, 0, 0, 0 };
+    static unsigned char old_ry[] = { 0, 0, 0, 0 };
+    SceCtrlData *pad = NULL;
+
+    int index = (int) SDL_JoystickInstanceID(joystick);
+
+    if (index == 0) pad = &pad0;
+    else if (index == 1) pad = &pad1;
+    else if (index == 2) pad = &pad2;
+    else if (index == 3) pad = &pad3;
+    else return;
+
+    sceCtrlPeekBufferPositive(port_map[index], pad, 1);
+
+    buttons = pad->buttons;
+    lx = pad->lx;
+    ly = pad->ly;
+    rx = pad->rx;
+    ry = pad->ry;
+/*
+    for(i=0; i<sizeof(button_map)/sizeof(button_map[0]); i++) {
+        SDL_PrivateJoystickButton(
+            joystick, i,
+            (buttons & button_map[i]) ?
+            SDL_PRESSED : SDL_RELEASED);
+}
+*/
+    // Axes
+
+    if(old_lx[index] != lx) {
+        SDL_PrivateJoystickAxis(joystick, 0, analog_map[lx]);
+        old_lx[index] = lx;
+    }
+    if(old_ly[index] != ly) {
+        SDL_PrivateJoystickAxis(joystick, 1, analog_map[ly]);
+        old_ly[index] = ly;
+    }
+    if(old_rx[index] != rx) {
+        SDL_PrivateJoystickAxis(joystick, 2, analog_map[rx]);
+        old_rx[index] = rx;
+    }
+    if(old_ry[index] != ry) {
+        SDL_PrivateJoystickAxis(joystick, 3, analog_map[ry]);
+        old_ry[index] = ry;
+    }
+
+    // Buttons
+    changed = old_buttons[index] ^ buttons;
+    old_buttons[index] = buttons;
+    if(changed) {
+        for(i=0; i<sizeof(button_map)/sizeof(button_map[0]); i++) {
+            if(changed & button_map[i]) {
+                SDL_PrivateJoystickButton(
+                    joystick, i,
+                    (buttons & button_map[i]) ?
+                    SDL_PRESSED : SDL_RELEASED);
+            }
+        }
+     }
+}
+
+/* Function to close a joystick after use */
+void VITA_JoystickClose(SDL_Joystick *joystick)
+{
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void VITA_JoystickQuit(void)
+{
+}
+
+SDL_JoystickGUID VITA_JoystickGetDeviceGUID( int device_index )
+{
+    SDL_JoystickGUID guid;
+    /* the GUID is just the first 16 chars of the name for now */
+    const char *name = VITA_JoystickGetDeviceName( device_index );
+    SDL_zero( guid );
+    SDL_memcpy( &guid, name, SDL_min( sizeof(guid), SDL_strlen( name ) ) );
+    return guid;
+}
+
+static int
+VITA_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble)
+{
+    return SDL_Unsupported();
+}
+
+
+SDL_JoystickDriver SDL_VITA_JoystickDriver =
+{
+    VITA_JoystickInit,
+    VITA_JoystickGetCount,
+    VITA_JoystickDetect,
+    VITA_JoystickGetDeviceName,
+    VITA_JoystickGetDevicePlayerIndex,
+    VITA_JoystickSetDevicePlayerIndex,
+    VITA_JoystickGetDeviceGUID,
+    VITA_JoystickGetDeviceInstanceID,
+
+    VITA_JoystickOpen,
+    VITA_JoystickRumble,
+    VITA_JoystickUpdate,
+    VITA_JoystickClose,
+    VITA_JoystickQuit,
+};
+
+
+#endif /* SDL_JOYSTICK_VITA */
+
+/* vim: ts=4 sw=4
+ */
diff --git a/src/power/SDL_power.c b/src/power/SDL_power.c
index ca19d4492..7a065c6a2 100644
--- a/src/power/SDL_power.c
+++ b/src/power/SDL_power.c
@@ -68,6 +68,9 @@ static SDL_GetPowerInfo_Impl implementations[] = {
 #ifdef SDL_POWER_PSP        /* handles PSP. */
     SDL_GetPowerInfo_PSP,
 #endif
+#ifdef SDL_POWER_VITA        /* handles PSVita. */
+    SDL_GetPowerInfo_VITA,
+#endif
 #ifdef SDL_POWER_WINRT          /* handles WinRT */
     SDL_GetPowerInfo_WinRT,
 #endif
diff --git a/src/power/SDL_syspower.h b/src/power/SDL_syspower.h
index f28cc982b..23832bf84 100644
--- a/src/power/SDL_syspower.h
+++ b/src/power/SDL_syspower.h
@@ -38,6 +38,7 @@ SDL_bool SDL_GetPowerInfo_MacOSX(SDL_PowerState *, int *, int *);
 SDL_bool SDL_GetPowerInfo_Haiku(SDL_PowerState *, int *, int *);
 SDL_bool SDL_GetPowerInfo_Android(SDL_PowerState *, int *, int *);
 SDL_bool SDL_GetPowerInfo_PSP(SDL_PowerState *, int *, int *);
+SDL_bool SDL_GetPowerInfo_VITA(SDL_PowerState *, int *, int *);
 SDL_bool SDL_GetPowerInfo_WinRT(SDL_PowerState *, int *, int *);
 SDL_bool SDL_GetPowerInfo_Emscripten(SDL_PowerState *, int *, int *);
 
diff --git a/src/power/vita/SDL_syspower.c b/src/power/vita/SDL_syspower.c
new file mode 100644
index 000000000..5aa8df0e9
--- /dev/null
+++ b/src/power/vita/SDL_syspower.c
@@ -0,0 +1,68 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifndef SDL_POWER_DISABLED
+#if SDL_POWER_VITA
+
+#include "SDL_power.h"
+#include <psp2/power.h>
+
+
+SDL_bool
+SDL_GetPowerInfo_VITA(SDL_PowerState * state, int *seconds,
+                            int *percent)
+{
+    int battery = 1;
+    int plugged = scePowerIsPowerOnline();
+    int charging = scePowerIsBatteryCharging();
+
+    *state = SDL_POWERSTATE_UNKNOWN;
+    *seconds = -1;
+    *percent = -1;
+
+    if (!battery) {
+        *state = SDL_POWERSTATE_NO_BATTERY;
+        *seconds = -1;
+        *percent = -1;
+    } else if (charging) {
+        *state = SDL_POWERSTATE_CHARGING;
+        *percent = scePowerGetBatteryLifePercent();
+        *seconds = scePowerGetBatteryLifeTime()*60;
+    } else if (plugged) {
+        *state = SDL_POWERSTATE_CHARGED;
+        *percent = scePowerGetBatteryLifePercent();
+        *seconds = scePowerGetBatteryLifeTime()*60;
+    } else {
+        *state = SDL_POWERSTATE_ON_BATTERY;
+        *percent = scePowerGetBatteryLifePercent();
+        *seconds = scePowerGetBatteryLifeTime()*60;
+    }
+
+
+    return SDL_TRUE;            /* always the definitive answer on VITA. */
+}
+
+#endif /* SDL_POWER_VITA */
+#endif /* SDL_POWER_DISABLED */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/SDL_render.c b/src/render/SDL_render.c
index 59c2f4992..e906ed19a 100644
--- a/src/render/SDL_render.c
+++ b/src/render/SDL_render.c
@@ -105,6 +105,12 @@ static const SDL_RenderDriver *render_drivers[] = {
 #if SDL_VIDEO_RENDER_PSP
     &PSP_RenderDriver,
 #endif
+#if SDL_VIDEO_RENDER_VITA_GXM
+    &VITA_GXM_RenderDriver,
+#endif
+#if SDL_VIDEO_RENDER_VITA_GLES2
+    &VITA_GLES2_RenderDriver,
+#endif
 #if SDL_VIDEO_RENDER_SW
     &SW_RenderDriver
 #endif
@@ -275,7 +281,9 @@ SDL_AllocateRenderVertices(SDL_Renderer *renderer, const size_t numbytes, const
         while (newsize < needed) {
             newsize *= 2;
         }
+
         ptr = SDL_realloc(renderer->vertex_data, newsize);
+
         if (ptr == NULL) {
             SDL_OutOfMemory();
             return NULL;
diff --git a/src/render/SDL_sysrender.h b/src/render/SDL_sysrender.h
index d6b2f3dab..00613807b 100644
--- a/src/render/SDL_sysrender.h
+++ b/src/render/SDL_sysrender.h
@@ -237,6 +237,8 @@ extern SDL_RenderDriver DirectFB_RenderDriver;
 extern SDL_RenderDriver METAL_RenderDriver;
 extern SDL_RenderDriver PSP_RenderDriver;
 extern SDL_RenderDriver SW_RenderDriver;
+extern SDL_RenderDriver VITA_GLES2_RenderDriver;
+extern SDL_RenderDriver VITA_GXM_RenderDriver;
 
 /* Blend mode functions */
 extern SDL_BlendFactor SDL_GetBlendModeSrcColorFactor(SDL_BlendMode blendMode);
diff --git a/src/render/opengles2/SDL_render_gles2.c b/src/render/opengles2/SDL_render_gles2.c
index fb83c875d..c871ed443 100644
--- a/src/render/opengles2/SDL_render_gles2.c
+++ b/src/render/opengles2/SDL_render_gles2.c
@@ -2057,7 +2057,11 @@ GLES2_CreateRenderer(SDL_Window *window, Uint32 flags)
     nFormats = 1;
 #else /* !ZUNE_HD */
     data->glGetIntegerv(GL_NUM_SHADER_BINARY_FORMATS, &nFormats);
+#if defined(__VITA__)
+    hasCompiler = GL_TRUE;
+#else
     data->glGetBooleanv(GL_SHADER_COMPILER, &hasCompiler);
+#endif
     if (hasCompiler) {
         ++nFormats;
     }
diff --git a/src/render/vitagles2/SDL_gles2funcs.h b/src/render/vitagles2/SDL_gles2funcs.h
new file mode 100644
index 000000000..94cfb8749
--- /dev/null
+++ b/src/render/vitagles2/SDL_gles2funcs.h
@@ -0,0 +1,77 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+SDL_PROC(void, glActiveTexture, (GLenum))
+SDL_PROC(void, glAttachShader, (GLuint, GLuint))
+SDL_PROC(void, glBindAttribLocation, (GLuint, GLuint, const char *))
+SDL_PROC(void, glBindTexture, (GLenum, GLuint))
+SDL_PROC(void, glBlendEquationSeparate, (GLenum, GLenum))
+SDL_PROC(void, glBlendFuncSeparate, (GLenum, GLenum, GLenum, GLenum))
+SDL_PROC(void, glClear, (GLbitfield))
+SDL_PROC(void, glClearColor, (GLclampf, GLclampf, GLclampf, GLclampf))
+SDL_PROC(void, glCompileShader, (GLuint))
+SDL_PROC(GLuint, glCreateProgram, (void))
+SDL_PROC(GLuint, glCreateShader, (GLenum))
+SDL_PROC(void, glDeleteProgram, (GLuint))
+SDL_PROC(void, glDeleteShader, (GLuint))
+SDL_PROC(void, glDeleteTextures, (GLsizei, const GLuint *))
+SDL_PROC(void, glDisable, (GLenum))
+SDL_PROC(void, glDisableVertexAttribArray, (GLuint))
+SDL_PROC(void, glDrawArrays, (GLenum, GLint, GLsizei))
+SDL_PROC(void, glEnable, (GLenum))
+SDL_PROC(void, glEnableVertexAttribArray, (GLuint))
+SDL_PROC(void, glFinish, (void))
+SDL_PROC(void, glGenFramebuffers, (GLsizei, GLuint *))
+SDL_PROC(void, glGenTextures, (GLsizei, GLuint *))
+SDL_PROC(void, glGetBooleanv, (GLenum, GLboolean *))
+SDL_PROC(const GLubyte *, glGetString, (GLenum))
+SDL_PROC(GLenum, glGetError, (void))
+SDL_PROC(void, glGetIntegerv, (GLenum, GLint *))
+SDL_PROC(void, glGetProgramiv, (GLuint, GLenum, GLint *))
+SDL_PROC(void, glGetShaderInfoLog, (GLuint, GLsizei, GLsizei *, char *))
+SDL_PROC(void, glGetShaderiv, (GLuint, GLenum, GLint *))
+SDL_PROC(GLint, glGetUniformLocation, (GLuint, const char *))
+SDL_PROC(void, glLinkProgram, (GLuint))
+SDL_PROC(void, glPixelStorei, (GLenum, GLint))
+SDL_PROC(void, glReadPixels, (GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid*))
+SDL_PROC(void, glScissor, (GLint, GLint, GLsizei, GLsizei))
+SDL_PROC(void, glShaderBinary, (GLsizei, const GLuint *, GLenum, const void *, GLsizei))
+SDL_PROC(void, glShaderSource, (GLuint, GLsizei, const GLchar* const*, const GLint *))
+SDL_PROC(void, glTexImage2D, (GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const void *))
+SDL_PROC(void, glTexParameteri, (GLenum, GLenum, GLint))
+SDL_PROC(void, glTexSubImage2D, (GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))
+SDL_PROC(void, glUniform1i, (GLint, GLint))
+SDL_PROC(void, glUniform4f, (GLint, GLfloat, GLfloat, GLfloat, GLfloat))
+SDL_PROC(void, glUniformMatrix4fv, (GLint, GLsizei, GLboolean, const GLfloat *))
+SDL_PROC(void, glUseProgram, (GLuint))
+SDL_PROC(void, glVertexAttribPointer, (GLuint, GLint, GLenum, GLboolean, GLsizei, const void *))
+SDL_PROC(void, glViewport, (GLint, GLint, GLsizei, GLsizei))
+SDL_PROC(void, glBindFramebuffer, (GLenum, GLuint))
+SDL_PROC(void, glFramebufferTexture2D, (GLenum, GLenum, GLenum, GLuint, GLint))
+SDL_PROC(GLenum, glCheckFramebufferStatus, (GLenum))
+SDL_PROC(void, glDeleteFramebuffers, (GLsizei, const GLuint *))
+SDL_PROC(GLint, glGetAttribLocation, (GLuint, const GLchar *))
+SDL_PROC(void, glGetProgramInfoLog, (GLuint, GLsizei, GLsizei*, GLchar*))
+SDL_PROC(void, glGenBuffers, (GLsizei, GLuint *))
+SDL_PROC(void, glDeleteBuffers, (GLsizei, const GLuint *))
+SDL_PROC(void, glBindBuffer, (GLenum, GLuint))
+SDL_PROC(void, glBufferData, (GLenum, GLsizeiptr, const GLvoid *, GLenum))
+SDL_PROC(void, glBufferSubData, (GLenum, GLintptr, GLsizeiptr, const GLvoid *))
diff --git a/src/render/vitagles2/SDL_render_gles2vita.c b/src/render/vitagles2/SDL_render_gles2vita.c
new file mode 100644
index 000000000..97a23ce16
--- /dev/null
+++ b/src/render/vitagles2/SDL_render_gles2vita.c
@@ -0,0 +1,2107 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_VITA_GLES2 && !SDL_RENDER_DISABLED
+
+#include "SDL_assert.h"
+#include "SDL_hints.h"
+#include "SDL_opengles2.h"
+#include "../SDL_sysrender.h"
+#include "../../video/SDL_blit.h"
+#include "SDL_shaders_gles2vita.h"
+
+//#include <psp2/gxm.h>
+//#include <psp2/types.h>
+//#include <psp2/kernel/sysmem.h>
+
+/* To prevent unnecessary window recreation,
+ * these should match the defaults selected in SDL_GL_ResetAttributes
+ */
+#define RENDERER_CONTEXT_MAJOR 2
+#define RENDERER_CONTEXT_MINOR 0
+
+/* Used to re-create the window with OpenGL ES capability */
+extern int SDL_RecreateWindow(SDL_Window * window, Uint32 flags);
+
+/*************************************************************************************************
+ * Context structures                                                                            *
+ *************************************************************************************************/
+
+typedef struct VITA_GLES2_FBOList VITA_GLES2_FBOList;
+
+struct VITA_GLES2_FBOList
+{
+   Uint32 w, h;
+   GLuint FBO;
+   VITA_GLES2_FBOList *next;
+};
+
+typedef struct VITA_GLES2_TextureData
+{
+    GLenum texture;
+    GLenum texture_type;
+    GLenum pixel_format;
+    GLenum pixel_type;
+    void *pixel_data;
+    int pitch;
+    /* YUV texture support */
+    SDL_bool yuv;
+    SDL_bool nv12;
+    GLenum texture_v;
+    GLenum texture_u;
+    VITA_GLES2_FBOList *fbo;
+} VITA_GLES2_TextureData;
+
+typedef struct VITA_GLES2_ShaderCacheEntry
+{
+    GLuint id;
+    VITA_GLES2_ShaderType type;
+    const VITA_GLES2_ShaderInstance *instance;
+    int references;
+    struct VITA_GLES2_ShaderCacheEntry *prev;
+    struct VITA_GLES2_ShaderCacheEntry *next;
+} VITA_GLES2_ShaderCacheEntry;
+
+typedef struct VITA_GLES2_ShaderCache
+{
+    int count;
+    VITA_GLES2_ShaderCacheEntry *head;
+} VITA_GLES2_ShaderCache;
+
+typedef struct VITA_GLES2_ProgramCacheEntry
+{
+    GLuint id;
+    VITA_GLES2_ShaderCacheEntry *vertex_shader;
+    VITA_GLES2_ShaderCacheEntry *fragment_shader;
+    GLuint uniform_locations[16];
+    Uint32 color;
+    GLfloat projection[4][4];
+    struct VITA_GLES2_ProgramCacheEntry *prev;
+    struct VITA_GLES2_ProgramCacheEntry *next;
+} VITA_GLES2_ProgramCacheEntry;
+
+typedef struct VITA_GLES2_ProgramCache
+{
+    int count;
+    VITA_GLES2_ProgramCacheEntry *head;
+    VITA_GLES2_ProgramCacheEntry *tail;
+} VITA_GLES2_ProgramCache;
+
+typedef enum
+{
+    VITA_GLES2_ATTRIBUTE_POSITION = 0,
+    VITA_GLES2_ATTRIBUTE_TEXCOORD = 1,
+    VITA_GLES2_ATTRIBUTE_ANGLE = 2,
+    VITA_GLES2_ATTRIBUTE_CENTER = 3,
+} VITA_GLES2_Attribute;
+
+typedef enum
+{
+    VITA_GLES2_UNIFORM_PROJECTION,
+    VITA_GLES2_UNIFORM_TEXTURE,
+    VITA_GLES2_UNIFORM_COLOR,
+    VITA_GLES2_UNIFORM_TEXTURE_U,
+    VITA_GLES2_UNIFORM_TEXTURE_V
+} VITA_GLES2_Uniform;
+
+typedef enum
+{
+    VITA_GLES2_IMAGESOURCE_INVALID,
+    VITA_GLES2_IMAGESOURCE_SOLID,
+    VITA_GLES2_IMAGESOURCE_TEXTURE_ABGR,
+    VITA_GLES2_IMAGESOURCE_TEXTURE_ARGB,
+    VITA_GLES2_IMAGESOURCE_TEXTURE_RGB,
+    VITA_GLES2_IMAGESOURCE_TEXTURE_BGR,
+    VITA_GLES2_IMAGESOURCE_TEXTURE_YUV,
+    VITA_GLES2_IMAGESOURCE_TEXTURE_NV12,
+    VITA_GLES2_IMAGESOURCE_TEXTURE_NV21,
+    VITA_GLES2_IMAGESOURCE_TEXTURE_EXTERNAL_OES
+} VITA_GLES2_ImageSource;
+
+typedef struct
+{
+    SDL_Rect viewport;
+    SDL_bool viewport_dirty;
+    SDL_Texture *texture;
+    SDL_Texture *target;
+    SDL_BlendMode blend;
+    SDL_bool cliprect_enabled_dirty;
+    SDL_bool cliprect_enabled;
+    SDL_bool cliprect_dirty;
+    SDL_Rect cliprect;
+    SDL_bool texturing;
+    SDL_bool is_copy_ex;
+    Uint32 color;
+    Uint32 clear_color;
+    int drawablew;
+    int drawableh;
+    VITA_GLES2_ProgramCacheEntry *program;
+    GLfloat projection[4][4];
+} VITA_GLES2_DrawStateCache;
+
+typedef struct VITA_GLES2_RenderData
+{
+    SDL_GLContext *context;
+
+    SDL_bool debug_enabled;
+
+#define SDL_PROC(ret,func,params) ret (APIENTRY *func) params;
+#include "SDL_gles2funcs.h"
+#undef SDL_PROC
+
+    VITA_GLES2_FBOList *framebuffers;
+    GLuint window_framebuffer;
+
+    int shader_format_count;
+    GLenum *shader_formats;
+    VITA_GLES2_ShaderCache shader_cache;
+    VITA_GLES2_ProgramCache program_cache;
+    Uint8 clear_r, clear_g, clear_b, clear_a;
+
+    GLuint vertex_buffers[8];
+    size_t vertex_buffer_size[8];
+    int current_vertex_buffer;
+    VITA_GLES2_DrawStateCache drawstate;
+} VITA_GLES2_RenderData;
+
+#define VITA_GLES2_MAX_CACHED_PROGRAMS 8
+
+static const float inv255f = 1.0f / 255.0f;
+
+
+SDL_FORCE_INLINE const char*
+GL_TranslateError (GLenum error)
+{
+#define GL_ERROR_TRANSLATE(e) case e: return #e;
+    switch (error) {
+    GL_ERROR_TRANSLATE(GL_INVALID_ENUM)
+    GL_ERROR_TRANSLATE(GL_INVALID_VALUE)
+    GL_ERROR_TRANSLATE(GL_INVALID_OPERATION)
+    GL_ERROR_TRANSLATE(GL_OUT_OF_MEMORY)
+    GL_ERROR_TRANSLATE(GL_NO_ERROR)
+    default:
+        return "UNKNOWN";
+}
+#undef GL_ERROR_TRANSLATE
+}
+
+SDL_FORCE_INLINE void
+GL_ClearErrors(SDL_Renderer *renderer)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *) renderer->driverdata;
+
+    if (!data->debug_enabled) {
+        return;
+    }
+    while (data->glGetError() != GL_NO_ERROR) {
+        /* continue; */
+    }
+}
+
+SDL_FORCE_INLINE int
+GL_CheckAllErrors (const char *prefix, SDL_Renderer *renderer, const char *file, int line, const char *function)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *) renderer->driverdata;
+    int ret = 0;
+
+    if (!data->debug_enabled) {
+        return 0;
+    }
+    /* check gl errors (can return multiple errors) */
+    for (;;) {
+        GLenum error = data->glGetError();
+        if (error != GL_NO_ERROR) {
+            if (prefix == NULL || prefix[0] == '\0') {
+                prefix = "generic";
+            }
+            SDL_SetError("%s: %s (%d): %s %s (0x%X)", prefix, file, line, function, GL_TranslateError(error), error);
+            ret = -1;
+        } else {
+            break;
+        }
+    }
+    return ret;
+}
+
+#if 0
+#define GL_CheckError(prefix, renderer)
+#else
+#define GL_CheckError(prefix, renderer) GL_CheckAllErrors(prefix, renderer, SDL_FILE, SDL_LINE, SDL_FUNCTION)
+#endif
+
+/*************************************************************************************************
+ * Renderer state APIs                                                                           *
+ *************************************************************************************************/
+
+static int VITA_GLES2_LoadFunctions(VITA_GLES2_RenderData * data)
+{
+#define SDL_PROC(ret,func,params) data->func=func;
+#include "SDL_gles2funcs.h"
+#undef SDL_PROC
+    return 0;
+}
+
+static VITA_GLES2_FBOList *
+VITA_GLES2_GetFBO(VITA_GLES2_RenderData *data, Uint32 w, Uint32 h)
+{
+   VITA_GLES2_FBOList *result = data->framebuffers;
+   while ((result) && ((result->w != w) || (result->h != h)) ) {
+       result = result->next;
+   }
+   if (result == NULL) {
+       result = SDL_malloc(sizeof(VITA_GLES2_FBOList));
+       result->w = w;
+       result->h = h;
+       data->glGenFramebuffers(1, &result->FBO);
+       result->next = data->framebuffers;
+       data->framebuffers = result;
+   }
+   return result;
+}
+
+static int
+VITA_GLES2_ActivateRenderer(SDL_Renderer * renderer)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *)renderer->driverdata;
+
+    if (SDL_GL_GetCurrentContext() != data->context) {
+        /* Null out the current program to ensure we set it again */
+        data->drawstate.program = NULL;
+
+        if (SDL_GL_MakeCurrent(renderer->window, data->context) < 0) {
+            return -1;
+        }
+    }
+
+    GL_ClearErrors(renderer);
+
+    return 0;
+}
+
+static void
+VITA_GLES2_WindowEvent(SDL_Renderer * renderer, const SDL_WindowEvent *event)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *)renderer->driverdata;
+
+    if (event->event == SDL_WINDOWEVENT_MINIMIZED) {
+        /* According to Apple documentation, we need to finish drawing NOW! */
+        data->glFinish();
+    }
+}
+
+static int
+VITA_GLES2_GetOutputSize(SDL_Renderer * renderer, int *w, int *h)
+{
+    SDL_GL_GetDrawableSize(renderer->window, w, h);
+    return 0;
+}
+
+static GLenum GetBlendFunc(SDL_BlendFactor factor)
+{
+    switch (factor) {
+    case SDL_BLENDFACTOR_ZERO:
+        return GL_ZERO;
+    case SDL_BLENDFACTOR_ONE:
+        return GL_ONE;
+    case SDL_BLENDFACTOR_SRC_COLOR:
+        return GL_SRC_COLOR;
+    case SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR:
+        return GL_ONE_MINUS_SRC_COLOR;
+    case SDL_BLENDFACTOR_SRC_ALPHA:
+        return GL_SRC_ALPHA;
+    case SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA:
+        return GL_ONE_MINUS_SRC_ALPHA;
+    case SDL_BLENDFACTOR_DST_COLOR:
+        return GL_DST_COLOR;
+    case SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR:
+        return GL_ONE_MINUS_DST_COLOR;
+    case SDL_BLENDFACTOR_DST_ALPHA:
+        return GL_DST_ALPHA;
+    case SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA:
+        return GL_ONE_MINUS_DST_ALPHA;
+    default:
+        return GL_INVALID_ENUM;
+    }
+}
+
+static GLenum GetBlendEquation(SDL_BlendOperation operation)
+{
+    switch (operation) {
+    case SDL_BLENDOPERATION_ADD:
+        return GL_FUNC_ADD;
+    case SDL_BLENDOPERATION_SUBTRACT:
+        return GL_FUNC_SUBTRACT;
+    case SDL_BLENDOPERATION_REV_SUBTRACT:
+        return GL_FUNC_REVERSE_SUBTRACT;
+    default:
+        return GL_INVALID_ENUM;
+    }
+}
+
+static SDL_bool
+VITA_GLES2_SupportsBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode)
+{
+    SDL_BlendFactor srcColorFactor = SDL_GetBlendModeSrcColorFactor(blendMode);
+    SDL_BlendFactor srcAlphaFactor = SDL_GetBlendModeSrcAlphaFactor(blendMode);
+    SDL_BlendOperation colorOperation = SDL_GetBlendModeColorOperation(blendMode);
+    SDL_BlendFactor dstColorFactor = SDL_GetBlendModeDstColorFactor(blendMode);
+    SDL_BlendFactor dstAlphaFactor = SDL_GetBlendModeDstAlphaFactor(blendMode);
+    SDL_BlendOperation alphaOperation = SDL_GetBlendModeAlphaOperation(blendMode);
+
+    if (GetBlendFunc(srcColorFactor) == GL_INVALID_ENUM ||
+        GetBlendFunc(srcAlphaFactor) == GL_INVALID_ENUM ||
+        GetBlendEquation(colorOperation) == GL_INVALID_ENUM ||
+        GetBlendFunc(dstColorFactor) == GL_INVALID_ENUM ||
+        GetBlendFunc(dstAlphaFactor) == GL_INVALID_ENUM ||
+        GetBlendEquation(alphaOperation) == GL_INVALID_ENUM) {
+        return SDL_FALSE;
+    }
+    return SDL_TRUE;
+}
+
+
+static void
+VITA_GLES2_EvictShader(VITA_GLES2_RenderData *data, VITA_GLES2_ShaderCacheEntry *entry)
+{
+    /* Unlink the shader from the cache */
+    if (entry->next) {
+        entry->next->prev = entry->prev;
+    }
+    if (entry->prev) {
+        entry->prev->next = entry->next;
+    }
+    if (data->shader_cache.head == entry) {
+        data->shader_cache.head = entry->next;
+    }
+    --data->shader_cache.count;
+
+    /* Deallocate the shader */
+    data->glDeleteShader(entry->id);
+    SDL_free(entry);
+}
+
+static VITA_GLES2_ProgramCacheEntry *
+VITA_GLES2_CacheProgram(VITA_GLES2_RenderData *data, VITA_GLES2_ShaderCacheEntry *vertex,
+                   VITA_GLES2_ShaderCacheEntry *fragment)
+{
+    VITA_GLES2_ProgramCacheEntry *entry;
+    VITA_GLES2_ShaderCacheEntry *shaderEntry;
+    GLint linkSuccessful;
+
+    /* Check if we've already cached this program */
+    entry = data->program_cache.head;
+    while (entry) {
+        if (entry->vertex_shader == vertex && entry->fragment_shader == fragment) {
+            break;
+        }
+        entry = entry->next;
+    }
+    if (entry) {
+        if (data->program_cache.head != entry) {
+            if (entry->next) {
+                entry->next->prev = entry->prev;
+            }
+            if (entry->prev) {
+                entry->prev->next = entry->next;
+            }
+            entry->prev = NULL;
+            entry->next = data->program_cache.head;
+            data->program_cache.head->prev = entry;
+            data->program_cache.head = entry;
+        }
+        return entry;
+    }
+
+    /* Create a program cache entry */
+    entry = (VITA_GLES2_ProgramCacheEntry *)SDL_calloc(1, sizeof(VITA_GLES2_ProgramCacheEntry));
+    if (!entry) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+    entry->vertex_shader = vertex;
+    entry->fragment_shader = fragment;
+
+    /* Create the program and link it */
+    entry->id = data->glCreateProgram();
+    data->glAttachShader(entry->id, vertex->id);
+    data->glAttachShader(entry->id, fragment->id);
+    data->glBindAttribLocation(entry->id, VITA_GLES2_ATTRIBUTE_POSITION, "a_position");
+    data->glBindAttribLocation(entry->id, VITA_GLES2_ATTRIBUTE_TEXCOORD, "a_texCoord");
+    data->glBindAttribLocation(entry->id, VITA_GLES2_ATTRIBUTE_ANGLE, "a_angle");
+    data->glBindAttribLocation(entry->id, VITA_GLES2_ATTRIBUTE_CENTER, "a_center");
+    data->glLinkProgram(entry->id);
+    data->glGetProgramiv(entry->id, GL_LINK_STATUS, &linkSuccessful);
+    if (!linkSuccessful) {
+        data->glDeleteProgram(entry->id);
+        SDL_free(entry);
+        SDL_SetError("Failed to link shader program");
+        return NULL;
+    }
+
+    /* Predetermine locations of uniform variables */
+    entry->uniform_locations[VITA_GLES2_UNIFORM_PROJECTION] =
+        data->glGetUniformLocation(entry->id, "u_projection");
+    entry->uniform_locations[VITA_GLES2_UNIFORM_TEXTURE_V] =
+        data->glGetUniformLocation(entry->id, "u_texture_v");
+    entry->uniform_locations[VITA_GLES2_UNIFORM_TEXTURE_U] =
+        data->glGetUniformLocation(entry->id, "u_texture_u");
+    entry->uniform_locations[VITA_GLES2_UNIFORM_TEXTURE] =
+        data->glGetUniformLocation(entry->id, "u_texture");
+    entry->uniform_locations[VITA_GLES2_UNIFORM_COLOR] =
+        data->glGetUniformLocation(entry->id, "u_color");
+
+    entry->color = 0;
+
+    data->glUseProgram(entry->id);
+    if (entry->uniform_locations[VITA_GLES2_UNIFORM_TEXTURE_V] != -1) {
+        data->glUniform1i(entry->uniform_locations[VITA_GLES2_UNIFORM_TEXTURE_V], 2);  /* always texture unit 2. */
+    }
+    if (entry->uniform_locations[VITA_GLES2_UNIFORM_TEXTURE_U] != -1) {
+        data->glUniform1i(entry->uniform_locations[VITA_GLES2_UNIFORM_TEXTURE_U], 1);  /* always texture unit 1. */
+    }
+    if (entry->uniform_locations[VITA_GLES2_UNIFORM_TEXTURE] != -1) {
+        data->glUniform1i(entry->uniform_locations[VITA_GLES2_UNIFORM_TEXTURE], 0);  /* always texture unit 0. */
+    }
+    if (entry->uniform_locations[VITA_GLES2_UNIFORM_PROJECTION] != -1) {
+        data->glUniformMatrix4fv(entry->uniform_locations[VITA_GLES2_UNIFORM_PROJECTION], 1, GL_FALSE, (GLfloat *)entry->projection);
+    }
+    if (entry->uniform_locations[VITA_GLES2_UNIFORM_COLOR] != -1) {
+        data->glUniform4f(entry->uniform_locations[VITA_GLES2_UNIFORM_COLOR], 0.0f, 0.0f, 0.0f, 0.0f);
+    }
+
+    /* Cache the linked program */
+    if (data->program_cache.head) {
+        entry->next = data->program_cache.head;
+        data->program_cache.head->prev = entry;
+    } else {
+        data->program_cache.tail = entry;
+    }
+    data->program_cache.head = entry;
+    ++data->program_cache.count;
+
+    /* Increment the refcount of the shaders we're using */
+    ++vertex->references;
+    ++fragment->references;
+
+    /* Evict the last entry from the cache if we exceed the limit */
+    if (data->program_cache.count > VITA_GLES2_MAX_CACHED_PROGRAMS) {
+        shaderEntry = data->program_cache.tail->vertex_shader;
+        if (--shaderEntry->references <= 0) {
+            VITA_GLES2_EvictShader(data, shaderEntry);
+        }
+        shaderEntry = data->program_cache.tail->fragment_shader;
+        if (--shaderEntry->references <= 0) {
+            VITA_GLES2_EvictShader(data, shaderEntry);
+        }
+        data->glDeleteProgram(data->program_cache.tail->id);
+        data->program_cache.tail = data->program_cache.tail->prev;
+        if (data->program_cache.tail != NULL) {
+            SDL_free(data->program_cache.tail->next);
+            data->program_cache.tail->next = NULL;
+        }
+        --data->program_cache.count;
+    }
+    return entry;
+}
+
+static VITA_GLES2_ShaderCacheEntry *
+VITA_GLES2_CacheShader(VITA_GLES2_RenderData *data, VITA_GLES2_ShaderType type)
+{
+    const VITA_GLES2_Shader *shader;
+    const VITA_GLES2_ShaderInstance *instance = NULL;
+    VITA_GLES2_ShaderCacheEntry *entry = NULL;
+    GLint compileSuccessful = GL_FALSE;
+    int i, j;
+
+    /* Find the corresponding shader */
+    shader = VITA_GLES2_GetShader(type);
+    if (!shader) {
+        SDL_SetError("No shader matching the requested characteristics was found");
+        return NULL;
+    }
+
+    /* Find a matching shader instance that's supported on this hardware */
+    for (i = 0; i < shader->instance_count && !instance; ++i) {
+        for (j = 0; j < data->shader_format_count && !instance; ++j) {
+            if (!shader->instances[i]) {
+                continue;
+            }
+            if (shader->instances[i]->format != data->shader_formats[j]) {
+                continue;
+            }
+            instance = shader->instances[i];
+        }
+    }
+    if (!instance) {
+        SDL_SetError("The specified shader cannot be loaded on the current platform");
+        return NULL;
+    }
+
+    /* Check if we've already cached this shader */
+    entry = data->shader_cache.head;
+    while (entry) {
+        if (entry->instance == instance) {
+            break;
+        }
+        entry = entry->next;
+    }
+    if (entry) {
+        return entry;
+    }
+
+    /* Create a shader cache entry */
+    entry = (VITA_GLES2_ShaderCacheEntry *)SDL_calloc(1, sizeof(VITA_GLES2_ShaderCacheEntry));
+    if (!entry) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+    entry->type = type;
+    entry->instance = instance;
+
+    /* Compile or load the selected shader instance */
+    entry->id = data->glCreateShader(instance->type);
+    if (instance->format == (GLenum)-1) {
+        data->glShaderSource(entry->id, 1, (const char **)(char *)&instance->data, NULL);
+        data->glCompileShader(entry->id);
+        data->glGetShaderiv(entry->id, GL_COMPILE_STATUS, &compileSuccessful);
+    } else {
+        data->glShaderBinary(1, &entry->id, instance->format, instance->data, instance->length);
+        compileSuccessful = GL_TRUE;
+    }
+    if (!compileSuccessful) {
+        SDL_bool isstack = SDL_FALSE;
+        char *info = NULL;
+        int length = 0;
+
+        data->glGetShaderiv(entry->id, GL_INFO_LOG_LENGTH, &length);
+        if (length > 0) {
+            info = SDL_small_alloc(char, length, &isstack);
+            if (info) {
+                data->glGetShaderInfoLog(entry->id, length, &length, info);
+            }
+        }
+        if (info) {
+            SDL_SetError("Failed to load the shader: %s", info);
+            SDL_small_free(info, isstack);
+        } else {
+            SDL_SetError("Failed to load the shader");
+        }
+        data->glDeleteShader(entry->id);
+        SDL_free(entry);
+        return NULL;
+    }
+
+    /* Link the shader entry in at the front of the cache */
+    if (data->shader_cache.head) {
+        entry->next = data->shader_cache.head;
+        data->shader_cache.head->prev = entry;
+    }
+    data->shader_cache.head = entry;
+    ++data->shader_cache.count;
+    return entry;
+}
+
+static int
+VITA_GLES2_SelectProgram(VITA_GLES2_RenderData *data, VITA_GLES2_ImageSource source, int w, int h)
+{
+    VITA_GLES2_ShaderCacheEntry *vertex = NULL;
+    VITA_GLES2_ShaderCacheEntry *fragment = NULL;
+    VITA_GLES2_ShaderType vtype, ftype;
+    VITA_GLES2_ProgramCacheEntry *program;
+
+    /* Select an appropriate shader pair for the specified modes */
+    vtype = VITA_GLES2_SHADER_VERTEX_DEFAULT;
+    switch (source) {
+    case VITA_GLES2_IMAGESOURCE_SOLID:
+        ftype = VITA_GLES2_SHADER_FRAGMENT_SOLID_SRC;
+        break;
+    case VITA_GLES2_IMAGESOURCE_TEXTURE_ABGR:
+        ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_ABGR_SRC;
+        break;
+    case VITA_GLES2_IMAGESOURCE_TEXTURE_ARGB:
+        ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_ARGB_SRC;
+        break;
+    case VITA_GLES2_IMAGESOURCE_TEXTURE_RGB:
+        ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_RGB_SRC;
+        break;
+    case VITA_GLES2_IMAGESOURCE_TEXTURE_BGR:
+        ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_BGR_SRC;
+        break;
+    case VITA_GLES2_IMAGESOURCE_TEXTURE_YUV:
+        switch (SDL_GetYUVConversionModeForResolution(w, h)) {
+        case SDL_YUV_CONVERSION_JPEG:
+            ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_YUV_JPEG_SRC;
+            break;
+        case SDL_YUV_CONVERSION_BT601:
+            ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_YUV_BT601_SRC;
+            break;
+        case SDL_YUV_CONVERSION_BT709:
+            ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_YUV_BT709_SRC;
+            break;
+        default:
+            SDL_SetError("Unsupported YUV conversion mode: %d\n", SDL_GetYUVConversionModeForResolution(w, h));
+            goto fault;
+        }
+        break;
+    case VITA_GLES2_IMAGESOURCE_TEXTURE_NV12:
+        switch (SDL_GetYUVConversionModeForResolution(w, h)) {
+        case SDL_YUV_CONVERSION_JPEG:
+            ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV12_JPEG_SRC;
+            break;
+        case SDL_YUV_CONVERSION_BT601:
+            ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV12_BT601_SRC;
+            break;
+        case SDL_YUV_CONVERSION_BT709:
+            ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV12_BT709_SRC;
+            break;
+        default:
+            SDL_SetError("Unsupported YUV conversion mode: %d\n", SDL_GetYUVConversionModeForResolution(w, h));
+            goto fault;
+        }
+        break;
+    case VITA_GLES2_IMAGESOURCE_TEXTURE_NV21:
+        switch (SDL_GetYUVConversionModeForResolution(w, h)) {
+        case SDL_YUV_CONVERSION_JPEG:
+            ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV21_JPEG_SRC;
+            break;
+        case SDL_YUV_CONVERSION_BT601:
+            ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV21_BT601_SRC;
+            break;
+        case SDL_YUV_CONVERSION_BT709:
+            ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV21_BT709_SRC;
+            break;
+        default:
+            SDL_SetError("Unsupported YUV conversion mode: %d\n", SDL_GetYUVConversionModeForResolution(w, h));
+            goto fault;
+        }
+        break;
+    case VITA_GLES2_IMAGESOURCE_TEXTURE_EXTERNAL_OES:
+        ftype = VITA_GLES2_SHADER_FRAGMENT_TEXTURE_EXTERNAL_OES_SRC;
+        break;
+    default:
+        goto fault;
+    }
+
+    /* Load the requested shaders */
+    vertex = VITA_GLES2_CacheShader(data, vtype);
+    if (!vertex) {
+        goto fault;
+    }
+    fragment = VITA_GLES2_CacheShader(data, ftype);
+    if (!fragment) {
+        goto fault;
+    }
+
+    /* Check if we need to change programs at all */
+    if (data->drawstate.program &&
+        data->drawstate.program->vertex_shader == vertex &&
+        data->drawstate.program->fragment_shader == fragment) {
+        return 0;
+    }
+
+    /* Generate a matching program */
+    program = VITA_GLES2_CacheProgram(data, vertex, fragment);
+    if (!program) {
+        goto fault;
+    }
+
+    /* Select that program in OpenGL */
+    data->glUseProgram(program->id);
+
+    /* Set the current program */
+    data->drawstate.program = program;
+
+    /* Clean up and return */
+    return 0;
+fault:
+    if (vertex && vertex->references <= 0) {
+        VITA_GLES2_EvictShader(data, vertex);
+    }
+    if (fragment && fragment->references <= 0) {
+        VITA_GLES2_EvictShader(data, fragment);
+    }
+    data->drawstate.program = NULL;
+    return -1;
+}
+
+static int
+VITA_GLES2_QueueSetViewport(SDL_Renderer * renderer, SDL_RenderCommand *cmd)
+{
+    return 0;  /* nothing to do in this backend. */
+}
+
+static int
+VITA_GLES2_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPoint * points, int count)
+{
+
+    GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * 2 * sizeof (GLfloat), 4, &cmd->data.draw.first);
+
+    int i;
+
+    if (!verts) {
+        return -1;
+    }
+
+    cmd->data.draw.count = count;
+    for (i = 0; i < count; i++) {
+        *(verts++) = 0.5f + points[i].x;
+        *(verts++) = 0.5f + points[i].y;
+    }
+
+    return 0;
+}
+
+static int
+VITA_GLES2_QueueFillRects(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FRect * rects, int count)
+{
+    GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * 8 * sizeof (GLfloat), 4, &cmd->data.draw.first);
+
+    int i;
+
+    if (!verts) {
+        return -1;
+    }
+
+    cmd->data.draw.count = count;
+
+    for (i = 0; i < count; i++) {
+        const SDL_FRect *rect = &rects[i];
+        const GLfloat minx = rect->x;
+        const GLfloat maxx = rect->x + rect->w;
+        const GLfloat miny = rect->y;
+        const GLfloat maxy = rect->y + rect->h;
+        *(verts++) = minx;
+        *(verts++) = miny;
+        *(verts++) = maxx;
+        *(verts++) = miny;
+        *(verts++) = minx;
+        *(verts++) = maxy;
+        *(verts++) = maxx;
+        *(verts++) = maxy;
+    }
+
+    return 0;
+}
+
+static int
+VITA_GLES2_QueueCopy(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * texture,
+                          const SDL_Rect * srcrect, const SDL_FRect * dstrect)
+{
+    GLfloat minx, miny, maxx, maxy;
+    GLfloat minu, maxu, minv, maxv;
+    GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, 16 * sizeof (GLfloat), 4, &cmd->data.draw.first);
+
+    if (!verts) {
+        return -1;
+    }
+
+    cmd->data.draw.count = 1;
+
+    minx = dstrect->x;
+    miny = dstrect->y;
+    maxx = dstrect->x + dstrect->w;
+    maxy = dstrect->y + dstrect->h;
+
+    minu = (GLfloat) srcrect->x / texture->w;
+    maxu = (GLfloat) (srcrect->x + srcrect->w) / texture->w;
+    minv = (GLfloat) srcrect->y / texture->h;
+    maxv = (GLfloat) (srcrect->y + srcrect->h) / texture->h;
+
+    *(verts++) = minx;
+    *(verts++) = miny;
+    *(verts++) = maxx;
+    *(verts++) = miny;
+    *(verts++) = minx;
+    *(verts++) = maxy;
+    *(verts++) = maxx;
+    *(verts++) = maxy;
+
+    *(verts++) = minu;
+    *(verts++) = minv;
+    *(verts++) = maxu;
+    *(verts++) = minv;
+    *(verts++) = minu;
+    *(verts++) = maxv;
+    *(verts++) = maxu;
+    *(verts++) = maxv;
+
+    return 0;
+}
+
+static int
+VITA_GLES2_QueueCopyEx(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * texture,
+                        const SDL_Rect * srcquad, const SDL_FRect * dstrect,
+                        const double angle, const SDL_FPoint *center, const SDL_RendererFlip flip)
+{
+    /* render expects cos value - 1 (see VITA_GLES2_VertexSrc_Default_) */
+    const float radian_angle = (float)(M_PI * (360.0 - angle) / 180.0);
+    const GLfloat s = (GLfloat) SDL_sin(radian_angle);
+    const GLfloat c = (GLfloat) SDL_cos(radian_angle) - 1.0f;
+    const GLfloat centerx = center->x + dstrect->x;
+    const GLfloat centery = center->y + dstrect->y;
+    GLfloat minx, miny, maxx, maxy;
+    GLfloat minu, maxu, minv, maxv;
+    GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, 32 * sizeof (GLfloat), 4, &cmd->data.draw.first);
+
+    if (!verts) {
+        return -1;
+    }
+
+    if (flip & SDL_FLIP_HORIZONTAL) {
+        minx = dstrect->x + dstrect->w;
+        maxx = dstrect->x;
+    } else {
+        minx = dstrect->x;
+        maxx = dstrect->x + dstrect->w;
+    }
+
+    if (flip & SDL_FLIP_VERTICAL) {
+        miny = dstrect->y + dstrect->h;
+        maxy = dstrect->y;
+    } else {
+        miny = dstrect->y;
+        maxy = dstrect->y + dstrect->h;
+    }
+
+    minu = ((GLfloat) srcquad->x) / ((GLfloat) texture->w);
+    maxu = ((GLfloat) (srcquad->x + srcquad->w)) / ((GLfloat) texture->w);
+    minv = ((GLfloat) srcquad->y) / ((GLfloat) texture->h);
+    maxv = ((GLfloat) (srcquad->y + srcquad->h)) / ((GLfloat) texture->h);
+
+
+    cmd->data.draw.count = 1;
+
+    *(verts++) = minx;
+    *(verts++) = miny;
+    *(verts++) = maxx;
+    *(verts++) = miny;
+    *(verts++) = minx;
+    *(verts++) = maxy;
+    *(verts++) = maxx;
+    *(verts++) = maxy;
+
+    *(verts++) = minu;
+    *(verts++) = minv;
+    *(verts++) = maxu;
+    *(verts++) = minv;
+    *(verts++) = minu;
+    *(verts++) = maxv;
+    *(verts++) = maxu;
+    *(verts++) = maxv;
+
+    *(verts++) = s;
+    *(verts++) = c;
+    *(verts++) = s;
+    *(verts++) = c;
+    *(verts++) = s;
+    *(verts++) = c;
+    *(verts++) = s;
+    *(verts++) = c;
+
+    *(verts++) = centerx;
+    *(verts++) = centery;
+    *(verts++) = centerx;
+    *(verts++) = centery;
+    *(verts++) = centerx;
+    *(verts++) = centery;
+    *(verts++) = centerx;
+    *(verts++) = centery;
+
+    return 0;
+}
+
+static int
+SetDrawState(VITA_GLES2_RenderData *data, const SDL_RenderCommand *cmd, const VITA_GLES2_ImageSource imgsrc)
+{
+    const SDL_bool was_copy_ex = data->drawstate.is_copy_ex;
+    const SDL_bool is_copy_ex = (cmd->command == SDL_RENDERCMD_COPY_EX);
+    SDL_Texture *texture = cmd->data.draw.texture;
+    const SDL_BlendMode blend = cmd->data.draw.blend;
+    VITA_GLES2_ProgramCacheEntry *program;
+
+    SDL_assert((texture != NULL) == (imgsrc != VITA_GLES2_IMAGESOURCE_SOLID));
+
+    if (data->drawstate.viewport_dirty) {
+        const SDL_Rect *viewport = &data->drawstate.viewport;
+        data->glViewport(viewport->x,
+                         data->drawstate.target ? viewport->y : (data->drawstate.drawableh - viewport->y - viewport->h),
+                         viewport->w, viewport->h);
+        if (viewport->w && viewport->h) {
+            data->drawstate.projection[0][0] = 2.0f / viewport->w;
+            data->drawstate.projection[1][1] = (data->drawstate.target ? 2.0f : -2.0f) / viewport->h;
+            data->drawstate.projection[3][1] = data->drawstate.target ? -1.0f : 1.0f;
+        }
+        data->drawstate.viewport_dirty = SDL_FALSE;
+    }
+
+    if (data->drawstate.cliprect_enabled_dirty) {
+        if (!data->drawstate.cliprect_enabled) {
+            data->glDisable(GL_SCISSOR_TEST);
+        } else {
+            data->glEnable(GL_SCISSOR_TEST);
+        }
+        data->drawstate.cliprect_enabled_dirty = SDL_FALSE;
+    }
+
+    if (data->drawstate.cliprect_enabled && data->drawstate.cliprect_dirty) {
+        const SDL_Rect *viewport = &data->drawstate.viewport;
+        const SDL_Rect *rect = &data->drawstate.cliprect;
+        data->glScissor(viewport->x + rect->x,
+                        data->drawstate.target ? viewport->y + rect->y : data->drawstate.drawableh - viewport->y - rect->y - rect->h,
+                        rect->w, rect->h);
+        data->drawstate.cliprect_dirty = SDL_FALSE;
+    }
+
+    if (texture != data->drawstate.texture) {
+        if ((texture != NULL) != data->drawstate.texturing) {
+            if (texture == NULL) {
+                data->glDisableVertexAttribArray((GLenum) VITA_GLES2_ATTRIBUTE_TEXCOORD);
+                data->drawstate.texturing = SDL_FALSE;
+            } else {
+                data->glEnableVertexAttribArray((GLenum) VITA_GLES2_ATTRIBUTE_TEXCOORD);
+                data->drawstate.texturing = SDL_TRUE;
+            }
+        }
+
+        if (texture) {
+            VITA_GLES2_TextureData *tdata = (VITA_GLES2_TextureData *) texture->driverdata;
+            if (tdata->yuv) {
+                data->glActiveTexture(GL_TEXTURE2);
+                data->glBindTexture(tdata->texture_type, tdata->texture_v);
+
+                data->glActiveTexture(GL_TEXTURE1);
+                data->glBindTexture(tdata->texture_type, tdata->texture_u);
+
+                data->glActiveTexture(GL_TEXTURE0);
+            } else if (tdata->nv12) {
+                data->glActiveTexture(GL_TEXTURE1);
+                data->glBindTexture(tdata->texture_type, tdata->texture_u);
+
+                data->glActiveTexture(GL_TEXTURE0);
+            }
+            data->glBindTexture(tdata->texture_type, tdata->texture);
+        }
+
+        data->drawstate.texture = texture;
+    }
+
+    if (texture) {
+        data->glVertexAttribPointer(VITA_GLES2_ATTRIBUTE_TEXCOORD, 2, GL_FLOAT, GL_FALSE, 0, (const GLvoid *) (cmd->data.draw.first + (sizeof (GLfloat) * 8)));
+    }
+
+    if (VITA_GLES2_SelectProgram(data, imgsrc, texture ? texture->w : 0, texture ? texture->h : 0) < 0) {
+        return -1;
+    }
+
+    program = data->drawstate.program;
+
+    if (program->uniform_locations[VITA_GLES2_UNIFORM_PROJECTION] != -1) {
+        if (SDL_memcmp(program->projection, data->drawstate.projection, sizeof (data->drawstate.projection)) != 0) {
+            data->glUniformMatrix4fv(program->uniform_locations[VITA_GLES2_UNIFORM_PROJECTION], 1, GL_FALSE, (GLfloat *)data->drawstate.projection);
+            SDL_memcpy(program->projection, data->drawstate.projection, sizeof (data->drawstate.projection));
+        }
+    }
+
+    if (program->uniform_locations[VITA_GLES2_UNIFORM_COLOR] != -1) {
+        if (data->drawstate.color != program->color) {
+            const Uint8 r = (data->drawstate.color >> 16) & 0xFF;
+            const Uint8 g = (data->drawstate.color >> 8) & 0xFF;
+            const Uint8 b = (data->drawstate.color >> 0) & 0xFF;
+            const Uint8 a = (data->drawstate.color >> 24) & 0xFF;
+            data->glUniform4f(program->uniform_locations[VITA_GLES2_UNIFORM_COLOR], r * inv255f, g * inv255f, b * inv255f, a * inv255f);
+            program->color = data->drawstate.color;
+        }
+    }
+
+    if (blend != data->drawstate.blend) {
+        if (blend == SDL_BLENDMODE_NONE) {
+            data->glDisable(GL_BLEND);
+        } else {
+            data->glEnable(GL_BLEND);
+            data->glBlendFuncSeparate(GetBlendFunc(SDL_GetBlendModeSrcColorFactor(blend)),
+                                      GetBlendFunc(SDL_GetBlendModeDstColorFactor(blend)),
+                                      GetBlendFunc(SDL_GetBlendModeSrcAlphaFactor(blend)),
+                                      GetBlendFunc(SDL_GetBlendModeDstAlphaFactor(blend)));
+            data->glBlendEquationSeparate(GetBlendEquation(SDL_GetBlendModeColorOperation(blend)),
+                                          GetBlendEquation(SDL_GetBlendModeAlphaOperation(blend)));
+        }
+        data->drawstate.blend = blend;
+    }
+
+    /* all drawing commands use this */
+    data->glVertexAttribPointer(VITA_GLES2_ATTRIBUTE_POSITION, 2, GL_FLOAT, GL_FALSE, 0, (const GLvoid *) cmd->data.draw.first);
+
+    if (is_copy_ex != was_copy_ex) {
+        if (is_copy_ex) {
+            data->glEnableVertexAttribArray((GLenum) VITA_GLES2_ATTRIBUTE_ANGLE);
+            data->glEnableVertexAttribArray((GLenum) VITA_GLES2_ATTRIBUTE_CENTER);
+        } else {
+            data->glDisableVertexAttribArray((GLenum) VITA_GLES2_ATTRIBUTE_ANGLE);
+            data->glDisableVertexAttribArray((GLenum) VITA_GLES2_ATTRIBUTE_CENTER);
+        }
+        data->drawstate.is_copy_ex = is_copy_ex;
+    }
+
+    if (is_copy_ex) {
+        data->glVertexAttribPointer(VITA_GLES2_ATTRIBUTE_ANGLE, 2, GL_FLOAT, GL_FALSE, 0, (const GLvoid *) (cmd->data.draw.first + (sizeof (GLfloat) * 16)));
+        data->glVertexAttribPointer(VITA_GLES2_ATTRIBUTE_CENTER, 2, GL_FLOAT, GL_FALSE, 0, (const GLvoid *) (cmd->data.draw.first + (sizeof (GLfloat) * 24)));
+    }
+
+    return 0;
+}
+
+static int
+SetCopyState(SDL_Renderer *renderer, const SDL_RenderCommand *cmd)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *) renderer->driverdata;
+    VITA_GLES2_ImageSource sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ABGR;
+    SDL_Texture *texture = cmd->data.draw.texture;
+
+    /* Pick an appropriate shader */
+    if (renderer->target) {
+        /* Check if we need to do color mapping between the source and render target textures */
+        if (renderer->target->format != texture->format) {
+            switch (texture->format) {
+            case SDL_PIXELFORMAT_ARGB8888:
+                switch (renderer->target->format) {
+                case SDL_PIXELFORMAT_ABGR8888:
+                case SDL_PIXELFORMAT_BGR888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ARGB;
+                    break;
+                case SDL_PIXELFORMAT_RGB888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ABGR;
+                    break;
+                }
+                break;
+            case SDL_PIXELFORMAT_ABGR8888:
+                switch (renderer->target->format) {
+                case SDL_PIXELFORMAT_ARGB8888:
+                case SDL_PIXELFORMAT_RGB888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ARGB;
+                    break;
+                case SDL_PIXELFORMAT_BGR888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ABGR;
+                    break;
+                }
+                break;
+            case SDL_PIXELFORMAT_RGB888:
+                switch (renderer->target->format) {
+                case SDL_PIXELFORMAT_ABGR8888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ARGB;
+                    break;
+                case SDL_PIXELFORMAT_ARGB8888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_BGR;
+                    break;
+                case SDL_PIXELFORMAT_BGR888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ARGB;
+                    break;
+                }
+                break;
+            case SDL_PIXELFORMAT_BGR888:
+                switch (renderer->target->format) {
+                case SDL_PIXELFORMAT_ABGR8888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_BGR;
+                    break;
+                case SDL_PIXELFORMAT_ARGB8888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_RGB;
+                    break;
+                case SDL_PIXELFORMAT_RGB888:
+                    sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ARGB;
+                    break;
+                }
+                break;
+            case SDL_PIXELFORMAT_IYUV:
+            case SDL_PIXELFORMAT_YV12:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_YUV;
+                break;
+            case SDL_PIXELFORMAT_NV12:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_NV12;
+                break;
+            case SDL_PIXELFORMAT_NV21:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_NV21;
+                break;
+            case SDL_PIXELFORMAT_EXTERNAL_OES:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_EXTERNAL_OES;
+                break;
+            default:
+                return SDL_SetError("Unsupported texture format");
+            }
+        } else {
+            sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ABGR;   /* Texture formats match, use the non color mapping shader (even if the formats are not ABGR) */
+        }
+    } else {
+        switch (texture->format) {
+            case SDL_PIXELFORMAT_ARGB8888:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ARGB;
+                break;
+            case SDL_PIXELFORMAT_ABGR8888:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_ABGR;
+                break;
+            case SDL_PIXELFORMAT_RGB888:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_RGB;
+                break;
+            case SDL_PIXELFORMAT_BGR888:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_BGR;
+                break;
+            case SDL_PIXELFORMAT_IYUV:
+            case SDL_PIXELFORMAT_YV12:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_YUV;
+                break;
+            case SDL_PIXELFORMAT_NV12:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_NV12;
+                break;
+            case SDL_PIXELFORMAT_NV21:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_NV21;
+                break;
+            case SDL_PIXELFORMAT_EXTERNAL_OES:
+                sourceType = VITA_GLES2_IMAGESOURCE_TEXTURE_EXTERNAL_OES;
+                break;
+            default:
+                return SDL_SetError("Unsupported texture format");
+        }
+    }
+
+    return SetDrawState(data, cmd, sourceType);
+}
+
+static int
+VITA_GLES2_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *) renderer->driverdata;
+    const SDL_bool colorswap = (renderer->target && (renderer->target->format == SDL_PIXELFORMAT_ARGB8888 || renderer->target->format == SDL_PIXELFORMAT_RGB888));
+    const int vboidx = data->current_vertex_buffer;
+    const GLuint vbo = data->vertex_buffers[vboidx];
+    size_t i;
+
+    if (VITA_GLES2_ActivateRenderer(renderer) < 0) {
+        return -1;
+    }
+
+    data->drawstate.target = renderer->target;
+    if (!data->drawstate.target) {
+        SDL_GL_GetDrawableSize(renderer->window, &data->drawstate.drawablew, &data->drawstate.drawableh);
+    }
+
+    /* upload the new VBO data for this set of commands. */
+    /* NULL/zero vertices could happen SetRenderTarget is the first render command */
+    if (vertsize > 0 && vertices != NULL)
+    {
+        data->glBindBuffer(GL_ARRAY_BUFFER, vbo);
+        if (data->vertex_buffer_size[vboidx] < vertsize) {
+            data->glBufferData(GL_ARRAY_BUFFER, vertsize, vertices, GL_DYNAMIC_DRAW);
+            data->vertex_buffer_size[vboidx] = vertsize;
+        } else {
+            data->glBufferSubData(GL_ARRAY_BUFFER, 0, vertsize, vertices);
+        }
+    }
+
+    /* cycle through a few VBOs so the GL has some time with the data before we replace it. */
+    data->current_vertex_buffer++;
+    if (data->current_vertex_buffer >= SDL_arraysize(data->vertex_buffers)) {
+        data->current_vertex_buffer = 0;
+    }
+
+    data->glDisable(GL_DEPTH_TEST);
+    data->glDisable(GL_CULL_FACE);
+
+    while (cmd) {
+        switch (cmd->command) {
+            case SDL_RENDERCMD_SETDRAWCOLOR: {
+                const Uint8 r = colorswap ? cmd->data.color.b : cmd->data.color.r;
+                const Uint8 g = cmd->data.color.g;
+                const Uint8 b = colorswap ? cmd->data.color.r : cmd->data.color.b;
+                const Uint8 a = cmd->data.color.a;
+                data->drawstate.color = ((a << 24) | (r << 16) | (g << 8) | b);
+                break;
+            }
+
+            case SDL_RENDERCMD_SETVIEWPORT: {
+                SDL_Rect *viewport = &data->drawstate.viewport;
+                if (SDL_memcmp(viewport, &cmd->data.viewport.rect, sizeof (SDL_Rect)) != 0) {
+                    SDL_memcpy(viewport, &cmd->data.viewport.rect, sizeof (SDL_Rect));
+                    data->drawstate.viewport_dirty = SDL_TRUE;
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_SETCLIPRECT: {
+                const SDL_Rect *rect = &cmd->data.cliprect.rect;
+                if (data->drawstate.cliprect_enabled != cmd->data.cliprect.enabled) {
+                    data->drawstate.cliprect_enabled = cmd->data.cliprect.enabled;
+                    data->drawstate.cliprect_enabled_dirty = SDL_TRUE;
+                }
+
+                if (SDL_memcmp(&data->drawstate.cliprect, rect, sizeof (SDL_Rect)) != 0) {
+                    SDL_memcpy(&data->drawstate.cliprect, rect, sizeof (SDL_Rect));
+                    data->drawstate.cliprect_dirty = SDL_TRUE;
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_CLEAR: {
+                const Uint8 r = colorswap ? cmd->data.color.b : cmd->data.color.r;
+                const Uint8 g = cmd->data.color.g;
+                const Uint8 b = colorswap ? cmd->data.color.r : cmd->data.color.b;
+                const Uint8 a = cmd->data.color.a;
+                const Uint32 color = ((a << 24) | (r << 16) | (g << 8) | b);
+                if (color != data->drawstate.clear_color) {
+                    const GLfloat fr = ((GLfloat) r) * inv255f;
+                    const GLfloat fg = ((GLfloat) g) * inv255f;
+                    const GLfloat fb = ((GLfloat) b) * inv255f;
+                    const GLfloat fa = ((GLfloat) a) * inv255f;
+                    data->glClearColor(fr, fg, fb, fa);
+                    data->drawstate.clear_color = color;
+                }
+
+                if (data->drawstate.cliprect_enabled || data->drawstate.cliprect_enabled_dirty) {
+                    data->glDisable(GL_SCISSOR_TEST);
+                    data->drawstate.cliprect_enabled_dirty = data->drawstate.cliprect_enabled;
+                }
+
+                data->glClear(GL_COLOR_BUFFER_BIT);
+                break;
+            }
+
+            case SDL_RENDERCMD_DRAW_POINTS: {
+                if (SetDrawState(data, cmd, VITA_GLES2_IMAGESOURCE_SOLID) == 0) {
+                    data->glDrawArrays(GL_POINTS, 0, (GLsizei) cmd->data.draw.count);
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_DRAW_LINES: {
+                const GLfloat *verts = (GLfloat *) (((Uint8 *) vertices) + cmd->data.draw.first);
+                const size_t count = cmd->data.draw.count;
+                if (SetDrawState(data, cmd, VITA_GLES2_IMAGESOURCE_SOLID) == 0) {
+                    if (count > 2 && (verts[0] == verts[(count-1)*2]) && (verts[1] == verts[(count*2)-1])) {
+                        /* GL_LINE_LOOP takes care of the final segment */
+                        data->glDrawArrays(GL_LINE_LOOP, 0, (GLsizei) (count - 1));
+                    } else {
+                        data->glDrawArrays(GL_LINE_STRIP, 0, (GLsizei) count);
+                        /* We need to close the endpoint of the line */
+                        data->glDrawArrays(GL_POINTS, (GLsizei) (count - 1), 1);
+                    }
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_FILL_RECTS: {
+                const size_t count = cmd->data.draw.count;
+                size_t offset = 0;
+                if (SetDrawState(data, cmd, VITA_GLES2_IMAGESOURCE_SOLID) == 0) {
+                    for (i = 0; i < count; ++i, offset += 4) {
+                        data->glDrawArrays(GL_TRIANGLE_STRIP, (GLsizei) offset, 4);
+                    }
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_COPY:
+            case SDL_RENDERCMD_COPY_EX: {
+                if (SetCopyState(renderer, cmd) == 0) {
+                    data->glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_NO_OP:
+                break;
+        }
+
+        cmd = cmd->next;
+    }
+
+    return GL_CheckError("", renderer);
+}
+
+static void
+VITA_GLES2_DestroyRenderer(SDL_Renderer *renderer)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *)renderer->driverdata;
+
+    /* Deallocate everything */
+    if (data) {
+        VITA_GLES2_ActivateRenderer(renderer);
+
+        {
+            VITA_GLES2_ShaderCacheEntry *entry;
+            VITA_GLES2_ShaderCacheEntry *next;
+            entry = data->shader_cache.head;
+            while (entry) {
+                data->glDeleteShader(entry->id);
+                next = entry->next;
+                SDL_free(entry);
+                entry = next;
+            }
+        }
+        {
+            VITA_GLES2_ProgramCacheEntry *entry;
+            VITA_GLES2_ProgramCacheEntry *next;
+            entry = data->program_cache.head;
+            while (entry) {
+                data->glDeleteProgram(entry->id);
+                next = entry->next;
+                SDL_free(entry);
+                entry = next;
+            }
+        }
+
+        if (data->context) {
+            while (data->framebuffers) {
+                VITA_GLES2_FBOList *nextnode = data->framebuffers->next;
+                data->glDeleteFramebuffers(1, &data->framebuffers->FBO);
+                GL_CheckError("", renderer);
+                SDL_free(data->framebuffers);
+                data->framebuffers = nextnode;
+            }
+
+            data->glDeleteBuffers(SDL_arraysize(data->vertex_buffers), data->vertex_buffers);
+            GL_CheckError("", renderer);
+
+            SDL_GL_DeleteContext(data->context);
+        }
+
+        SDL_free(data->shader_formats);
+        SDL_free(data);
+    }
+    SDL_free(renderer);
+}
+
+static int
+VITA_GLES2_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    VITA_GLES2_RenderData *renderdata = (VITA_GLES2_RenderData *)renderer->driverdata;
+    VITA_GLES2_TextureData *data;
+    GLenum format;
+    GLenum type;
+    GLenum scaleMode;
+
+    VITA_GLES2_ActivateRenderer(renderer);
+
+    renderdata->drawstate.texture = NULL;  /* we trash this state. */
+
+    /* Determine the corresponding GLES texture format params */
+    switch (texture->format)
+    {
+    case SDL_PIXELFORMAT_ARGB8888:
+    case SDL_PIXELFORMAT_ABGR8888:
+    case SDL_PIXELFORMAT_RGB888:
+    case SDL_PIXELFORMAT_BGR888:
+        format = GL_RGBA;
+        type = GL_UNSIGNED_BYTE;
+        break;
+    case SDL_PIXELFORMAT_IYUV:
+    case SDL_PIXELFORMAT_YV12:
+    case SDL_PIXELFORMAT_NV12:
+    case SDL_PIXELFORMAT_NV21:
+        format = GL_LUMINANCE;
+        type = GL_UNSIGNED_BYTE;
+        break;
+    default:
+        return SDL_SetError("Texture format not supported");
+    }
+
+    if (texture->format == SDL_PIXELFORMAT_EXTERNAL_OES &&
+        texture->access != SDL_TEXTUREACCESS_STATIC) {
+        return SDL_SetError("Unsupported texture access for SDL_PIXELFORMAT_EXTERNAL_OES");
+    }
+
+    /* Allocate a texture struct */
+    data = (VITA_GLES2_TextureData *)SDL_calloc(1, sizeof(VITA_GLES2_TextureData));
+    if (!data) {
+        return SDL_OutOfMemory();
+    }
+    data->texture = 0;
+    data->texture_type = GL_TEXTURE_2D;
+    data->pixel_format = format;
+    data->pixel_type = type;
+    data->yuv = ((texture->format == SDL_PIXELFORMAT_IYUV) || (texture->format == SDL_PIXELFORMAT_YV12));
+    data->nv12 = ((texture->format == SDL_PIXELFORMAT_NV12) || (texture->format == SDL_PIXELFORMAT_NV21));
+    data->texture_u = 0;
+    data->texture_v = 0;
+    scaleMode = (texture->scaleMode == SDL_ScaleModeNearest) ? GL_NEAREST : GL_LINEAR;
+
+    /* Allocate a blob for image renderdata */
+    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {
+        size_t size;
+        data->pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);
+        size = texture->h * data->pitch;
+        if (data->yuv) {
+            /* Need to add size for the U and V planes */
+            size += 2 * ((texture->h + 1) / 2) * ((data->pitch + 1) / 2);
+        } else if (data->nv12) {
+            /* Need to add size for the U/V plane */
+            size += 2 * ((texture->h + 1) / 2) * ((data->pitch + 1) / 2);
+        }
+        data->pixel_data = SDL_calloc(1, size);
+        if (!data->pixel_data) {
+            SDL_free(data);
+            return SDL_OutOfMemory();
+        }
+    }
+
+    /* Allocate the texture */
+    GL_CheckError("", renderer);
+
+    if (data->yuv) {
+        renderdata->glGenTextures(1, &data->texture_v);
+        if (GL_CheckError("glGenTexures()", renderer) < 0) {
+            return -1;
+        }
+        renderdata->glActiveTexture(GL_TEXTURE2);
+        renderdata->glBindTexture(data->texture_type, data->texture_v);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, scaleMode);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, scaleMode);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        renderdata->glTexImage2D(data->texture_type, 0, format, (texture->w + 1) / 2, (texture->h + 1) / 2, 0, format, type, NULL);
+
+        renderdata->glGenTextures(1, &data->texture_u);
+        if (GL_CheckError("glGenTexures()", renderer) < 0) {
+            return -1;
+        }
+        renderdata->glActiveTexture(GL_TEXTURE1);
+        renderdata->glBindTexture(data->texture_type, data->texture_u);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, scaleMode);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, scaleMode);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        renderdata->glTexImage2D(data->texture_type, 0, format, (texture->w + 1) / 2, (texture->h + 1) / 2, 0, format, type, NULL);
+        if (GL_CheckError("glTexImage2D()", renderer) < 0) {
+            return -1;
+        }
+    } else if (data->nv12) {
+        renderdata->glGenTextures(1, &data->texture_u);
+        if (GL_CheckError("glGenTexures()", renderer) < 0) {
+            return -1;
+        }
+        renderdata->glActiveTexture(GL_TEXTURE1);
+        renderdata->glBindTexture(data->texture_type, data->texture_u);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, scaleMode);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, scaleMode);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        renderdata->glTexImage2D(data->texture_type, 0, GL_LUMINANCE_ALPHA, (texture->w + 1) / 2, (texture->h + 1) / 2, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, NULL);
+        if (GL_CheckError("glTexImage2D()", renderer) < 0) {
+            return -1;
+        }
+    }
+
+    renderdata->glGenTextures(1, &data->texture);
+    if (GL_CheckError("glGenTexures()", renderer) < 0) {
+        return -1;
+    }
+    texture->driverdata = data;
+    renderdata->glActiveTexture(GL_TEXTURE0);
+    renderdata->glBindTexture(data->texture_type, data->texture);
+    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, scaleMode);
+    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, scaleMode);
+    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    if (texture->format != SDL_PIXELFORMAT_EXTERNAL_OES) {
+        renderdata->glTexImage2D(data->texture_type, 0, format, texture->w, texture->h, 0, format, type, NULL);
+        if (GL_CheckError("glTexImage2D()", renderer) < 0) {
+            return -1;
+        }
+    }
+
+    if (texture->access == SDL_TEXTUREACCESS_TARGET) {
+       data->fbo = VITA_GLES2_GetFBO(renderer->driverdata, texture->w, texture->h);
+    } else {
+       data->fbo = NULL;
+    }
+
+    return GL_CheckError("", renderer);
+}
+
+static int
+VITA_GLES2_TexSubImage2D(VITA_GLES2_RenderData *data, GLenum target, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels, GLint pitch, GLint bpp)
+{
+    Uint8 *blob = NULL;
+    Uint8 *src;
+    int src_pitch;
+    int y;
+
+    if ((width == 0) || (height == 0) || (bpp == 0)) {
+        return 0;  /* nothing to do */
+    }
+
+    /* Reformat the texture data into a tightly packed array */
+    src_pitch = width * bpp;
+    src = (Uint8 *)pixels;
+    if (pitch != src_pitch) {
+        blob = (Uint8 *)SDL_malloc(src_pitch * height);
+        if (!blob) {
+            return SDL_OutOfMemory();
+        }
+        src = blob;
+        for (y = 0; y < height; ++y)
+        {
+            SDL_memcpy(src, pixels, src_pitch);
+            src += src_pitch;
+            pixels = (Uint8 *)pixels + pitch;
+        }
+        src = blob;
+    }
+
+    data->glTexSubImage2D(target, 0, xoffset, yoffset, width, height, format, type, src);
+    if (blob) {
+        SDL_free(blob);
+    }
+    return 0;
+}
+
+static int
+VITA_GLES2_UpdateTexture(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *rect,
+                    const void *pixels, int pitch)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *)renderer->driverdata;
+    VITA_GLES2_TextureData *tdata = (VITA_GLES2_TextureData *)texture->driverdata;
+
+    VITA_GLES2_ActivateRenderer(renderer);
+
+    /* Bail out if we're supposed to update an empty rectangle */
+    if (rect->w <= 0 || rect->h <= 0) {
+        return 0;
+    }
+
+    data->drawstate.texture = NULL;  /* we trash this state. */
+
+    /* Create a texture subimage with the supplied data */
+    data->glBindTexture(tdata->texture_type, tdata->texture);
+    VITA_GLES2_TexSubImage2D(data, tdata->texture_type,
+                    rect->x,
+                    rect->y,
+                    rect->w,
+                    rect->h,
+                    tdata->pixel_format,
+                    tdata->pixel_type,
+                    pixels, pitch, SDL_BYTESPERPIXEL(texture->format));
+
+    if (tdata->yuv) {
+        /* Skip to the correct offset into the next texture */
+        pixels = (const void*)((const Uint8*)pixels + rect->h * pitch);
+        if (texture->format == SDL_PIXELFORMAT_YV12) {
+            data->glBindTexture(tdata->texture_type, tdata->texture_v);
+        } else {
+            data->glBindTexture(tdata->texture_type, tdata->texture_u);
+        }
+        VITA_GLES2_TexSubImage2D(data, tdata->texture_type,
+                rect->x / 2,
+                rect->y / 2,
+                (rect->w + 1) / 2,
+                (rect->h + 1) / 2,
+                tdata->pixel_format,
+                tdata->pixel_type,
+                pixels, (pitch + 1) / 2, 1);
+
+
+        /* Skip to the correct offset into the next texture */
+        pixels = (const void*)((const Uint8*)pixels + ((rect->h + 1) / 2) * ((pitch + 1)/2));
+        if (texture->format == SDL_PIXELFORMAT_YV12) {
+            data->glBindTexture(tdata->texture_type, tdata->texture_u);
+        } else {
+            data->glBindTexture(tdata->texture_type, tdata->texture_v);
+        }
+        VITA_GLES2_TexSubImage2D(data, tdata->texture_type,
+                rect->x / 2,
+                rect->y / 2,
+                (rect->w + 1) / 2,
+                (rect->h + 1) / 2,
+                tdata->pixel_format,
+                tdata->pixel_type,
+                pixels, (pitch + 1) / 2, 1);
+    } else if (tdata->nv12) {
+        /* Skip to the correct offset into the next texture */
+        pixels = (const void*)((const Uint8*)pixels + rect->h * pitch);
+        data->glBindTexture(tdata->texture_type, tdata->texture_u);
+        VITA_GLES2_TexSubImage2D(data, tdata->texture_type,
+                rect->x / 2,
+                rect->y / 2,
+                (rect->w + 1) / 2,
+                (rect->h + 1) / 2,
+                GL_LUMINANCE_ALPHA,
+                GL_UNSIGNED_BYTE,
+                pixels, 2 * ((pitch + 1) / 2), 2);
+    }
+
+    return GL_CheckError("glTexSubImage2D()", renderer);
+}
+
+static int
+VITA_GLES2_UpdateTextureYUV(SDL_Renderer * renderer, SDL_Texture * texture,
+                    const SDL_Rect * rect,
+                    const Uint8 *Yplane, int Ypitch,
+                    const Uint8 *Uplane, int Upitch,
+                    const Uint8 *Vplane, int Vpitch)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *)renderer->driverdata;
+    VITA_GLES2_TextureData *tdata = (VITA_GLES2_TextureData *)texture->driverdata;
+
+    VITA_GLES2_ActivateRenderer(renderer);
+
+    /* Bail out if we're supposed to update an empty rectangle */
+    if (rect->w <= 0 || rect->h <= 0) {
+        return 0;
+    }
+
+    data->drawstate.texture = NULL;  /* we trash this state. */
+
+    data->glBindTexture(tdata->texture_type, tdata->texture_v);
+    VITA_GLES2_TexSubImage2D(data, tdata->texture_type,
+                    rect->x / 2,
+                    rect->y / 2,
+                    (rect->w + 1) / 2,
+                    (rect->h + 1) / 2,
+                    tdata->pixel_format,
+                    tdata->pixel_type,
+                    Vplane, Vpitch, 1);
+
+    data->glBindTexture(tdata->texture_type, tdata->texture_u);
+    VITA_GLES2_TexSubImage2D(data, tdata->texture_type,
+                    rect->x / 2,
+                    rect->y / 2,
+                    (rect->w + 1) / 2,
+                    (rect->h + 1) / 2,
+                    tdata->pixel_format,
+                    tdata->pixel_type,
+                    Uplane, Upitch, 1);
+
+    data->glBindTexture(tdata->texture_type, tdata->texture);
+    VITA_GLES2_TexSubImage2D(data, tdata->texture_type,
+                    rect->x,
+                    rect->y,
+                    rect->w,
+                    rect->h,
+                    tdata->pixel_format,
+                    tdata->pixel_type,
+                    Yplane, Ypitch, 1);
+
+    return GL_CheckError("glTexSubImage2D()", renderer);
+}
+
+static int
+VITA_GLES2_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *rect,
+                  void **pixels, int *pitch)
+{
+    VITA_GLES2_TextureData *tdata = (VITA_GLES2_TextureData *)texture->driverdata;
+
+    /* Retrieve the buffer/pitch for the specified region */
+    *pixels = (Uint8 *)tdata->pixel_data +
+              (tdata->pitch * rect->y) +
+              (rect->x * SDL_BYTESPERPIXEL(texture->format));
+    *pitch = tdata->pitch;
+
+    return 0;
+}
+
+static void
+VITA_GLES2_UnlockTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    VITA_GLES2_TextureData *tdata = (VITA_GLES2_TextureData *)texture->driverdata;
+    SDL_Rect rect;
+
+    /* We do whole texture updates, at least for now */
+    rect.x = 0;
+    rect.y = 0;
+    rect.w = texture->w;
+    rect.h = texture->h;
+    VITA_GLES2_UpdateTexture(renderer, texture, &rect, tdata->pixel_data, tdata->pitch);
+}
+
+static void
+VITA_GLES2_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_ScaleMode scaleMode)
+{
+    VITA_GLES2_RenderData *renderdata = (VITA_GLES2_RenderData *) renderer->driverdata;
+    VITA_GLES2_TextureData *data = (VITA_GLES2_TextureData *) texture->driverdata;
+    GLenum glScaleMode = (scaleMode == SDL_ScaleModeNearest) ? GL_NEAREST : GL_LINEAR;
+
+    if (data->yuv) {
+        renderdata->glActiveTexture(GL_TEXTURE2);
+        renderdata->glBindTexture(data->texture_type, data->texture_v);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, glScaleMode);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, glScaleMode);
+
+        renderdata->glActiveTexture(GL_TEXTURE1);
+        renderdata->glBindTexture(data->texture_type, data->texture_u);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, glScaleMode);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, glScaleMode);
+    } else if (data->nv12) {
+        renderdata->glActiveTexture(GL_TEXTURE1);
+        renderdata->glBindTexture(data->texture_type, data->texture_u);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, glScaleMode);
+        renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, glScaleMode);
+    }
+
+    renderdata->glActiveTexture(GL_TEXTURE0);
+    renderdata->glBindTexture(data->texture_type, data->texture);
+    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MIN_FILTER, glScaleMode);
+    renderdata->glTexParameteri(data->texture_type, GL_TEXTURE_MAG_FILTER, glScaleMode);
+}
+
+static int
+VITA_GLES2_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *) renderer->driverdata;
+    VITA_GLES2_TextureData *texturedata = NULL;
+    GLenum status;
+
+    data->drawstate.viewport_dirty = SDL_TRUE;
+
+    if (texture == NULL) {
+        data->glBindFramebuffer(GL_FRAMEBUFFER, data->window_framebuffer);
+    } else {
+        texturedata = (VITA_GLES2_TextureData *) texture->driverdata;
+        data->glBindFramebuffer(GL_FRAMEBUFFER, texturedata->fbo->FBO);
+        /* TODO: check if texture pixel format allows this operation */
+        data->glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texturedata->texture_type, texturedata->texture, 0);
+        /* Check FBO status */
+        status = data->glCheckFramebufferStatus(GL_FRAMEBUFFER);
+        if (status != GL_FRAMEBUFFER_COMPLETE) {
+            return SDL_SetError("glFramebufferTexture2D() failed");
+        }
+    }
+    return 0;
+}
+
+static void
+VITA_GLES2_DestroyTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *)renderer->driverdata;
+    VITA_GLES2_TextureData *tdata = (VITA_GLES2_TextureData *)texture->driverdata;
+
+    VITA_GLES2_ActivateRenderer(renderer);
+
+    if (data->drawstate.texture == texture) {
+        data->drawstate.texture = NULL;
+    }
+    if (data->drawstate.target == texture) {
+        data->drawstate.target = NULL;
+    }
+
+    /* Destroy the texture */
+    if (tdata) {
+        data->glDeleteTextures(1, &tdata->texture);
+        if (tdata->texture_v) {
+            data->glDeleteTextures(1, &tdata->texture_v);
+        }
+        if (tdata->texture_u) {
+            data->glDeleteTextures(1, &tdata->texture_u);
+        }
+        SDL_free(tdata->pixel_data);
+        SDL_free(tdata);
+        texture->driverdata = NULL;
+    }
+}
+
+static int
+VITA_GLES2_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
+                    Uint32 pixel_format, void * pixels, int pitch)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *)renderer->driverdata;
+    Uint32 temp_format = renderer->target ? renderer->target->format : SDL_PIXELFORMAT_ABGR8888;
+    size_t buflen;
+    void *temp_pixels;
+    int temp_pitch;
+    Uint8 *src, *dst, *tmp;
+    int w, h, length, rows;
+    int status;
+
+    temp_pitch = rect->w * SDL_BYTESPERPIXEL(temp_format);
+    buflen = rect->h * temp_pitch;
+    if (buflen == 0) {
+        return 0;  /* nothing to do. */
+    }
+
+    temp_pixels = SDL_malloc(buflen);
+    if (!temp_pixels) {
+        return SDL_OutOfMemory();
+    }
+
+    SDL_GetRendererOutputSize(renderer, &w, &h);
+
+    data->glReadPixels(rect->x, renderer->target ? rect->y : (h-rect->y)-rect->h,
+                       rect->w, rect->h, GL_RGBA, GL_UNSIGNED_BYTE, temp_pixels);
+    if (GL_CheckError("glReadPixels()", renderer) < 0) {
+        return -1;
+    }
+
+    /* Flip the rows to be top-down if necessary */
+    if (!renderer->target) {
+        SDL_bool isstack;
+        length = rect->w * SDL_BYTESPERPIXEL(temp_format);
+        src = (Uint8*)temp_pixels + (rect->h-1)*temp_pitch;
+        dst = (Uint8*)temp_pixels;
+        tmp = SDL_small_alloc(Uint8, length, &isstack);
+        rows = rect->h / 2;
+        while (rows--) {
+            SDL_memcpy(tmp, dst, length);
+            SDL_memcpy(dst, src, length);
+            SDL_memcpy(src, tmp, length);
+            dst += temp_pitch;
+            src -= temp_pitch;
+        }
+        SDL_small_free(tmp, isstack);
+    }
+
+    status = SDL_ConvertPixels(rect->w, rect->h,
+                               temp_format, temp_pixels, temp_pitch,
+                               pixel_format, pixels, pitch);
+    SDL_free(temp_pixels);
+
+    return status;
+}
+
+static void
+VITA_GLES2_RenderPresent(SDL_Renderer *renderer)
+{
+    /* Tell the video driver to swap buffers */
+    SDL_GL_SwapWindow(renderer->window);
+}
+
+
+/*************************************************************************************************
+ * Bind/unbinding of textures
+ *************************************************************************************************/
+static int VITA_GLES2_BindTexture (SDL_Renderer * renderer, SDL_Texture *texture, float *texw, float *texh);
+static int VITA_GLES2_UnbindTexture (SDL_Renderer * renderer, SDL_Texture *texture);
+
+static int VITA_GLES2_BindTexture (SDL_Renderer * renderer, SDL_Texture *texture, float *texw, float *texh)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *)renderer->driverdata;
+    VITA_GLES2_TextureData *texturedata = (VITA_GLES2_TextureData *)texture->driverdata;
+    VITA_GLES2_ActivateRenderer(renderer);
+
+    data->glBindTexture(texturedata->texture_type, texturedata->texture);
+    data->drawstate.texture = texture;
+
+    if (texw) {
+        *texw = 1.0;
+    }
+    if (texh) {
+        *texh = 1.0;
+    }
+
+    return 0;
+}
+
+static int VITA_GLES2_UnbindTexture (SDL_Renderer * renderer, SDL_Texture *texture)
+{
+    VITA_GLES2_RenderData *data = (VITA_GLES2_RenderData *)renderer->driverdata;
+    VITA_GLES2_TextureData *texturedata = (VITA_GLES2_TextureData *)texture->driverdata;
+    VITA_GLES2_ActivateRenderer(renderer);
+
+    data->glBindTexture(texturedata->texture_type, 0);
+    data->drawstate.texture = NULL;
+
+    return 0;
+}
+
+
+/*************************************************************************************************
+ * Renderer instantiation                                                                        *
+ *************************************************************************************************/
+
+static SDL_Renderer *
+VITA_GLES2_CreateRenderer(SDL_Window *window, Uint32 flags)
+{
+    SDL_Renderer *renderer;
+    VITA_GLES2_RenderData *data;
+    GLint nFormats;
+    GLboolean hasCompiler;
+    GLint window_framebuffer;
+    GLint value;
+    Uint32 window_flags = 0;
+
+    window_flags = SDL_GetWindowFlags(window);
+
+    if (!(window_flags & SDL_WINDOW_OPENGL)) {
+        if (SDL_RecreateWindow(window, window_flags | SDL_WINDOW_OPENGL) < 0) {
+            goto error;
+        }
+    }
+
+    /* Create the renderer struct */
+    renderer = (SDL_Renderer *)SDL_calloc(1, sizeof(SDL_Renderer));
+    if (!renderer) {
+        SDL_OutOfMemory();
+        goto error;
+    }
+
+    data = (VITA_GLES2_RenderData *)SDL_calloc(1, sizeof(VITA_GLES2_RenderData));
+    if (!data) {
+        SDL_free(renderer);
+        SDL_OutOfMemory();
+        goto error;
+    }
+
+    renderer->info = VITA_GLES2_RenderDriver.info;
+    renderer->info.flags = (SDL_RENDERER_ACCELERATED | SDL_RENDERER_TARGETTEXTURE);
+    renderer->driverdata = data;
+    renderer->window = window;
+
+    /* Create an OpenGL ES 2.0 context */
+    data->context = SDL_GL_CreateContext(window);
+    if (!data->context) {
+        SDL_free(renderer);
+        SDL_free(data);
+        goto error;
+    }
+    if (SDL_GL_MakeCurrent(window, data->context) < 0) {
+        SDL_GL_DeleteContext(data->context);
+        SDL_free(renderer);
+        SDL_free(data);
+        goto error;
+    }
+
+    if (VITA_GLES2_LoadFunctions(data) < 0) {
+        SDL_GL_DeleteContext(data->context);
+        SDL_free(renderer);
+        SDL_free(data);
+        goto error;
+    }
+
+    if (flags & SDL_RENDERER_PRESENTVSYNC) {
+        SDL_GL_SetSwapInterval(1);
+    } else {
+        SDL_GL_SetSwapInterval(0);
+    }
+
+    if (SDL_GL_GetSwapInterval() > 0) {
+        renderer->info.flags |= SDL_RENDERER_PRESENTVSYNC;
+    }
+
+    /* Check for debug output support */
+    if (SDL_GL_GetAttribute(SDL_GL_CONTEXT_FLAGS, &value) == 0 &&
+        (value & SDL_GL_CONTEXT_DEBUG_FLAG)) {
+        data->debug_enabled = SDL_TRUE;
+    }
+
+    value = 0;
+    data->glGetIntegerv(GL_MAX_TEXTURE_SIZE, &value);
+    renderer->info.max_texture_width = value;
+    value = 0;
+    data->glGetIntegerv(GL_MAX_TEXTURE_SIZE, &value);
+    renderer->info.max_texture_height = value;
+
+    data->glGetIntegerv(GL_NUM_SHADER_BINARY_FORMATS, &nFormats);
+    hasCompiler = GL_TRUE;
+    if (hasCompiler) {
+        ++nFormats;
+    }
+
+    data->shader_formats = (GLenum *)SDL_calloc(nFormats, sizeof(GLenum));
+    if (!data->shader_formats) {
+        VITA_GLES2_DestroyRenderer(renderer);
+        SDL_OutOfMemory();
+        goto error;
+    }
+    data->shader_format_count = nFormats;
+    data->glGetIntegerv(GL_SHADER_BINARY_FORMATS, (GLint *)data->shader_formats);
+    if (hasCompiler) {
+        data->shader_formats[nFormats - 1] = (GLenum)-1;
+    }
+
+    /* we keep a few of these and cycle through them, so data can live for a few frames. */
+    data->glGenBuffers(SDL_arraysize(data->vertex_buffers), data->vertex_buffers);
+
+    data->framebuffers = NULL;
+    data->glGetIntegerv(GL_FRAMEBUFFER_BINDING, &window_framebuffer);
+    data->window_framebuffer = (GLuint)window_framebuffer;
+
+    /* Populate the function pointers for the module */
+    renderer->WindowEvent         = VITA_GLES2_WindowEvent;
+    renderer->GetOutputSize       = VITA_GLES2_GetOutputSize;
+    renderer->SupportsBlendMode   = VITA_GLES2_SupportsBlendMode;
+    renderer->CreateTexture       = VITA_GLES2_CreateTexture;
+    renderer->UpdateTexture       = VITA_GLES2_UpdateTexture;
+    renderer->UpdateTextureYUV    = VITA_GLES2_UpdateTextureYUV;
+    renderer->LockTexture         = VITA_GLES2_LockTexture;
+    renderer->UnlockTexture       = VITA_GLES2_UnlockTexture;
+    renderer->SetTextureScaleMode = VITA_GLES2_SetTextureScaleMode;
+    renderer->SetRenderTarget     = VITA_GLES2_SetRenderTarget;
+
+    renderer->QueueSetViewport    = VITA_GLES2_QueueSetViewport;
+    renderer->QueueSetDrawColor   = VITA_GLES2_QueueSetViewport;  /* SetViewport and SetDrawColor are (currently) no-ops. */
+    renderer->QueueDrawPoints     = VITA_GLES2_QueueDrawPoints;
+    renderer->QueueDrawLines      = VITA_GLES2_QueueDrawPoints;  /* lines and points queue vertices the same way. */
+    renderer->QueueFillRects      = VITA_GLES2_QueueFillRects;
+    renderer->QueueCopy           = VITA_GLES2_QueueCopy;
+    renderer->QueueCopyEx         = VITA_GLES2_QueueCopyEx;
+    renderer->RunCommandQueue     = VITA_GLES2_RunCommandQueue;
+    renderer->RenderReadPixels    = VITA_GLES2_RenderReadPixels;
+    renderer->RenderPresent       = VITA_GLES2_RenderPresent;
+    renderer->DestroyTexture      = VITA_GLES2_DestroyTexture;
+    renderer->DestroyRenderer     = VITA_GLES2_DestroyRenderer;
+    renderer->GL_BindTexture      = VITA_GLES2_BindTexture;
+    renderer->GL_UnbindTexture    = VITA_GLES2_UnbindTexture;
+
+// TODO. See shaders
+//    renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_YV12;
+//    renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_IYUV;
+//    renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_NV12;
+//    renderer->info.texture_formats[renderer->info.num_texture_formats++] = SDL_PIXELFORMAT_NV21;
+
+    /* Set up parameters for rendering */
+    data->glActiveTexture(GL_TEXTURE0);
+    data->glPixelStorei(GL_PACK_ALIGNMENT, 1);
+    data->glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+
+    data->glEnableVertexAttribArray(VITA_GLES2_ATTRIBUTE_POSITION);
+    data->glDisableVertexAttribArray(VITA_GLES2_ATTRIBUTE_TEXCOORD);
+
+    data->glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
+
+    data->drawstate.blend = SDL_BLENDMODE_INVALID;
+    data->drawstate.color = 0xFFFFFFFF;
+    data->drawstate.clear_color = 0xFFFFFFFF;
+    data->drawstate.projection[3][0] = -1.0f;
+    data->drawstate.projection[3][3] = 1.0f;
+
+    GL_CheckError("", renderer);
+
+    return renderer;
+
+error:
+    return NULL;
+}
+
+SDL_RenderDriver VITA_GLES2_RenderDriver = {
+    VITA_GLES2_CreateRenderer,
+    {
+        "VITA gles2",
+        (SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE),
+        4,
+        {
+        SDL_PIXELFORMAT_ARGB8888,
+        SDL_PIXELFORMAT_ABGR8888,
+        SDL_PIXELFORMAT_RGB888,
+        SDL_PIXELFORMAT_BGR888
+        },
+        0,
+        0
+    }
+};
+
+#endif /* SDL_VIDEO_RENDER_VITA_GLES2 && !SDL_RENDER_DISABLED */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagles2/SDL_shaders_gles2vita.c b/src/render/vitagles2/SDL_shaders_gles2vita.c
new file mode 100644
index 000000000..87ad13d50
--- /dev/null
+++ b/src/render/vitagles2/SDL_shaders_gles2vita.c
@@ -0,0 +1,563 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_VITA_GLES2 && !SDL_RENDER_DISABLED
+
+#include "SDL_video.h"
+#include "SDL_opengles2.h"
+#include "SDL_shaders_gles2vita.h"
+#include "SDL_stdinc.h"
+
+/* While Vita is gles2-compliant, shaders should be in Cg format, not glsl */
+
+/*************************************************************************************************
+ * Vertex/fragment shader source                                                                 *
+ *************************************************************************************************/
+/* Notes on a_angle:
+   * It is a vector containing sin and cos for rotation matrix
+   * To get correct rotation for most cases when a_angle is disabled cos
+     value is decremented by 1.0 to get proper output with 0.0 which is
+     default value
+*/
+static const Uint8 VITA_GLES2_VertexSrc_Default_[] = " \
+    struct _Output { \
+      float2 v_texCoord : TEXCOORD0; \
+      float4 position : POSITION; \
+      float pointsize    : PSIZE; \
+    }; \
+\
+    _Output main( \
+        uniform float4x4 u_projection, \
+        float2 a_position, \
+        float2 a_texCoord, \
+        float2 a_angle, \
+        float2 a_center \
+    ) \
+    { \
+        _Output OUT; \
+\
+        float s = a_angle[0]; \
+        float c = a_angle[1] + 1.0; \
+        float2x2 rotationMatrix = float2x2(c, s, -s, c); \
+        float2 position = mul((a_position - a_center) + a_center, rotationMatrix); \
+\
+        OUT.v_texCoord = a_texCoord; \
+        OUT.position =  mul(float4(position, 0.0, 1.0), u_projection);\
+        OUT.pointsize = 1.0; \
+        return OUT; \
+    } \
+";
+
+static const Uint8 VITA_GLES2_FragmentSrc_SolidSrc_[] = " \
+    float4 main(uniform float4 u_color : COLOR) : COLOR \
+    { \
+        return u_color; \
+    } \
+";
+
+static const Uint8 VITA_GLES2_FragmentSrc_TextureABGRSrc_[] = " \
+    float4 main(uniform sampler2D u_texture, uniform float4 u_color : COLOR, float2 v_texCoord : TEXCOORD0 ) : COLOR \
+    { \
+        float4 color = tex2D(u_texture, v_texCoord); \
+        return color * u_color; \
+    } \
+";
+
+/* ARGB to ABGR conversion */
+static const Uint8 VITA_GLES2_FragmentSrc_TextureARGBSrc_[] = " \
+    float4 main(uniform sampler2D u_texture, uniform float4 u_color : COLOR, float2 v_texCoord : TEXCOORD0 ) : COLOR \
+    { \
+        float4 abgr = tex2D(u_texture, v_texCoord); \
+        float4 color = abgr; \
+        color.r = abgr.b; \
+        color.b = abgr.r; \
+        return color * u_color; \
+    } \
+";
+
+/* RGB to ABGR conversion */
+static const Uint8 VITA_GLES2_FragmentSrc_TextureRGBSrc_[] = " \
+    float4 main(uniform sampler2D u_texture, uniform float4 u_color : COLOR, float2 v_texCoord : TEXCOORD0 ) : COLOR \
+    { \
+        float4 abgr = tex2D(u_texture, v_texCoord); \
+        float4 color = abgr; \
+        color.r = abgr.b; \
+        color.b = abgr.r; \
+        color.a = 1.0; \
+        return color * u_color; \
+    } \
+";
+
+/* BGR to ABGR conversion */
+static const Uint8 VITA_GLES2_FragmentSrc_TextureBGRSrc_[] = " \
+    float4 main(uniform sampler2D u_texture, uniform float4 u_color : COLOR, float2 v_texCoord : TEXCOORD0 ) : COLOR \
+    { \
+        float4 abgr = tex2D(u_texture, v_texCoord); \
+        float4 color = abgr; \
+        color.a = 1.0; \
+        return color * u_color; \
+    } \
+";
+
+// VITA : TODO
+
+#define JPEG_SHADER_CONSTANTS                                   \
+"// YUV offset \n"                                              \
+"const vec3 offset = vec3(0, -0.501960814, -0.501960814);\n"    \
+"\n"                                                            \
+"// RGB coefficients \n"                                        \
+"const mat3 matrix = mat3( 1,       1,        1,\n"             \
+"                          0,      -0.3441,   1.772,\n"         \
+"                          1.402,  -0.7141,   0);\n"            \
+
+#define BT601_SHADER_CONSTANTS                                  \
+"// YUV offset \n"                                              \
+"const vec3 offset = vec3(-0.0627451017, -0.501960814, -0.501960814);\n" \
+"\n"                                                            \
+"// RGB coefficients \n"                                        \
+"const mat3 matrix = mat3( 1.1644,  1.1644,   1.1644,\n"        \
+"                          0,      -0.3918,   2.0172,\n"        \
+"                          1.596,  -0.813,    0);\n"            \
+
+#define BT709_SHADER_CONSTANTS                                  \
+"// YUV offset \n"                                              \
+"const vec3 offset = vec3(-0.0627451017, -0.501960814, -0.501960814);\n" \
+"\n"                                                            \
+"// RGB coefficients \n"                                        \
+"const mat3 matrix = mat3( 1.1644,  1.1644,   1.1644,\n"        \
+"                          0,      -0.2132,   2.1124,\n"        \
+"                          1.7927, -0.5329,   0);\n"            \
+
+
+#define YUV_SHADER_PROLOGUE                                     \
+"precision mediump float;\n"                                    \
+"uniform sampler2D u_texture;\n"                                \
+"uniform sampler2D u_texture_u;\n"                              \
+"uniform sampler2D u_texture_v;\n"                              \
+"uniform vec4 u_color;\n"                                  \
+"varying vec2 v_texCoord;\n"                                    \
+"\n"                                                            \
+
+#define YUV_SHADER_BODY                                         \
+"\n"                                                            \
+"void main()\n"                                                 \
+"{\n"                                                           \
+"    mediump vec3 yuv;\n"                                       \
+"    lowp vec3 rgb;\n"                                          \
+"\n"                                                            \
+"    // Get the YUV values \n"                                  \
+"    yuv.x = texture2D(u_texture,   v_texCoord).r;\n"           \
+"    yuv.y = texture2D(u_texture_u, v_texCoord).r;\n"           \
+"    yuv.z = texture2D(u_texture_v, v_texCoord).r;\n"           \
+"\n"                                                            \
+"    // Do the color transform \n"                              \
+"    yuv += offset;\n"                                          \
+"    rgb = matrix * yuv;\n"                                     \
+"\n"                                                            \
+"    // That was easy. :) \n"                                   \
+"    gl_FragColor = vec4(rgb, 1);\n"                            \
+"    gl_FragColor *= u_color;\n"                           \
+"}"                                                             \
+
+#define NV12_SHADER_BODY                                        \
+"\n"                                                            \
+"void main()\n"                                                 \
+"{\n"                                                           \
+"    mediump vec3 yuv;\n"                                       \
+"    lowp vec3 rgb;\n"                                          \
+"\n"                                                            \
+"    // Get the YUV values \n"                                  \
+"    yuv.x = texture2D(u_texture,   v_texCoord).r;\n"           \
+"    yuv.yz = texture2D(u_texture_u, v_texCoord).ra;\n"         \
+"\n"                                                            \
+"    // Do the color transform \n"                              \
+"    yuv += offset;\n"                                          \
+"    rgb = matrix * yuv;\n"                                     \
+"\n"                                                            \
+"    // That was easy. :) \n"                                   \
+"    gl_FragColor = vec4(rgb, 1);\n"                            \
+"    gl_FragColor *= u_color;\n"                           \
+"}"                                                             \
+
+#define NV21_SHADER_BODY                                        \
+"\n"                                                            \
+"void main()\n"                                                 \
+"{\n"                                                           \
+"    mediump vec3 yuv;\n"                                       \
+"    lowp vec3 rgb;\n"                                          \
+"\n"                                                            \
+"    // Get the YUV values \n"                                  \
+"    yuv.x = texture2D(u_texture,   v_texCoord).r;\n"           \
+"    yuv.yz = texture2D(u_texture_u, v_texCoord).ar;\n"         \
+"\n"                                                            \
+"    // Do the color transform \n"                              \
+"    yuv += offset;\n"                                          \
+"    rgb = matrix * yuv;\n"                                     \
+"\n"                                                            \
+"    // That was easy. :) \n"                                   \
+"    gl_FragColor = vec4(rgb, 1);\n"                            \
+"    gl_FragColor *= u_color;\n"                           \
+"}"                                                             \
+
+/* YUV to ABGR conversion */
+static const Uint8 VITA_GLES2_FragmentSrc_TextureYUVJPEGSrc_[] = \
+        YUV_SHADER_PROLOGUE \
+        JPEG_SHADER_CONSTANTS \
+        YUV_SHADER_BODY \
+;
+static const Uint8 VITA_GLES2_FragmentSrc_TextureYUVBT601Src_[] = \
+        YUV_SHADER_PROLOGUE \
+        BT601_SHADER_CONSTANTS \
+        YUV_SHADER_BODY \
+;
+static const Uint8 VITA_GLES2_FragmentSrc_TextureYUVBT709Src_[] = \
+        YUV_SHADER_PROLOGUE \
+        BT709_SHADER_CONSTANTS \
+        YUV_SHADER_BODY \
+;
+
+/* NV12 to ABGR conversion */
+static const Uint8 VITA_GLES2_FragmentSrc_TextureNV12JPEGSrc_[] = \
+        YUV_SHADER_PROLOGUE \
+        JPEG_SHADER_CONSTANTS \
+        NV12_SHADER_BODY \
+;
+static const Uint8 VITA_GLES2_FragmentSrc_TextureNV12BT601Src_[] = \
+        YUV_SHADER_PROLOGUE \
+        BT601_SHADER_CONSTANTS \
+        NV12_SHADER_BODY \
+;
+static const Uint8 VITA_GLES2_FragmentSrc_TextureNV12BT709Src_[] = \
+        YUV_SHADER_PROLOGUE \
+        BT709_SHADER_CONSTANTS \
+        NV12_SHADER_BODY \
+;
+
+/* NV21 to ABGR conversion */
+static const Uint8 VITA_GLES2_FragmentSrc_TextureNV21JPEGSrc_[] = \
+        YUV_SHADER_PROLOGUE \
+        JPEG_SHADER_CONSTANTS \
+        NV21_SHADER_BODY \
+;
+static const Uint8 VITA_GLES2_FragmentSrc_TextureNV21BT601Src_[] = \
+        YUV_SHADER_PROLOGUE \
+        BT601_SHADER_CONSTANTS \
+        NV21_SHADER_BODY \
+;
+static const Uint8 VITA_GLES2_FragmentSrc_TextureNV21BT709Src_[] = \
+        YUV_SHADER_PROLOGUE \
+        BT709_SHADER_CONSTANTS \
+        NV21_SHADER_BODY \
+;
+
+/* Custom Android video format texture */
+static const Uint8 VITA_GLES2_FragmentSrc_TextureExternalOESSrc_[] = " \
+    #extension GL_OES_EGL_image_external : require\n\
+    precision mediump float; \
+    uniform samplerExternalOES u_texture; \
+    uniform vec4 u_color; \
+    varying vec2 v_texCoord; \
+    \
+    void main() \
+    { \
+        gl_FragColor = texture2D(u_texture, v_texCoord); \
+        gl_FragColor *= u_color; \
+    } \
+";
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_VertexSrc_Default = {
+    GL_VERTEX_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_VertexSrc_Default_),
+    VITA_GLES2_VertexSrc_Default_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_SolidSrc = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_SolidSrc_),
+    VITA_GLES2_FragmentSrc_SolidSrc_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureABGRSrc = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureABGRSrc_),
+    VITA_GLES2_FragmentSrc_TextureABGRSrc_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureARGBSrc = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureARGBSrc_),
+    VITA_GLES2_FragmentSrc_TextureARGBSrc_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureRGBSrc = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureRGBSrc_),
+    VITA_GLES2_FragmentSrc_TextureRGBSrc_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureBGRSrc = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureBGRSrc_),
+    VITA_GLES2_FragmentSrc_TextureBGRSrc_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureYUVJPEGSrc = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureYUVJPEGSrc_),
+    VITA_GLES2_FragmentSrc_TextureYUVJPEGSrc_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureYUVBT601Src = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureYUVBT601Src_),
+    VITA_GLES2_FragmentSrc_TextureYUVBT601Src_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureYUVBT709Src = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureYUVBT709Src_),
+    VITA_GLES2_FragmentSrc_TextureYUVBT709Src_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureNV12JPEGSrc = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureNV12JPEGSrc_),
+    VITA_GLES2_FragmentSrc_TextureNV12JPEGSrc_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureNV12BT601Src = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureNV12BT601Src_),
+    VITA_GLES2_FragmentSrc_TextureNV12BT601Src_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureNV21BT709Src = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureNV21BT709Src_),
+    VITA_GLES2_FragmentSrc_TextureNV21BT709Src_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureNV21JPEGSrc = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureNV21JPEGSrc_),
+    VITA_GLES2_FragmentSrc_TextureNV21JPEGSrc_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureNV21BT601Src = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureNV21BT601Src_),
+    VITA_GLES2_FragmentSrc_TextureNV21BT601Src_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureNV12BT709Src = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureNV12BT709Src_),
+    VITA_GLES2_FragmentSrc_TextureNV12BT709Src_
+};
+
+static const VITA_GLES2_ShaderInstance VITA_GLES2_FragmentSrc_TextureExternalOESSrc = {
+    GL_FRAGMENT_SHADER,
+    VITA_GLES2_SOURCE_SHADER,
+    sizeof(VITA_GLES2_FragmentSrc_TextureExternalOESSrc_),
+    VITA_GLES2_FragmentSrc_TextureExternalOESSrc_
+};
+
+
+/*************************************************************************************************
+ * Vertex/fragment shader definitions                                                            *
+ *************************************************************************************************/
+
+static VITA_GLES2_Shader VITA_GLES2_VertexShader_Default = {
+    1,
+    {
+        &VITA_GLES2_VertexSrc_Default
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_SolidSrc = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_SolidSrc
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureABGRSrc = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureABGRSrc
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureARGBSrc = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureARGBSrc
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureRGBSrc = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureRGBSrc
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureBGRSrc = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureBGRSrc
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureYUVJPEGSrc = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureYUVJPEGSrc
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureYUVBT601Src = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureYUVBT601Src
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureYUVBT709Src = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureYUVBT709Src
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureNV12JPEGSrc = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureNV12JPEGSrc
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureNV12BT601Src = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureNV12BT601Src
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureNV12BT709Src = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureNV12BT709Src
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureNV21JPEGSrc = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureNV21JPEGSrc
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureNV21BT601Src = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureNV21BT601Src
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureNV21BT709Src = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureNV21BT709Src
+    }
+};
+
+static VITA_GLES2_Shader VITA_GLES2_FragmentShader_TextureExternalOESSrc = {
+    1,
+    {
+        &VITA_GLES2_FragmentSrc_TextureExternalOESSrc
+    }
+};
+
+
+/*************************************************************************************************
+ * Shader selector                                                                               *
+ *************************************************************************************************/
+
+const VITA_GLES2_Shader *VITA_GLES2_GetShader(VITA_GLES2_ShaderType type)
+{
+    switch (type) {
+    case VITA_GLES2_SHADER_VERTEX_DEFAULT:
+        return &VITA_GLES2_VertexShader_Default;
+    case VITA_GLES2_SHADER_FRAGMENT_SOLID_SRC:
+        return &VITA_GLES2_FragmentShader_SolidSrc;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_ABGR_SRC:
+        return &VITA_GLES2_FragmentShader_TextureABGRSrc;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_ARGB_SRC:
+        return &VITA_GLES2_FragmentShader_TextureARGBSrc;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_RGB_SRC:
+        return &VITA_GLES2_FragmentShader_TextureRGBSrc;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_BGR_SRC:
+        return &VITA_GLES2_FragmentShader_TextureBGRSrc;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_YUV_JPEG_SRC:
+        return &VITA_GLES2_FragmentShader_TextureYUVJPEGSrc;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_YUV_BT601_SRC:
+        return &VITA_GLES2_FragmentShader_TextureYUVBT601Src;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_YUV_BT709_SRC:
+        return &VITA_GLES2_FragmentShader_TextureYUVBT709Src;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV12_JPEG_SRC:
+        return &VITA_GLES2_FragmentShader_TextureNV12JPEGSrc;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV12_BT601_SRC:
+        return &VITA_GLES2_FragmentShader_TextureNV12BT601Src;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV12_BT709_SRC:
+        return &VITA_GLES2_FragmentShader_TextureNV12BT709Src;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV21_JPEG_SRC:
+        return &VITA_GLES2_FragmentShader_TextureNV21JPEGSrc;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV21_BT601_SRC:
+        return &VITA_GLES2_FragmentShader_TextureNV21BT601Src;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV21_BT709_SRC:
+        return &VITA_GLES2_FragmentShader_TextureNV21BT709Src;
+    case VITA_GLES2_SHADER_FRAGMENT_TEXTURE_EXTERNAL_OES_SRC:
+        return &VITA_GLES2_FragmentShader_TextureExternalOESSrc;
+    default:
+        return NULL;
+    }
+}
+
+#endif /* SDL_VIDEO_RENDER_VITA_GLES2 && !SDL_RENDER_DISABLED */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagles2/SDL_shaders_gles2vita.h b/src/render/vitagles2/SDL_shaders_gles2vita.h
new file mode 100644
index 000000000..dd7091591
--- /dev/null
+++ b/src/render/vitagles2/SDL_shaders_gles2vita.h
@@ -0,0 +1,70 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_shaders_gles2vita_h_
+#define SDL_shaders_gles2vita_h_
+
+#if SDL_VIDEO_RENDER_VITA_GLES2
+
+typedef struct VITA_GLES2_ShaderInstance
+{
+    GLenum type;
+    GLenum format;
+    int length;
+    const void *data;
+} VITA_GLES2_ShaderInstance;
+
+typedef struct VITA_GLES2_Shader
+{
+    int instance_count;
+    const VITA_GLES2_ShaderInstance *instances[4];
+} VITA_GLES2_Shader;
+
+typedef enum
+{
+    VITA_GLES2_SHADER_VERTEX_DEFAULT,
+    VITA_GLES2_SHADER_FRAGMENT_SOLID_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_ABGR_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_ARGB_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_BGR_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_RGB_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_YUV_JPEG_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_YUV_BT601_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_YUV_BT709_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV12_JPEG_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV12_BT601_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV12_BT709_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV21_JPEG_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV21_BT601_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_NV21_BT709_SRC,
+    VITA_GLES2_SHADER_FRAGMENT_TEXTURE_EXTERNAL_OES_SRC
+} VITA_GLES2_ShaderType;
+
+#define VITA_GLES2_SOURCE_SHADER (GLenum)-1
+
+const VITA_GLES2_Shader *VITA_GLES2_GetShader(VITA_GLES2_ShaderType type);
+
+#endif /* SDL_VIDEO_RENDER_VITA_GLES2 */
+
+#endif /* SDL_shaders_gles2vita_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagxm/SDL_render_vita_gxm.c b/src/render/vitagxm/SDL_render_vita_gxm.c
new file mode 100644
index 000000000..4ffe51d36
--- /dev/null
+++ b/src/render/vitagxm/SDL_render_vita_gxm.c
@@ -0,0 +1,1145 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_VITA_GXM
+
+#include "SDL_hints.h"
+#include "../SDL_sysrender.h"
+#include "SDL_log.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdarg.h>
+#include <stdlib.h>
+
+#include "SDL_render_vita_gxm_types.h"
+#include "SDL_render_vita_gxm_tools.h"
+#include "SDL_render_vita_gxm_memory.h"
+
+#include <psp2/common_dialog.h>
+
+static SDL_Renderer *VITA_GXM_CreateRenderer(SDL_Window *window, Uint32 flags);
+
+static void VITA_GXM_WindowEvent(SDL_Renderer *renderer, const SDL_WindowEvent *event);
+
+static SDL_bool VITA_GXM_SupportsBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode);
+
+static int VITA_GXM_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture);
+
+static int VITA_GXM_UpdateTexture(SDL_Renderer *renderer, SDL_Texture *texture,
+    const SDL_Rect *rect, const void *pixels, int pitch);
+
+static int VITA_GXM_UpdateTextureYUV(SDL_Renderer * renderer, SDL_Texture * texture,
+    const SDL_Rect * rect,
+    const Uint8 *Yplane, int Ypitch,
+    const Uint8 *Uplane, int Upitch,
+    const Uint8 *Vplane, int Vpitch);
+
+static int VITA_GXM_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture,
+    const SDL_Rect *rect, void **pixels, int *pitch);
+
+static void VITA_GXM_UnlockTexture(SDL_Renderer *renderer,
+    SDL_Texture *texture);
+
+static void VITA_GXM_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_ScaleMode scaleMode);
+
+static int VITA_GXM_SetRenderTarget(SDL_Renderer *renderer,
+    SDL_Texture *texture);
+
+
+static int VITA_GXM_QueueSetViewport(SDL_Renderer * renderer, SDL_RenderCommand *cmd);
+
+static int VITA_GXM_QueueSetDrawColor(SDL_Renderer * renderer, SDL_RenderCommand *cmd);
+
+
+static int VITA_GXM_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPoint * points, int count);
+static int VITA_GXM_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPoint * points, int count);
+
+static int VITA_GXM_QueueCopy(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * texture,
+    const SDL_Rect * srcrect, const SDL_FRect * dstrect);
+
+static int VITA_GXM_QueueCopyEx(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * texture,
+    const SDL_Rect * srcrect, const SDL_FRect * dstrect,
+    const double angle, const SDL_FPoint *center, const SDL_RendererFlip flip);
+
+static int VITA_GXM_RenderClear(SDL_Renderer *renderer, SDL_RenderCommand *cmd);
+
+static int VITA_GXM_RenderDrawPoints(SDL_Renderer *renderer, const SDL_RenderCommand *cmd);
+
+static int VITA_GXM_RenderDrawLines(SDL_Renderer *renderer, const SDL_RenderCommand *cmd);
+
+static int VITA_GXM_QueueFillRects(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FRect * rects, int count);
+
+static int VITA_GXM_RenderFillRects(SDL_Renderer *renderer, const SDL_RenderCommand *cmd);
+
+
+static int VITA_GXM_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize);
+
+static int VITA_GXM_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect,
+    Uint32 pixel_format, void *pixels, int pitch);
+
+
+static void VITA_GXM_RenderPresent(SDL_Renderer *renderer);
+static void VITA_GXM_DestroyTexture(SDL_Renderer *renderer, SDL_Texture *texture);
+static void VITA_GXM_DestroyRenderer(SDL_Renderer *renderer);
+
+
+SDL_RenderDriver VITA_GXM_RenderDriver = {
+    .CreateRenderer = VITA_GXM_CreateRenderer,
+    .info = {
+        .name = "VITA gxm",
+        .flags = SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE,
+        .num_texture_formats = 1,
+        .texture_formats = {
+            [0] = SDL_PIXELFORMAT_ABGR8888, // TODO: support more formats? ARGB8888 should be enough?
+        },
+        .max_texture_width = 1024,
+        .max_texture_height = 1024,
+     }
+};
+
+void
+StartDrawing(SDL_Renderer *renderer)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+    if(data->drawing)
+    {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "uh-oh, already drawing\n");
+        return;
+    }
+
+    data->drawstate.texture = NULL;
+    data->drawstate.vertex_program = NULL;
+    data->drawstate.fragment_program = NULL;
+    data->drawstate.last_command = -1;
+    data->drawstate.texture_color = 0xFFFFFFFF;
+
+    // reset blend mode
+//    data->currentBlendMode = SDL_BLENDMODE_BLEND;
+//    fragment_programs *in = &data->blendFragmentPrograms.blend_mode_blend;
+//    data->colorFragmentProgram = in->color;
+//    data->textureFragmentProgram = in->texture;
+//    data->textureTintFragmentProgram = in->textureTint;
+
+    if (renderer->target == NULL) {
+        sceGxmBeginScene(
+            data->gxm_context,
+            0,
+            data->renderTarget,
+            NULL,
+            NULL,
+            data->displayBufferSync[data->backBufferIndex],
+            &data->displaySurface[data->backBufferIndex],
+            &data->depthSurface
+        );
+    } else {
+        VITA_GXM_TextureData *vita_texture = (VITA_GXM_TextureData *) renderer->target->driverdata;
+
+        sceGxmBeginScene(
+            data->gxm_context,
+            0,
+            vita_texture->tex->gxm_rendertarget,
+            NULL,
+            NULL,
+            NULL,
+            &vita_texture->tex->gxm_colorsurface,
+            &vita_texture->tex->gxm_depthstencil
+        );
+    }
+
+//    unset_clip_rectangle(data);
+
+    data->drawing = SDL_TRUE;
+}
+
+SDL_Renderer *
+VITA_GXM_CreateRenderer(SDL_Window *window, Uint32 flags)
+{
+    SDL_Renderer *renderer;
+    VITA_GXM_RenderData *data;
+
+    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
+    if (!renderer) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    data = (VITA_GXM_RenderData *) SDL_calloc(1, sizeof(VITA_GXM_RenderData));
+    if (!data) {
+        VITA_GXM_DestroyRenderer(renderer);
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    renderer->WindowEvent = VITA_GXM_WindowEvent;
+    renderer->SupportsBlendMode = VITA_GXM_SupportsBlendMode;
+    renderer->CreateTexture = VITA_GXM_CreateTexture;
+    renderer->UpdateTexture = VITA_GXM_UpdateTexture;
+    renderer->UpdateTextureYUV = VITA_GXM_UpdateTextureYUV;
+    renderer->LockTexture = VITA_GXM_LockTexture;
+    renderer->UnlockTexture = VITA_GXM_UnlockTexture;
+    renderer->SetTextureScaleMode = VITA_GXM_SetTextureScaleMode;
+    renderer->SetRenderTarget = VITA_GXM_SetRenderTarget;
+    renderer->QueueSetViewport = VITA_GXM_QueueSetViewport;
+    renderer->QueueSetDrawColor = VITA_GXM_QueueSetDrawColor;
+    renderer->QueueDrawPoints = VITA_GXM_QueueDrawPoints;
+    renderer->QueueDrawLines = VITA_GXM_QueueDrawLines;
+    renderer->QueueFillRects = VITA_GXM_QueueFillRects;
+    renderer->QueueCopy = VITA_GXM_QueueCopy;
+    renderer->QueueCopyEx = VITA_GXM_QueueCopyEx;
+    renderer->RunCommandQueue = VITA_GXM_RunCommandQueue;
+    renderer->RenderReadPixels = VITA_GXM_RenderReadPixels;
+    renderer->RenderPresent = VITA_GXM_RenderPresent;
+    renderer->DestroyTexture = VITA_GXM_DestroyTexture;
+    renderer->DestroyRenderer = VITA_GXM_DestroyRenderer;
+
+    renderer->info = VITA_GXM_RenderDriver.info;
+    renderer->info.flags = (SDL_RENDERER_ACCELERATED | SDL_RENDERER_TARGETTEXTURE);
+    renderer->driverdata = data;
+    renderer->window = window;
+
+    if (data->initialized != SDL_FALSE)
+        return 0;
+    data->initialized = SDL_TRUE;
+
+    if (flags & SDL_RENDERER_PRESENTVSYNC) {
+        data->displayData.wait_vblank = SDL_TRUE;
+    } else {
+        data->displayData.wait_vblank = SDL_FALSE;
+    }
+
+    if (gxm_init(renderer) != 0)
+    {
+        return NULL;
+    }
+
+    return renderer;
+}
+
+static void
+VITA_GXM_WindowEvent(SDL_Renderer *renderer, const SDL_WindowEvent *event)
+{
+}
+
+static SDL_bool
+VITA_GXM_SupportsBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode)
+{
+    // only for custom modes. we build all modes on init, so no custom modes, sorry
+    return SDL_FALSE;
+}
+
+static int
+VITA_GXM_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+    VITA_GXM_TextureData* vita_texture = (VITA_GXM_TextureData*) SDL_calloc(1, sizeof(VITA_GXM_TextureData));
+
+    if (!vita_texture) {
+        return SDL_OutOfMemory();
+    }
+
+    vita_texture->tex = create_gxm_texture(data, texture->w, texture->h, SCE_GXM_TEXTURE_FORMAT_A8B8G8R8, (texture->access == SDL_TEXTUREACCESS_TARGET));
+
+    if (!vita_texture->tex) {
+        SDL_free(vita_texture);
+        return SDL_OutOfMemory();
+    }
+
+    texture->driverdata = vita_texture;
+
+    VITA_GXM_SetTextureScaleMode(renderer, texture, texture->scaleMode);
+
+    vita_texture->w = gxm_texture_get_width(vita_texture->tex);
+    vita_texture->h = gxm_texture_get_height(vita_texture->tex);
+    vita_texture->pitch = gxm_texture_get_stride(vita_texture->tex);
+
+    return 0;
+}
+
+
+static int
+VITA_GXM_UpdateTexture(SDL_Renderer *renderer, SDL_Texture *texture,
+    const SDL_Rect *rect, const void *pixels, int pitch)
+{
+    const Uint8 *src;
+    Uint8 *dst;
+    int row, length,dpitch;
+    src = pixels;
+
+    VITA_GXM_LockTexture(renderer, texture, rect, (void **)&dst, &dpitch);
+    length = rect->w * SDL_BYTESPERPIXEL(texture->format);
+    if (length == pitch && length == dpitch) {
+        SDL_memcpy(dst, src, length*rect->h);
+    } else {
+        for (row = 0; row < rect->h; ++row) {
+            SDL_memcpy(dst, src, length);
+            src += pitch;
+            dst += dpitch;
+        }
+    }
+
+    return 0;
+}
+
+static int
+VITA_GXM_UpdateTextureYUV(SDL_Renderer * renderer, SDL_Texture * texture,
+    const SDL_Rect * rect,
+    const Uint8 *Yplane, int Ypitch,
+    const Uint8 *Uplane, int Upitch,
+    const Uint8 *Vplane, int Vpitch)
+{
+    return 0;
+}
+
+static int
+VITA_GXM_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture,
+    const SDL_Rect *rect, void **pixels, int *pitch)
+{
+    VITA_GXM_TextureData *vita_texture = (VITA_GXM_TextureData *) texture->driverdata;
+
+    *pixels =
+        (void *) ((Uint8 *) gxm_texture_get_datap(vita_texture->tex)
+            + (rect->y * vita_texture->pitch) + rect->x * SDL_BYTESPERPIXEL(texture->format));
+    *pitch = vita_texture->pitch;
+    return 0;
+}
+
+static void
+VITA_GXM_UnlockTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    // No need to update texture data on ps vita.
+    // VITA_GXM_LockTexture already returns a pointer to the texture pixels buffer.
+    // This really improves framerate when using lock/unlock.
+}
+
+static void
+VITA_GXM_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_ScaleMode scaleMode)
+{
+    VITA_GXM_TextureData *vita_texture = (VITA_GXM_TextureData *) texture->driverdata;
+
+    /*
+     set texture filtering according to scaleMode
+     suported hint values are nearest (0, default) or linear (1)
+     vitaScaleMode is either SCE_GXM_TEXTURE_FILTER_POINT (good for tile-map)
+     or SCE_GXM_TEXTURE_FILTER_LINEAR (good for scaling)
+     */
+
+    int vitaScaleMode = (scaleMode == SDL_ScaleModeNearest
+                        ? SCE_GXM_TEXTURE_FILTER_POINT
+                        : SCE_GXM_TEXTURE_FILTER_LINEAR);
+    gxm_texture_set_filters(vita_texture->tex, vitaScaleMode, vitaScaleMode);
+
+    return;
+}
+
+static int
+VITA_GXM_SetRenderTarget(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    return 0; // nothing to do here
+}
+
+static void
+VITA_GXM_SetBlendMode(VITA_GXM_RenderData *data, int blendMode)
+{
+    if (blendMode != data->currentBlendMode)
+    {
+        fragment_programs *in = &data->blendFragmentPrograms.blend_mode_blend;
+
+        switch (blendMode)
+        {
+            case SDL_BLENDMODE_NONE:
+                in = &data->blendFragmentPrograms.blend_mode_none;
+                break;
+            case SDL_BLENDMODE_BLEND:
+                in = &data->blendFragmentPrograms.blend_mode_blend;
+                break;
+            case SDL_BLENDMODE_ADD:
+                in = &data->blendFragmentPrograms.blend_mode_add;
+                break;
+            case SDL_BLENDMODE_MOD:
+                in = &data->blendFragmentPrograms.blend_mode_mod;
+                break;
+            case SDL_BLENDMODE_MUL:
+                in = &data->blendFragmentPrograms.blend_mode_mul;
+                break;
+        }
+        data->colorFragmentProgram = in->color;
+        data->textureFragmentProgram = in->texture;
+        data->textureTintFragmentProgram = in->textureTint;
+        data->currentBlendMode = blendMode;
+    }
+}
+
+static int
+VITA_GXM_QueueSetViewport(SDL_Renderer * renderer, SDL_RenderCommand *cmd)
+{
+    return 0; // TODO
+}
+
+static int
+VITA_GXM_QueueSetDrawColor(SDL_Renderer * renderer, SDL_RenderCommand *cmd)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    const Uint8 r = cmd->data.color.r;
+    const Uint8 g = cmd->data.color.g;
+    const Uint8 b = cmd->data.color.b;
+    const Uint8 a = cmd->data.color.a;
+    data->drawstate.color = ((a << 24) | (b << 16) | (g << 8) | r);
+
+    return 0;
+}
+
+static int
+VITA_GXM_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPoint * points, int count)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    int color = data->drawstate.color;
+
+    color_vertex *vertex = (color_vertex *)pool_memalign(
+        data,
+        count * sizeof(color_vertex),
+        sizeof(color_vertex)
+    );
+
+    cmd->data.draw.first = (size_t)vertex;
+    cmd->data.draw.count = count;
+
+    for (int i = 0; i < count; i++)
+    {
+        vertex[i].x = points[i].x;
+        vertex[i].y = points[i].y;
+        vertex[i].z = +0.5f;
+        vertex[i].color = color;
+    }
+    return 0;
+}
+
+static int
+VITA_GXM_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPoint * points, int count)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+    int color = data->drawstate.color;
+
+    color_vertex *vertex = (color_vertex *)pool_memalign(
+        data,
+        (count-1) * 2 * sizeof(color_vertex),
+        sizeof(color_vertex)
+    );
+
+    cmd->data.draw.first = (size_t)vertex;
+    cmd->data.draw.count = (count-1) * 2;
+
+    for (int i = 0; i < count - 1; i++)
+    {
+        vertex[i*2].x = points[i].x;
+        vertex[i*2].y = points[i].y;
+        vertex[i*2].z = +0.5f;
+        vertex[i*2].color = color;
+
+        vertex[i*2+1].x = points[i+1].x;
+        vertex[i*2+1].y = points[i+1].y;
+        vertex[i*2+1].z = +0.5f;
+        vertex[i*2+1].color = color;
+    }
+
+    return 0;
+}
+
+static int
+VITA_GXM_QueueFillRects(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FRect * rects, int count)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    cmd->data.draw.count = count;
+    int color = data->drawstate.color;
+
+    color_vertex *vertices = (color_vertex *)pool_memalign(
+            data,
+            4 * count * sizeof(color_vertex), // 4 vertices * count
+            sizeof(color_vertex));
+
+    for (int i =0; i < count; i++)
+    {
+        const SDL_FRect *rect = &rects[i];
+
+        vertices[4*i+0].x = rect->x;
+        vertices[4*i+0].y = rect->y;
+        vertices[4*i+0].z = +0.5f;
+        vertices[4*i+0].color = color;
+
+        vertices[4*i+1].x = rect->x + rect->w;
+        vertices[4*i+1].y = rect->y;
+        vertices[4*i+1].z = +0.5f;
+        vertices[4*i+1].color = color;
+
+        vertices[4*i+2].x = rect->x;
+        vertices[4*i+2].y = rect->y + rect->h;
+        vertices[4*i+2].z = +0.5f;
+        vertices[4*i+2].color = color;
+
+        vertices[4*i+3].x = rect->x + rect->w;
+        vertices[4*i+3].y = rect->y + rect->h;
+        vertices[4*i+3].z = +0.5f;
+        vertices[4*i+3].color = color;
+    }
+
+    cmd->data.draw.first = (size_t)vertices;
+
+    return 0;
+}
+
+
+#define PI   3.14159265358979f
+
+#define degToRad(x) ((x)*PI/180.f)
+
+void MathSincos(float r, float *s, float *c)
+{
+    *s = sinf(r);
+    *c = cosf(r);
+}
+
+void Swap(float *a, float *b)
+{
+    float n=*a;
+    *a = *b;
+    *b = n;
+}
+
+static int
+VITA_GXM_QueueCopy(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * texture,
+    const SDL_Rect * srcrect, const SDL_FRect * dstrect)
+{
+
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    cmd->data.draw.count = 1;
+
+    texture_vertex *vertices = (texture_vertex *)pool_memalign(
+            data,
+            4 * sizeof(texture_vertex), // 4 vertices
+            sizeof(texture_vertex));
+
+    cmd->data.draw.first = (size_t)vertices;
+    cmd->data.draw.texture = texture;
+
+    const float u0 = (float)srcrect->x / (float)texture->w;
+    const float v0 = (float)srcrect->y / (float)texture->h;
+    const float u1 = (float)(srcrect->x + srcrect->w) / (float)texture->w;
+    const float v1 = (float)(srcrect->y + srcrect->h) / (float)texture->h;
+
+    vertices[0].x = dstrect->x;
+    vertices[0].y = dstrect->y;
+    vertices[0].z = +0.5f;
+    vertices[0].u = u0;
+    vertices[0].v = v0;
+
+    vertices[1].x = dstrect->x + dstrect->w;
+    vertices[1].y = dstrect->y;
+    vertices[1].z = +0.5f;
+    vertices[1].u = u1;
+    vertices[1].v = v0;
+
+    vertices[2].x = dstrect->x;
+    vertices[2].y = dstrect->y + dstrect->h;
+    vertices[2].z = +0.5f;
+    vertices[2].u = u0;
+    vertices[2].v = v1;
+
+    vertices[3].x = dstrect->x + dstrect->w;
+    vertices[3].y = dstrect->y + dstrect->h;
+    vertices[3].z = +0.5f;
+    vertices[3].u = u1;
+    vertices[3].v = v1;
+
+    return 0;
+}
+
+static int
+VITA_GXM_QueueCopyEx(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * texture,
+    const SDL_Rect * srcrect, const SDL_FRect * dstrect,
+    const double angle, const SDL_FPoint *center, const SDL_RendererFlip flip)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    cmd->data.draw.count = 1;
+
+    texture_vertex *vertices = (texture_vertex *)pool_memalign(
+            data,
+            4 * sizeof(texture_vertex), // 4 vertices
+            sizeof(texture_vertex));
+
+    cmd->data.draw.first = (size_t)vertices;
+    cmd->data.draw.texture = texture;
+
+    float u0 = (float)srcrect->x / (float)texture->w;
+    float v0 = (float)srcrect->y / (float)texture->h;
+    float u1 = (float)(srcrect->x + srcrect->w) / (float)texture->w;
+    float v1 = (float)(srcrect->y + srcrect->h) / (float)texture->h;
+
+    if (flip & SDL_FLIP_VERTICAL) {
+        Swap(&v0, &v1);
+    }
+
+    if (flip & SDL_FLIP_HORIZONTAL) {
+        Swap(&u0, &u1);
+    }
+
+    const float centerx = center->x;
+    const float centery = center->y;
+    const float x = dstrect->x + centerx;
+    const float y = dstrect->y + centery;
+    const float width = dstrect->w - centerx;
+    const float height = dstrect->h - centery;
+    float s, c;
+
+    MathSincos(degToRad(angle), &s, &c);
+
+    const float cw = c * width;
+    const float sw = s * width;
+    const float ch = c * height;
+    const float sh = s * height;
+
+    vertices[0].x = x - cw + sh;
+    vertices[0].y = y - sw - ch;
+    vertices[0].z = +0.5f;
+    vertices[0].u = u0;
+    vertices[0].v = v0;
+
+    vertices[1].x = x + cw + sh;
+    vertices[1].y = y + sw - ch;
+    vertices[1].z = +0.5f;
+    vertices[1].u = u1;
+    vertices[1].v = v0;
+
+
+    vertices[2].x = x - cw - sh;
+    vertices[2].y = y - sw + ch;
+    vertices[2].z = +0.5f;
+    vertices[2].u = u0;
+    vertices[2].v = v1;
+
+    vertices[3].x = x + cw - sh;
+    vertices[3].y = y + sw + ch;
+    vertices[3].z = +0.5f;
+    vertices[3].u = u1;
+    vertices[3].v = v1;
+
+    return 0;
+}
+
+
+static int
+VITA_GXM_RenderClear(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    float clear_color[4];
+    clear_color[0] = (cmd->data.color.r)/255.0f;
+    clear_color[1] = (cmd->data.color.g)/255.0f;
+    clear_color[2] = (cmd->data.color.b)/255.0f;
+    clear_color[3] = (cmd->data.color.a)/255.0f;
+
+    // set clear shaders
+    data->drawstate.fragment_program = data->clearFragmentProgram;
+    data->drawstate.vertex_program = data->clearVertexProgram;
+    sceGxmSetVertexProgram(data->gxm_context, data->clearVertexProgram);
+    sceGxmSetFragmentProgram(data->gxm_context, data->clearFragmentProgram);
+
+    // set the clear color
+    void *color_buffer;
+    sceGxmReserveFragmentDefaultUniformBuffer(data->gxm_context, &color_buffer);
+    sceGxmSetUniformDataF(color_buffer, data->clearClearColorParam, 0, 4, clear_color);
+
+    // draw the clear triangle
+    sceGxmSetVertexStream(data->gxm_context, 0, data->clearVertices);
+    sceGxmDraw(data->gxm_context, SCE_GXM_PRIMITIVE_TRIANGLES, SCE_GXM_INDEX_FORMAT_U16, data->linearIndices, 3);
+
+    return 0;
+}
+
+
+static int
+VITA_GXM_RenderDrawPoints(SDL_Renderer *renderer, const SDL_RenderCommand *cmd)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    sceGxmSetFrontPolygonMode(data->gxm_context, SCE_GXM_POLYGON_MODE_POINT);
+    sceGxmDraw(data->gxm_context, SCE_GXM_PRIMITIVE_POINTS, SCE_GXM_INDEX_FORMAT_U16, data->linearIndices, cmd->data.draw.count);
+    sceGxmSetFrontPolygonMode(data->gxm_context, SCE_GXM_POLYGON_MODE_TRIANGLE_FILL);
+
+    return 0;
+}
+
+static int
+VITA_GXM_RenderDrawLines(SDL_Renderer *renderer, const SDL_RenderCommand *cmd)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    sceGxmSetFrontPolygonMode(data->gxm_context, SCE_GXM_POLYGON_MODE_LINE);
+    sceGxmDraw(data->gxm_context, SCE_GXM_PRIMITIVE_LINES, SCE_GXM_INDEX_FORMAT_U16, data->linearIndices, cmd->data.draw.count);
+    sceGxmSetFrontPolygonMode(data->gxm_context, SCE_GXM_POLYGON_MODE_TRIANGLE_FILL);
+    return 0;
+}
+
+
+static int
+VITA_GXM_RenderFillRects(SDL_Renderer *renderer, const SDL_RenderCommand *cmd)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    sceGxmSetVertexStream(data->gxm_context, 0, (const void*)cmd->data.draw.first);
+    sceGxmDraw(data->gxm_context, SCE_GXM_PRIMITIVE_TRIANGLE_STRIP, SCE_GXM_INDEX_FORMAT_U16, data->linearIndices, 4 * cmd->data.draw.count);
+
+    return 0;
+}
+
+
+static int
+SetDrawState(VITA_GXM_RenderData *data, const SDL_RenderCommand *cmd, SDL_bool solid)
+{
+    SDL_Texture *texture = cmd->data.draw.texture;
+    const SDL_BlendMode blend = cmd->data.draw.blend;
+    SceGxmFragmentProgram *fragment_program;
+    SceGxmVertexProgram *vertex_program;
+    SDL_bool matrix_updated = SDL_FALSE;
+    SDL_bool program_updated = SDL_FALSE;
+
+    Uint8 r, g, b, a;
+    r = cmd->data.draw.r;
+    g = cmd->data.draw.g;
+    b = cmd->data.draw.b;
+    a = cmd->data.draw.a;
+
+    if (data->drawstate.viewport_dirty) {
+        const SDL_Rect *viewport = &data->drawstate.viewport;
+
+
+        float sw = viewport->w  / 2.;
+        float sh = viewport->h / 2.;
+
+        float x_scale = sw;
+        float x_off = viewport->x + sw;
+        float y_scale = -(sh);
+        float y_off = viewport->y + sh;
+
+        sceGxmSetViewport(data->gxm_context, x_off, x_scale, y_off, y_scale, -0.5f, 0.5f);
+
+        if (viewport->w && viewport->h) {
+            init_orthographic_matrix(data->ortho_matrix,
+                (float) 0,
+                (float) viewport->w,
+                (float) viewport->h,
+                (float) 0,
+                0.0f, 1.0f);
+            matrix_updated = SDL_TRUE;
+        }
+
+        data->drawstate.viewport_dirty = SDL_FALSE;
+    }
+
+    if (data->drawstate.cliprect_enabled_dirty) {
+        if (!data->drawstate.cliprect_enabled) {
+            unset_clip_rectangle(data);
+        }
+        data->drawstate.cliprect_enabled_dirty = SDL_FALSE;
+    }
+
+    if (data->drawstate.cliprect_enabled && data->drawstate.cliprect_dirty) {
+        const SDL_Rect *viewport = &data->drawstate.viewport;
+        const SDL_Rect *rect = &data->drawstate.cliprect;
+        set_clip_rectangle(data, viewport->x + rect->x,
+                        data->drawstate.target ? viewport->y + rect->y : data->drawstate.drawableh - viewport->y - rect->y - rect->h,
+                        rect->w, rect->h);
+        data->drawstate.cliprect_dirty = SDL_FALSE;
+    }
+
+    VITA_GXM_SetBlendMode(data, blend); // do that first, to select appropriate shaders
+
+    if (texture) {
+        vertex_program = data->textureVertexProgram;
+        if(cmd->data.draw.r == 255 && cmd->data.draw.g == 255 && cmd->data.draw.b == 255 && cmd->data.draw.a == 255) {
+            fragment_program = data->textureFragmentProgram;
+        } else {
+            fragment_program = data->textureTintFragmentProgram;
+        }
+    } else {
+        vertex_program = data->colorVertexProgram;
+        fragment_program = data->colorFragmentProgram;
+    }
+
+    if (data->drawstate.vertex_program != vertex_program) {
+        data->drawstate.vertex_program = vertex_program;
+        sceGxmSetVertexProgram(data->gxm_context, vertex_program);
+        program_updated = SDL_TRUE;
+    }
+
+    if (data->drawstate.fragment_program != fragment_program) {
+        data->drawstate.fragment_program = fragment_program;
+        sceGxmSetFragmentProgram(data->gxm_context, fragment_program);
+        program_updated = SDL_TRUE;
+    }
+
+    Uint32 texture_color = ((a << 24) | (b << 16) | (g << 8) | r);
+
+    if (program_updated || matrix_updated) {
+        if (data->drawstate.fragment_program == data->textureFragmentProgram) {
+            void *vertex_wvp_buffer;
+            sceGxmReserveVertexDefaultUniformBuffer(data->gxm_context, &vertex_wvp_buffer);
+            sceGxmSetUniformDataF(vertex_wvp_buffer, data->textureWvpParam, 0, 16, data->ortho_matrix);
+        } else if (data->drawstate.fragment_program == data->textureTintFragmentProgram) {
+            void *vertex_wvp_buffer;
+            sceGxmReserveVertexDefaultUniformBuffer(data->gxm_context, &vertex_wvp_buffer);
+            sceGxmSetUniformDataF(vertex_wvp_buffer, data->textureWvpParam, 0, 16, data->ortho_matrix);
+
+            void *texture_tint_color_buffer;
+            sceGxmReserveFragmentDefaultUniformBuffer(data->gxm_context, &texture_tint_color_buffer);
+
+            float *tint_color = pool_memalign(
+                data,
+                4 * sizeof(float), // RGBA
+                sizeof(float)
+            );
+
+            tint_color[0] = r / 255.0f;
+            tint_color[1] = g / 255.0f;
+            tint_color[2] = b / 255.0f;
+            tint_color[3] = a / 255.0f;
+            sceGxmSetUniformDataF(texture_tint_color_buffer, data->textureTintColorParam, 0, 4, tint_color);
+            data->drawstate.texture_color = texture_color;
+        } else { // color
+            void *vertexDefaultBuffer;
+            sceGxmReserveVertexDefaultUniformBuffer(data->gxm_context, &vertexDefaultBuffer);
+            sceGxmSetUniformDataF(vertexDefaultBuffer, data->colorWvpParam, 0, 16, data->ortho_matrix);
+        }
+    } else {
+        if (data->drawstate.fragment_program == data->textureTintFragmentProgram && data->drawstate.texture_color != texture_color) {
+            void *texture_tint_color_buffer;
+            sceGxmReserveFragmentDefaultUniformBuffer(data->gxm_context, &texture_tint_color_buffer);
+
+            float *tint_color = pool_memalign(
+                data,
+                4 * sizeof(float), // RGBA
+                sizeof(float)
+            );
+
+            tint_color[0] = r / 255.0f;
+            tint_color[1] = g / 255.0f;
+            tint_color[2] = b / 255.0f;
+            tint_color[3] = a / 255.0f;
+            sceGxmSetUniformDataF(texture_tint_color_buffer, data->textureTintColorParam, 0, 4, tint_color);
+            data->drawstate.texture_color = texture_color;
+        }
+    }
+
+    if (texture != data->drawstate.texture) {
+        if (texture) {
+            VITA_GXM_TextureData *vita_texture = (VITA_GXM_TextureData *) cmd->data.draw.texture->driverdata;
+            sceGxmSetFragmentTexture(data->gxm_context, 0, &vita_texture->tex->gxm_tex);
+        }
+        data->drawstate.texture = texture;
+    }
+
+    /* all drawing commands use this */
+    sceGxmSetVertexStream(data->gxm_context, 0, (const void*)cmd->data.draw.first);
+
+    return 0;
+}
+
+static int
+SetCopyState(SDL_Renderer *renderer, const SDL_RenderCommand *cmd)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    return SetDrawState(data, cmd, SDL_FALSE);
+}
+
+static int
+VITA_GXM_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize)
+{
+    StartDrawing(renderer);
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    data->drawstate.target = renderer->target;
+    if (!data->drawstate.target) {
+        SDL_GL_GetDrawableSize(renderer->window, &data->drawstate.drawablew, &data->drawstate.drawableh);
+    }
+
+    while (cmd) {
+        switch (cmd->command) {
+
+            case SDL_RENDERCMD_SETVIEWPORT: {
+                SDL_Rect *viewport = &data->drawstate.viewport;
+                if (SDL_memcmp(viewport, &cmd->data.viewport.rect, sizeof (SDL_Rect)) != 0) {
+                    SDL_memcpy(viewport, &cmd->data.viewport.rect, sizeof (SDL_Rect));
+                    data->drawstate.viewport_dirty = SDL_TRUE;
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_SETCLIPRECT: {
+                const SDL_Rect *rect = &cmd->data.cliprect.rect;
+                if (data->drawstate.cliprect_enabled != cmd->data.cliprect.enabled) {
+                    data->drawstate.cliprect_enabled = cmd->data.cliprect.enabled;
+                    data->drawstate.cliprect_enabled_dirty = SDL_TRUE;
+                }
+
+                if (SDL_memcmp(&data->drawstate.cliprect, rect, sizeof (SDL_Rect)) != 0) {
+                    SDL_memcpy(&data->drawstate.cliprect, rect, sizeof (SDL_Rect));
+                    data->drawstate.cliprect_dirty = SDL_TRUE;
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_SETDRAWCOLOR: {
+                break;
+            }
+
+            case SDL_RENDERCMD_CLEAR: {
+                VITA_GXM_RenderClear(renderer, cmd);
+                break;
+            }
+
+            case SDL_RENDERCMD_DRAW_POINTS: {
+                SetDrawState(data, cmd, SDL_FALSE);
+                VITA_GXM_RenderDrawPoints(renderer, cmd);
+                break;
+            }
+
+            case SDL_RENDERCMD_DRAW_LINES: {
+                SetDrawState(data, cmd, SDL_FALSE);
+                VITA_GXM_RenderDrawLines(renderer, cmd);
+                break;
+            }
+
+            case SDL_RENDERCMD_FILL_RECTS: {
+                SetDrawState(data, cmd, SDL_FALSE);
+                VITA_GXM_RenderFillRects(renderer, cmd);
+                break;
+            }
+
+            case SDL_RENDERCMD_COPY:
+            case SDL_RENDERCMD_COPY_EX: {
+                SetCopyState(renderer, cmd);
+                sceGxmDraw(data->gxm_context, SCE_GXM_PRIMITIVE_TRIANGLE_STRIP, SCE_GXM_INDEX_FORMAT_U16, data->linearIndices, 4 * cmd->data.draw.count);
+
+                break;
+            }
+
+            case SDL_RENDERCMD_NO_OP:
+                break;
+        }
+        data->drawstate.last_command = cmd->command;
+        cmd = cmd->next;
+    }
+
+    sceGxmEndScene(data->gxm_context, NULL, NULL);
+    data->drawing = SDL_FALSE;
+
+    return 0;
+}
+
+void read_pixels(int x, int y, size_t width, size_t height, void *data) {
+    SceDisplayFrameBuf pParam;
+    pParam.size = sizeof(SceDisplayFrameBuf);
+
+    sceDisplayGetFrameBuf(&pParam, SCE_DISPLAY_SETBUF_NEXTFRAME);
+
+    int i, j;
+    Uint32 *out32 = (Uint32 *)data;
+    Uint32 *in32 = (Uint32 *)pParam.base;
+
+    in32 += (x + y * pParam.pitch);
+
+    for (i = 0; i < height; i++) {
+        for (j = 0; j < width; j++) {
+            out32[(height - (i + 1)) * width + j] = in32[j];
+        }
+        in32 += pParam.pitch;
+    }
+}
+
+
+static int
+VITA_GXM_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect,
+    Uint32 pixel_format, void *pixels, int pitch)
+{
+    // TODO: read from texture rendertarget. Although no-one sane should do it.
+    if (renderer->target) {
+        return SDL_Unsupported();
+    }
+
+    Uint32 temp_format = renderer->target ? renderer->target->format : SDL_PIXELFORMAT_ABGR8888;
+    size_t buflen;
+    void *temp_pixels;
+    int temp_pitch;
+    Uint8 *src, *dst, *tmp;
+    int w, h, length, rows;
+    int status;
+
+    temp_pitch = rect->w * SDL_BYTESPERPIXEL(temp_format);
+    buflen = rect->h * temp_pitch;
+    if (buflen == 0) {
+        return 0;  /* nothing to do. */
+    }
+
+    temp_pixels = SDL_malloc(buflen);
+    if (!temp_pixels) {
+        return SDL_OutOfMemory();
+    }
+
+    SDL_GetRendererOutputSize(renderer, &w, &h);
+
+    read_pixels(rect->x, renderer->target ? rect->y : (h-rect->y)-rect->h,
+                       rect->w, rect->h, temp_pixels);
+
+    /* Flip the rows to be top-down if necessary */
+
+    if (!renderer->target) {
+        SDL_bool isstack;
+        length = rect->w * SDL_BYTESPERPIXEL(temp_format);
+        src = (Uint8*)temp_pixels + (rect->h-1)*temp_pitch;
+        dst = (Uint8*)temp_pixels;
+        tmp = SDL_small_alloc(Uint8, length, &isstack);
+        rows = rect->h / 2;
+        while (rows--) {
+            SDL_memcpy(tmp, dst, length);
+            SDL_memcpy(dst, src, length);
+            SDL_memcpy(src, tmp, length);
+            dst += temp_pitch;
+            src -= temp_pitch;
+        }
+        SDL_small_free(tmp, isstack);
+    }
+
+    status = SDL_ConvertPixels(rect->w, rect->h,
+                               temp_format, temp_pixels, temp_pitch,
+                               pixel_format, pixels, pitch);
+    SDL_free(temp_pixels);
+
+    return status;
+}
+
+
+static void
+VITA_GXM_RenderPresent(SDL_Renderer *renderer)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+//    sceGxmFinish(data->gxm_context);
+
+    data->displayData.address = data->displayBufferData[data->backBufferIndex];
+
+
+    SceCommonDialogUpdateParam updateParam;
+
+    SDL_memset(&updateParam, 0, sizeof(updateParam));
+
+    updateParam.renderTarget.colorFormat    = VITA_GXM_COLOR_FORMAT;
+    updateParam.renderTarget.surfaceType    = SCE_GXM_COLOR_SURFACE_LINEAR;
+    updateParam.renderTarget.width          = VITA_GXM_SCREEN_WIDTH;
+    updateParam.renderTarget.height         = VITA_GXM_SCREEN_HEIGHT;
+    updateParam.renderTarget.strideInPixels = VITA_GXM_SCREEN_STRIDE;
+
+    updateParam.renderTarget.colorSurfaceData = data->displayBufferData[data->backBufferIndex];
+    updateParam.renderTarget.depthSurfaceData = data->depthBufferData;
+
+    updateParam.displaySyncObject = (SceGxmSyncObject *)data->displayBufferSync[data->backBufferIndex];
+
+    sceCommonDialogUpdate(&updateParam);
+
+
+    sceGxmDisplayQueueAddEntry(
+        data->displayBufferSync[data->frontBufferIndex],    // OLD fb
+        data->displayBufferSync[data->backBufferIndex],     // NEW fb
+        &data->displayData
+    );
+
+    // update buffer indices
+    data->frontBufferIndex = data->backBufferIndex;
+    data->backBufferIndex = (data->backBufferIndex + 1) % VITA_GXM_BUFFERS;
+    data->pool_index = 0;
+
+    data->current_pool = (data->current_pool + 1) % 2;
+
+    data->drawing = SDL_FALSE;
+}
+
+static void
+VITA_GXM_DestroyTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+    VITA_GXM_TextureData *vita_texture = (VITA_GXM_TextureData *) texture->driverdata;
+
+    if (data == 0)
+        return;
+
+    if(vita_texture == 0)
+        return;
+
+    if(vita_texture->tex == 0)
+        return;
+
+    sceGxmFinish(data->gxm_context);
+
+    if (vita_texture->tex->gxm_rendertarget) {
+        sceGxmDestroyRenderTarget(vita_texture->tex->gxm_rendertarget);
+    }
+
+    if (vita_texture->tex->depth_UID) {
+        mem_gpu_free(vita_texture->tex->depth_UID);
+    }
+
+    if (vita_texture->tex->palette_UID) {
+        mem_gpu_free(vita_texture->tex->palette_UID);
+    }
+
+    mem_gpu_free(vita_texture->tex->data_UID);
+    SDL_free(vita_texture->tex);
+    SDL_free(vita_texture);
+
+    texture->driverdata = NULL;
+}
+
+static void
+VITA_GXM_DestroyRenderer(SDL_Renderer *renderer)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+    if (data) {
+        if (!data->initialized)
+            return;
+
+        gxm_finish(renderer);
+
+        data->initialized = SDL_FALSE;
+        data->drawing = SDL_FALSE;
+        SDL_free(data);
+    }
+    SDL_free(renderer);
+}
+
+#endif /* SDL_VIDEO_RENDER_VITA_GXM */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagxm/SDL_render_vita_gxm_memory.c b/src/render/vitagxm/SDL_render_vita_gxm_memory.c
new file mode 100644
index 000000000..f9fbda652
--- /dev/null
+++ b/src/render/vitagxm/SDL_render_vita_gxm_memory.c
@@ -0,0 +1,117 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_VITA_GXM
+
+#include "SDL_render_vita_gxm_memory.h"
+
+void *
+mem_gpu_alloc(SceKernelMemBlockType type, unsigned int size, unsigned int alignment, unsigned int attribs, SceUID *uid)
+{
+    void *mem;
+
+    if (type == SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_RW) {
+        size = ALIGN(size, 256*1024);
+    } else {
+        size = ALIGN(size, 4*1024);
+    }
+
+    *uid = sceKernelAllocMemBlock("gpu_mem", type, size, NULL);
+
+    if (*uid < 0)
+        return NULL;
+
+    if (sceKernelGetMemBlockBase(*uid, &mem) < 0)
+        return NULL;
+
+    if (sceGxmMapMemory(mem, size, attribs) < 0)
+        return NULL;
+
+    return mem;
+}
+
+void
+mem_gpu_free(SceUID uid)
+{
+    void *mem = NULL;
+    if (sceKernelGetMemBlockBase(uid, &mem) < 0)
+        return;
+    sceGxmUnmapMemory(mem);
+    sceKernelFreeMemBlock(uid);
+}
+
+void *
+mem_vertex_usse_alloc(unsigned int size, SceUID *uid, unsigned int *usse_offset)
+{
+    void *mem = NULL;
+
+    size = ALIGN(size, 4096);
+    *uid = sceKernelAllocMemBlock("vertex_usse", SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE, size, NULL);
+
+    if (sceKernelGetMemBlockBase(*uid, &mem) < 0)
+        return NULL;
+    if (sceGxmMapVertexUsseMemory(mem, size, usse_offset) < 0)
+        return NULL;
+
+    return mem;
+}
+
+void
+mem_vertex_usse_free(SceUID uid)
+{
+    void *mem = NULL;
+    if (sceKernelGetMemBlockBase(uid, &mem) < 0)
+        return;
+    sceGxmUnmapVertexUsseMemory(mem);
+    sceKernelFreeMemBlock(uid);
+}
+
+void *
+mem_fragment_usse_alloc(unsigned int size, SceUID *uid, unsigned int *usse_offset)
+{
+    void *mem = NULL;
+
+    size = ALIGN(size, 4096);
+    *uid = sceKernelAllocMemBlock("fragment_usse", SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE, size, NULL);
+
+    if (sceKernelGetMemBlockBase(*uid, &mem) < 0)
+        return NULL;
+    if (sceGxmMapFragmentUsseMemory(mem, size, usse_offset) < 0)
+        return NULL;
+
+    return mem;
+}
+
+void
+mem_fragment_usse_free(SceUID uid)
+{
+    void *mem = NULL;
+    if (sceKernelGetMemBlockBase(uid, &mem) < 0)
+        return;
+    sceGxmUnmapFragmentUsseMemory(mem);
+    sceKernelFreeMemBlock(uid);
+}
+
+#endif /* SDL_VIDEO_RENDER_VITA_GXM */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagxm/SDL_render_vita_gxm_memory.h b/src/render/vitagxm/SDL_render_vita_gxm_memory.h
new file mode 100644
index 000000000..d8a23122f
--- /dev/null
+++ b/src/render/vitagxm/SDL_render_vita_gxm_memory.h
@@ -0,0 +1,40 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_RENDER_VITA_GXM_MEMORY_H
+#define SDL_RENDER_VITA_GXM_MEMORY_H
+
+#include <psp2/gxm.h>
+#include <psp2/types.h>
+#include <psp2/kernel/sysmem.h>
+
+#define ALIGN(x, a) (((x) + ((a) - 1)) & ~((a) - 1))
+
+void *mem_gpu_alloc(SceKernelMemBlockType type, unsigned int size, unsigned int alignment, unsigned int attribs, SceUID *uid);
+void mem_gpu_free(SceUID uid);
+void *mem_vertex_usse_alloc(unsigned int size, SceUID *uid, unsigned int *usse_offset);
+void mem_vertex_usse_free(SceUID uid);
+void *mem_fragment_usse_alloc(unsigned int size, SceUID *uid, unsigned int *usse_offset);
+void mem_fragment_usse_free(SceUID uid);
+
+#endif /* SDL_RENDER_VITA_GXM_MEMORY_H */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagxm/SDL_render_vita_gxm_shaders.h b/src/render/vitagxm/SDL_render_vita_gxm_shaders.h
new file mode 100644
index 000000000..9d13e42cd
--- /dev/null
+++ b/src/render/vitagxm/SDL_render_vita_gxm_shaders.h
@@ -0,0 +1,313 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_RENDER_VITA_GXM_SHADERS_H
+#define SDL_RENDER_VITA_GXM_SHADERS_H
+
+#include <psp2/gxm.h>
+
+#define gxm_shader_clear_f_size 232
+static const unsigned char gxm_shader_clear_f[gxm_shader_clear_f_size] = {
+    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x50, 0x03, 
+    0xe8, 0x00, 0x00, 0x00, 0xa2, 0x55, 0x22, 0x3e, 
+    0xc6, 0x7e, 0x77, 0xf1, 0x01, 0x00, 0x18, 0x00, 
+    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0xa4, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x68, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x5c, 0x00, 0x00, 0x00, 0xc0, 0x3d, 0x03, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 
+    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x07, 0x44, 0xfa, 0x02, 0x80, 0x19, 0xf0, 
+    0x7e, 0x0d, 0x80, 0x40, 0x0e, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 
+    0x01, 0xe4, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x75, 0x43, 0x6c, 0x65, 
+    0x61, 0x72, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 
+};
+
+#define gxm_shader_clear_v_size 252
+static const unsigned char gxm_shader_clear_v[gxm_shader_clear_v_size] = {
+    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x50, 0x03, 
+    0xfa, 0x00, 0x00, 0x00, 0xdc, 0x25, 0x34, 0x74, 
+    0x53, 0x4a, 0x7a, 0x5b, 0x04, 0x00, 0x19, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0xb8, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x74, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x78, 0x00, 0x00, 0x00, 0xc0, 0x3d, 0x03, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x04, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x44, 0xfa, 
+    0x01, 0x00, 0x04, 0x90, 0x85, 0x11, 0xa5, 0x08, 
+    0x01, 0x80, 0x56, 0x90, 0x81, 0x11, 0x83, 0x08, 
+    0x00, 0x00, 0x20, 0xa0, 0x00, 0x50, 0x27, 0xfb, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x61, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
+    0x6e, 0x00, 0x00, 0x00, 
+};
+
+#define gxm_shader_color_f_size 212
+static const unsigned char gxm_shader_color_f[gxm_shader_color_f_size] = {
+    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x50, 0x03, 
+    0xd4, 0x00, 0x00, 0x00, 0x9c, 0xd6, 0x9b, 0xf7, 
+    0x78, 0x00, 0x5d, 0x31, 0x01, 0x10, 0x18, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xac, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x78, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x6c, 0x00, 0x00, 0x00, 0xc0, 0x3d, 0x03, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 
+    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x0f, 0xa0, 0xd0, 0x0e, 0x00, 0x00, 0x00, 0x00, 
+    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x07, 0x44, 0xfa, 0x02, 0x80, 0x19, 0xa0, 
+    0x7e, 0x0d, 0x80, 0x40, 
+};
+
+#define gxm_shader_color_v_size 344
+static const unsigned char gxm_shader_color_v[gxm_shader_color_v_size] = {
+    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x50, 0x03, 
+    0x55, 0x01, 0x00, 0x00, 0x2e, 0x35, 0x0f, 0x26, 
+    0x23, 0x46, 0x37, 0xbb, 0x00, 0x00, 0x19, 0x00, 
+    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0xe8, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x00, 0x00, 
+    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x74, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
+    0xa0, 0x00, 0x00, 0x00, 0xc0, 0x3d, 0x03, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x08, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x44, 0xfa, 
+    0x80, 0x00, 0x08, 0x83, 0x21, 0x1d, 0x80, 0x38, 
+    0x02, 0x80, 0x81, 0xaf, 0x9c, 0x0d, 0xc0, 0x40, 
+    0x0e, 0x86, 0xb9, 0xff, 0xbc, 0x0d, 0xc0, 0x40, 
+    0x04, 0x11, 0x49, 0xcf, 0x80, 0x8f, 0xb1, 0x18, 
+    0x02, 0x11, 0x45, 0xcf, 0x80, 0x8f, 0xb1, 0x18, 
+    0x00, 0x11, 0x01, 0xc0, 0x81, 0x81, 0xb1, 0x18, 
+    0x01, 0xd1, 0x42, 0xc0, 0x81, 0x81, 0xb1, 0x18, 
+    0x00, 0x00, 0x20, 0xa0, 0x00, 0x50, 0x27, 0xfb, 
+    0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 
+    0x30, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x21, 0x00, 0x00, 0x00, 0x01, 0xe4, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x61, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
+    0x6e, 0x00, 0x61, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
+    0x00, 0x77, 0x76, 0x70, 0x00, 0x00, 0x00, 0x00, 
+};
+
+#define gxm_shader_texture_f_size 256
+static const unsigned char gxm_shader_texture_f[gxm_shader_texture_f_size] = {
+    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x50, 0x03, 
+    0x00, 0x01, 0x00, 0x00, 0x2f, 0x18, 0xe0, 0x2b, 
+    0x1f, 0x21, 0x47, 0x49, 0x01, 0x08, 0x18, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0xa4, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x78, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x64, 0x00, 0x00, 0x00, 0xc0, 0x3d, 0x03, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
+    0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 
+    0x01, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x00, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x40, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x07, 0x44, 0xfa, 0x30, 0x00, 0x00, 0x00, 
+    0x02, 0x04, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x74, 0x65, 0x78, 0x00, 
+};
+
+#define gxm_shader_texture_tint_f_size 324
+static const unsigned char gxm_shader_texture_tint_f[gxm_shader_texture_tint_f_size] = {
+    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x50, 0x03, 
+    0x43, 0x01, 0x00, 0x00, 0x44, 0x2f, 0x5d, 0xfe, 
+    0x9e, 0xda, 0xf8, 0x6f, 0x05, 0x08, 0x18, 0x00, 
+    0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0xcc, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x01, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x78, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x84, 0x00, 0x00, 0x00, 0xc0, 0x3d, 0x03, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
+    0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 
+    0x01, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x00, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xc0, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x07, 0x44, 0xfa, 0x00, 0x00, 0x00, 0x00, 
+    0x40, 0x09, 0x00, 0xf8, 0x02, 0x80, 0x99, 0xff, 
+    0xbc, 0x0d, 0xc0, 0x40, 0x02, 0x80, 0xb9, 0xaf, 
+    0xbc, 0x0d, 0x80, 0x40, 0x7c, 0x0f, 0x04, 0x00, 
+    0x86, 0x47, 0xa4, 0x10, 0x0e, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x01, 0xe4, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x00, 
+    0x02, 0x04, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x75, 0x54, 0x69, 0x6e, 
+    0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x74, 
+    0x65, 0x78, 0x00, 0x00, 
+};
+
+#define gxm_shader_texture_v_size 344
+static const unsigned char gxm_shader_texture_v[gxm_shader_texture_v_size] = {
+    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x50, 0x03, 
+    0x58, 0x01, 0x00, 0x00, 0xa3, 0x36, 0x7b, 0x62, 
+    0x1b, 0x80, 0x1c, 0xb0, 0x00, 0x00, 0x19, 0x00, 
+    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0xe8, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x00, 0x00, 
+    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x74, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
+    0xa0, 0x00, 0x00, 0x00, 0xc0, 0x3d, 0x03, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x06, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x44, 0xfa, 
+    0x80, 0x00, 0x08, 0x83, 0x21, 0x0d, 0x80, 0x38, 
+    0x02, 0x80, 0x81, 0xaf, 0x9c, 0x0d, 0xc0, 0x40, 
+    0x0e, 0x86, 0xb9, 0xff, 0xbc, 0x0d, 0xc0, 0x40, 
+    0x04, 0x11, 0x49, 0xcf, 0x80, 0x8f, 0xb1, 0x18, 
+    0x02, 0x11, 0x45, 0xcf, 0x80, 0x8f, 0xb1, 0x18, 
+    0x00, 0x11, 0x01, 0xc0, 0x81, 0x81, 0xb1, 0x18, 
+    0x01, 0xd1, 0x42, 0xc0, 0x81, 0x81, 0xb1, 0x18, 
+    0x00, 0x00, 0x20, 0xa0, 0x00, 0x50, 0x27, 0xfb, 
+    0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 
+    0x30, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x24, 0x00, 0x00, 0x00, 0x01, 0xe4, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x61, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
+    0x6e, 0x00, 0x61, 0x54, 0x65, 0x78, 0x63, 0x6f, 
+    0x6f, 0x72, 0x64, 0x00, 0x77, 0x76, 0x70, 0x00, 
+};
+
+
+static const SceGxmProgram *const clearVertexProgramGxp         = (const SceGxmProgram*)gxm_shader_clear_v;
+static const SceGxmProgram *const clearFragmentProgramGxp       = (const SceGxmProgram *)gxm_shader_clear_f;
+static const SceGxmProgram *const colorVertexProgramGxp         = (const SceGxmProgram *)gxm_shader_color_v;
+static const SceGxmProgram *const colorFragmentProgramGxp       = (const SceGxmProgram *)gxm_shader_color_f;
+static const SceGxmProgram *const textureVertexProgramGxp       = (const SceGxmProgram *)gxm_shader_texture_v;
+static const SceGxmProgram *const textureFragmentProgramGxp     = (const SceGxmProgram *)gxm_shader_texture_f;
+static const SceGxmProgram *const textureTintFragmentProgramGxp = (const SceGxmProgram *)gxm_shader_texture_tint_f;
+
+#endif // SDL_RENDER_VITA_GXM_SHADERS_H
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagxm/SDL_render_vita_gxm_tools.c b/src/render/vitagxm/SDL_render_vita_gxm_tools.c
new file mode 100644
index 000000000..12065cedf
--- /dev/null
+++ b/src/render/vitagxm/SDL_render_vita_gxm_tools.c
@@ -0,0 +1,1159 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_VITA_GXM
+
+#include "SDL_hints.h"
+#include "../SDL_sysrender.h"
+#include "SDL_log.h"
+
+#include <psp2/kernel/processmgr.h>
+#include <psp2/appmgr.h>
+#include <psp2/display.h>
+#include <psp2/gxm.h>
+#include <psp2/types.h>
+#include <psp2/kernel/sysmem.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <stdarg.h>
+#include <stdlib.h>
+
+#include "SDL_render_vita_gxm_tools.h"
+#include "SDL_render_vita_gxm_types.h"
+#include "SDL_render_vita_gxm_memory.h"
+#include "SDL_render_vita_gxm_shaders.h"
+
+void
+init_orthographic_matrix(float *m, float left, float right, float bottom, float top, float near, float far)
+{
+    m[0x0] = 2.0f/(right-left);
+    m[0x4] = 0.0f;
+    m[0x8] = 0.0f;
+    m[0xC] = -(right+left)/(right-left);
+
+    m[0x1] = 0.0f;
+    m[0x5] = 2.0f/(top-bottom);
+    m[0x9] = 0.0f;
+    m[0xD] = -(top+bottom)/(top-bottom);
+
+    m[0x2] = 0.0f;
+    m[0x6] = 0.0f;
+    m[0xA] = -2.0f/(far-near);
+    m[0xE] = (far+near)/(far-near);
+
+    m[0x3] = 0.0f;
+    m[0x7] = 0.0f;
+    m[0xB] = 0.0f;
+    m[0xF] = 1.0f;
+}
+
+static void *
+patcher_host_alloc(void *user_data, unsigned int size)
+{
+    (void)user_data;
+    void *mem = SDL_malloc(size);
+    return mem;
+}
+
+static void
+patcher_host_free(void *user_data, void *mem)
+{
+    (void)user_data;
+    SDL_free(mem);
+}
+
+void *
+pool_malloc(VITA_GXM_RenderData *data, unsigned int size)
+{
+
+    if ((data->pool_index + size) < VITA_GXM_POOL_SIZE) {
+        void *addr = (void *)((unsigned int)data->pool_addr[data->current_pool] + data->pool_index);
+        data->pool_index += size;
+        return addr;
+    }
+    SDL_LogError(SDL_LOG_CATEGORY_RENDER, "POOL OVERFLOW\n");
+    return NULL;
+}
+
+void *
+pool_memalign(VITA_GXM_RenderData *data, unsigned int size, unsigned int alignment)
+{
+    unsigned int new_index = (data->pool_index + alignment - 1) & ~(alignment - 1);
+    if ((new_index + size) < VITA_GXM_POOL_SIZE) {
+        void *addr = (void *)((unsigned int)data->pool_addr[data->current_pool] + new_index);
+        data->pool_index = new_index + size;
+        return addr;
+    }
+    SDL_LogError(SDL_LOG_CATEGORY_RENDER, "POOL OVERFLOW\n");
+    return NULL;
+}
+
+static int
+tex_format_to_bytespp(SceGxmTextureFormat format)
+{
+    switch (format & 0x9f000000U) {
+    case SCE_GXM_TEXTURE_BASE_FORMAT_U8:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_S8:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_P8:
+        return 1;
+    case SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_U8U3U3U2:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_U5U6U5:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_S5S5U6:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_U8U8:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_S8S8:
+        return 2;
+    case SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8:
+        return 3;
+    case SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_F32:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_U32:
+    case SCE_GXM_TEXTURE_BASE_FORMAT_S32:
+    default:
+        return 4;
+    }
+}
+
+static void
+display_callback(const void *callback_data)
+{
+    SceDisplayFrameBuf framebuf;
+    const VITA_GXM_DisplayData *display_data = (const VITA_GXM_DisplayData *)callback_data;
+
+    SDL_memset(&framebuf, 0x00, sizeof(SceDisplayFrameBuf));
+    framebuf.size        = sizeof(SceDisplayFrameBuf);
+    framebuf.base        = display_data->address;
+    framebuf.pitch       = VITA_GXM_SCREEN_STRIDE;
+    framebuf.pixelformat = VITA_GXM_PIXEL_FORMAT;
+    framebuf.width       = VITA_GXM_SCREEN_WIDTH;
+    framebuf.height      = VITA_GXM_SCREEN_HEIGHT;
+    sceDisplaySetFrameBuf(&framebuf, SCE_DISPLAY_SETBUF_NEXTFRAME);
+
+    if (display_data->wait_vblank) {
+        sceDisplayWaitVblankStart();
+    }
+}
+
+static void
+free_fragment_programs(VITA_GXM_RenderData *data, fragment_programs *out)
+{
+    sceGxmShaderPatcherReleaseFragmentProgram(data->shaderPatcher, out->color);
+    sceGxmShaderPatcherReleaseFragmentProgram(data->shaderPatcher, out->texture);
+    sceGxmShaderPatcherReleaseFragmentProgram(data->shaderPatcher, out->textureTint);
+}
+
+static void
+make_fragment_programs(VITA_GXM_RenderData *data, fragment_programs *out,
+    const SceGxmBlendInfo *blend_info)
+{
+    int err;
+
+    err = sceGxmShaderPatcherCreateFragmentProgram(
+        data->shaderPatcher,
+        data->colorFragmentProgramId,
+        SCE_GXM_OUTPUT_REGISTER_FORMAT_UCHAR4,
+        0,
+        blend_info,
+        colorVertexProgramGxp,
+        &out->color
+    );
+
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Patcher create fragment failed: %d\n", err);
+        return;
+    }
+
+    err = sceGxmShaderPatcherCreateFragmentProgram(
+        data->shaderPatcher,
+        data->textureFragmentProgramId,
+        SCE_GXM_OUTPUT_REGISTER_FORMAT_UCHAR4,
+        0,
+        blend_info,
+        textureVertexProgramGxp,
+        &out->texture
+    );
+
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Patcher create fragment failed: %d\n", err);
+        return;
+    }
+
+    err = sceGxmShaderPatcherCreateFragmentProgram(
+        data->shaderPatcher,
+        data->textureTintFragmentProgramId,
+        SCE_GXM_OUTPUT_REGISTER_FORMAT_UCHAR4,
+        0,
+        blend_info,
+        textureVertexProgramGxp,
+        &out->textureTint
+    );
+
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Patcher create fragment failed: %d\n", err);
+        return;
+    }
+}
+
+
+static void
+set_stencil_mask(VITA_GXM_RenderData *data, float x, float y, float w, float h)
+{
+    color_vertex *vertices = (color_vertex *)pool_memalign(
+        data,
+        4 * sizeof(color_vertex), // 4 vertices
+        sizeof(color_vertex)
+    );
+
+    vertices[0].x = x;
+    vertices[0].y = y;
+    vertices[0].z = +0.5f;
+    vertices[0].color = 0;
+
+    vertices[1].x = x + w;
+    vertices[1].y = y;
+    vertices[1].z = +0.5f;
+    vertices[1].color = 0;
+
+    vertices[2].x = x;
+    vertices[2].y = y + h;
+    vertices[2].z = +0.5f;
+    vertices[2].color = 0;
+
+    vertices[3].x = x + w;
+    vertices[3].y = y + h;
+    vertices[3].z = +0.5f;
+    vertices[3].color = 0;
+
+    data->drawstate.fragment_program = data->colorFragmentProgram;
+    data->drawstate.vertex_program = data->colorVertexProgram;
+    sceGxmSetVertexProgram(data->gxm_context, data->colorVertexProgram);
+    sceGxmSetFragmentProgram(data->gxm_context, data->colorFragmentProgram);
+
+    void *vertexDefaultBuffer;
+    sceGxmReserveVertexDefaultUniformBuffer(data->gxm_context, &vertexDefaultBuffer);
+    sceGxmSetUniformDataF(vertexDefaultBuffer, data->colorWvpParam, 0, 16, data->ortho_matrix);
+
+    sceGxmSetVertexStream(data->gxm_context, 0, vertices);
+    sceGxmDraw(data->gxm_context, SCE_GXM_PRIMITIVE_TRIANGLE_STRIP, SCE_GXM_INDEX_FORMAT_U16, data->linearIndices, 4);
+}
+
+
+void
+set_clip_rectangle(VITA_GXM_RenderData *data, int x_min, int y_min, int x_max, int y_max)
+{
+    if(data->drawing) {
+        // clear the stencil buffer to 0
+        sceGxmSetFrontStencilFunc(
+            data->gxm_context,
+            SCE_GXM_STENCIL_FUNC_NEVER,
+            SCE_GXM_STENCIL_OP_ZERO,
+            SCE_GXM_STENCIL_OP_ZERO,
+            SCE_GXM_STENCIL_OP_ZERO,
+            0xFF,
+            0xFF
+        );
+
+        set_stencil_mask(data, 0, 0, VITA_GXM_SCREEN_WIDTH, VITA_GXM_SCREEN_HEIGHT);
+
+        // set the stencil to 1 in the desired region
+        sceGxmSetFrontStencilFunc(
+            data->gxm_context,
+            SCE_GXM_STENCIL_FUNC_NEVER,
+            SCE_GXM_STENCIL_OP_REPLACE,
+            SCE_GXM_STENCIL_OP_REPLACE,
+            SCE_GXM_STENCIL_OP_REPLACE,
+            0xFF,
+            0xFF
+        );
+
+        set_stencil_mask(data, x_min, y_min, x_max - x_min, y_max - y_min);
+
+        // set the stencil function to only accept pixels where the stencil is 1
+        sceGxmSetFrontStencilFunc(
+            data->gxm_context,
+            SCE_GXM_STENCIL_FUNC_EQUAL,
+            SCE_GXM_STENCIL_OP_KEEP,
+            SCE_GXM_STENCIL_OP_KEEP,
+            SCE_GXM_STENCIL_OP_KEEP,
+            0xFF,
+            0xFF
+        );
+    }
+}
+
+void
+unset_clip_rectangle(VITA_GXM_RenderData *data)
+{
+    sceGxmSetFrontStencilFunc(
+        data->gxm_context,
+        SCE_GXM_STENCIL_FUNC_ALWAYS,
+        SCE_GXM_STENCIL_OP_KEEP,
+        SCE_GXM_STENCIL_OP_KEEP,
+        SCE_GXM_STENCIL_OP_KEEP,
+        0xFF,
+        0xFF
+    );
+}
+
+int
+gxm_init(SDL_Renderer *renderer)
+{
+    unsigned int i, x, y;
+    int err;
+
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    SceGxmInitializeParams initializeParams;
+    SDL_memset(&initializeParams, 0, sizeof(SceGxmInitializeParams));
+    initializeParams.flags                          = 0;
+    initializeParams.displayQueueMaxPendingCount    = VITA_GXM_PENDING_SWAPS;
+    initializeParams.displayQueueCallback           = display_callback;
+    initializeParams.displayQueueCallbackDataSize   = sizeof(VITA_GXM_DisplayData);
+    initializeParams.parameterBufferSize            = SCE_GXM_DEFAULT_PARAMETER_BUFFER_SIZE;
+
+    err = sceGxmInitialize(&initializeParams);
+
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "gxm init failed: %d\n", err);
+        return err;
+    }
+
+    // allocate ring buffer memory using default sizes
+    void *vdmRingBuffer = mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
+        SCE_GXM_DEFAULT_VDM_RING_BUFFER_SIZE,
+        4,
+        SCE_GXM_MEMORY_ATTRIB_READ,
+        &data->vdmRingBufferUid);
+
+    void *vertexRingBuffer = mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
+        SCE_GXM_DEFAULT_VERTEX_RING_BUFFER_SIZE,
+        4,
+        SCE_GXM_MEMORY_ATTRIB_READ,
+        &data->vertexRingBufferUid);
+
+    void *fragmentRingBuffer = mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
+        SCE_GXM_DEFAULT_FRAGMENT_RING_BUFFER_SIZE,
+        4,
+        SCE_GXM_MEMORY_ATTRIB_READ,
+        &data->fragmentRingBufferUid);
+
+    unsigned int fragmentUsseRingBufferOffset;
+    void *fragmentUsseRingBuffer = mem_fragment_usse_alloc(
+        SCE_GXM_DEFAULT_FRAGMENT_USSE_RING_BUFFER_SIZE,
+        &data->fragmentUsseRingBufferUid,
+        &fragmentUsseRingBufferOffset);
+
+    SDL_memset(&data->contextParams, 0, sizeof(SceGxmContextParams));
+    data->contextParams.hostMem                       = SDL_malloc(SCE_GXM_MINIMUM_CONTEXT_HOST_MEM_SIZE);
+    data->contextParams.hostMemSize                   = SCE_GXM_MINIMUM_CONTEXT_HOST_MEM_SIZE;
+    data->contextParams.vdmRingBufferMem              = vdmRingBuffer;
+    data->contextParams.vdmRingBufferMemSize          = SCE_GXM_DEFAULT_VDM_RING_BUFFER_SIZE;
+    data->contextParams.vertexRingBufferMem           = vertexRingBuffer;
+    data->contextParams.vertexRingBufferMemSize       = SCE_GXM_DEFAULT_VERTEX_RING_BUFFER_SIZE;
+    data->contextParams.fragmentRingBufferMem         = fragmentRingBuffer;
+    data->contextParams.fragmentRingBufferMemSize     = SCE_GXM_DEFAULT_FRAGMENT_RING_BUFFER_SIZE;
+    data->contextParams.fragmentUsseRingBufferMem     = fragmentUsseRingBuffer;
+    data->contextParams.fragmentUsseRingBufferMemSize = SCE_GXM_DEFAULT_FRAGMENT_USSE_RING_BUFFER_SIZE;
+    data->contextParams.fragmentUsseRingBufferOffset  = fragmentUsseRingBufferOffset;
+
+    err = sceGxmCreateContext(&data->contextParams, &data->gxm_context);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "create context failed: %d\n", err);
+        return err;
+    }
+
+    // set up parameters
+    SceGxmRenderTargetParams renderTargetParams;
+    SDL_memset(&renderTargetParams, 0, sizeof(SceGxmRenderTargetParams));
+    renderTargetParams.flags                = 0;
+    renderTargetParams.width                = VITA_GXM_SCREEN_WIDTH;
+    renderTargetParams.height               = VITA_GXM_SCREEN_HEIGHT;
+    renderTargetParams.scenesPerFrame       = 1;
+    renderTargetParams.multisampleMode      = 0;
+    renderTargetParams.multisampleLocations = 0;
+    renderTargetParams.driverMemBlock       = -1; // Invalid UID
+
+    // create the render target
+    err = sceGxmCreateRenderTarget(&renderTargetParams, &data->renderTarget);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "render target creation failed: %d\n", err);
+        return err;
+    }
+
+    // allocate memory and sync objects for display buffers
+    for (i = 0; i < VITA_GXM_BUFFERS; i++) {
+
+        // allocate memory for display
+        data->displayBufferData[i] = mem_gpu_alloc(
+            SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_RW,
+            4 * VITA_GXM_SCREEN_STRIDE * VITA_GXM_SCREEN_HEIGHT,
+            SCE_GXM_COLOR_SURFACE_ALIGNMENT,
+            SCE_GXM_MEMORY_ATTRIB_READ | SCE_GXM_MEMORY_ATTRIB_WRITE,
+            &data->displayBufferUid[i]);
+
+        // memset the buffer to black
+        for (y = 0; y < VITA_GXM_SCREEN_HEIGHT; y++) {
+            unsigned int *row = (unsigned int *)data->displayBufferData[i] + y * VITA_GXM_SCREEN_STRIDE;
+            for (x = 0; x < VITA_GXM_SCREEN_WIDTH; x++) {
+                row[x] = 0xff000000;
+            }
+        }
+
+        // initialize a color surface for this display buffer
+        err = sceGxmColorSurfaceInit(
+            &data->displaySurface[i],
+            VITA_GXM_COLOR_FORMAT,
+            SCE_GXM_COLOR_SURFACE_LINEAR,
+            SCE_GXM_COLOR_SURFACE_SCALE_NONE,
+            SCE_GXM_OUTPUT_REGISTER_SIZE_32BIT,
+            VITA_GXM_SCREEN_WIDTH,
+            VITA_GXM_SCREEN_HEIGHT,
+            VITA_GXM_SCREEN_STRIDE,
+            data->displayBufferData[i]
+        );
+
+        if (err != SCE_OK) {
+            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "color surface init failed: %d\n", err);
+            return err;
+        }
+
+
+        // create a sync object that we will associate with this buffer
+        err = sceGxmSyncObjectCreate(&data->displayBufferSync[i]);
+        if (err != SCE_OK) {
+            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "sync object creation failed: %d\n", err);
+            return err;
+        }
+
+    }
+
+    // compute the memory footprint of the depth buffer
+    const unsigned int alignedWidth = ALIGN(VITA_GXM_SCREEN_WIDTH, SCE_GXM_TILE_SIZEX);
+    const unsigned int alignedHeight = ALIGN(VITA_GXM_SCREEN_HEIGHT, SCE_GXM_TILE_SIZEY);
+
+    unsigned int sampleCount = alignedWidth * alignedHeight;
+    unsigned int depthStrideInSamples = alignedWidth;
+
+    // allocate the depth buffer
+    data->depthBufferData = mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
+        4 * sampleCount,
+        SCE_GXM_DEPTHSTENCIL_SURFACE_ALIGNMENT,
+        SCE_GXM_MEMORY_ATTRIB_READ | SCE_GXM_MEMORY_ATTRIB_WRITE,
+        &data->depthBufferUid);
+
+    // allocate the stencil buffer
+    data->stencilBufferData = mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
+        4 * sampleCount,
+        SCE_GXM_DEPTHSTENCIL_SURFACE_ALIGNMENT,
+        SCE_GXM_MEMORY_ATTRIB_READ | SCE_GXM_MEMORY_ATTRIB_WRITE,
+        &data->stencilBufferUid);
+
+    // create the SceGxmDepthStencilSurface structure
+    err = sceGxmDepthStencilSurfaceInit(
+        &data->depthSurface,
+        SCE_GXM_DEPTH_STENCIL_FORMAT_S8D24,
+        SCE_GXM_DEPTH_STENCIL_SURFACE_TILED,
+        depthStrideInSamples,
+        data->depthBufferData,
+        data->stencilBufferData);
+
+    // set the stencil test reference (this is currently assumed to always remain 1 after here for region clipping)
+    sceGxmSetFrontStencilRef(data->gxm_context, 1);
+
+
+    // set the stencil function (this wouldn't actually be needed, as the set clip rectangle function has to call this at the begginning of every scene)
+    sceGxmSetFrontStencilFunc(
+        data->gxm_context,
+        SCE_GXM_STENCIL_FUNC_ALWAYS,
+        SCE_GXM_STENCIL_OP_KEEP,
+        SCE_GXM_STENCIL_OP_KEEP,
+        SCE_GXM_STENCIL_OP_KEEP,
+        0xFF,
+        0xFF);
+
+    // set buffer sizes for this sample
+    const unsigned int patcherBufferSize        = 64*1024;
+    const unsigned int patcherVertexUsseSize    = 64*1024;
+    const unsigned int patcherFragmentUsseSize  = 64*1024;
+
+    // allocate memory for buffers and USSE code
+    void *patcherBuffer = mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
+        patcherBufferSize,
+        4,
+        SCE_GXM_MEMORY_ATTRIB_READ | SCE_GXM_MEMORY_ATTRIB_WRITE,
+        &data->patcherBufferUid);
+
+    unsigned int patcherVertexUsseOffset;
+    void *patcherVertexUsse = mem_vertex_usse_alloc(
+        patcherVertexUsseSize,
+        &data->patcherVertexUsseUid,
+        &patcherVertexUsseOffset);
+
+    unsigned int patcherFragmentUsseOffset;
+    void *patcherFragmentUsse = mem_fragment_usse_alloc(
+        patcherFragmentUsseSize,
+        &data->patcherFragmentUsseUid,
+        &patcherFragmentUsseOffset);
+
+    // create a shader patcher
+    SceGxmShaderPatcherParams patcherParams;
+    SDL_memset(&patcherParams, 0, sizeof(SceGxmShaderPatcherParams));
+    patcherParams.userData                  = NULL;
+    patcherParams.hostAllocCallback         = &patcher_host_alloc;
+    patcherParams.hostFreeCallback          = &patcher_host_free;
+    patcherParams.bufferAllocCallback       = NULL;
+    patcherParams.bufferFreeCallback        = NULL;
+    patcherParams.bufferMem                 = patcherBuffer;
+    patcherParams.bufferMemSize             = patcherBufferSize;
+    patcherParams.vertexUsseAllocCallback   = NULL;
+    patcherParams.vertexUsseFreeCallback    = NULL;
+    patcherParams.vertexUsseMem             = patcherVertexUsse;
+    patcherParams.vertexUsseMemSize         = patcherVertexUsseSize;
+    patcherParams.vertexUsseOffset          = patcherVertexUsseOffset;
+    patcherParams.fragmentUsseAllocCallback = NULL;
+    patcherParams.fragmentUsseFreeCallback  = NULL;
+    patcherParams.fragmentUsseMem           = patcherFragmentUsse;
+    patcherParams.fragmentUsseMemSize       = patcherFragmentUsseSize;
+    patcherParams.fragmentUsseOffset        = patcherFragmentUsseOffset;
+
+    err = sceGxmShaderPatcherCreate(&patcherParams, &data->shaderPatcher);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "shader patcher creation failed: %d\n", err);
+        return err;
+    }
+
+
+    // check the shaders
+    err = sceGxmProgramCheck(clearVertexProgramGxp);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "check program (clear vertex) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmProgramCheck(clearFragmentProgramGxp);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "check program (clear fragment) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmProgramCheck(colorVertexProgramGxp);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "check program (color vertex) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmProgramCheck(colorFragmentProgramGxp);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "check program (color fragment) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmProgramCheck(textureVertexProgramGxp);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "check program (texture vertex) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmProgramCheck(textureFragmentProgramGxp);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "check program (texture fragment) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmProgramCheck(textureTintFragmentProgramGxp);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "check program (texture tint fragment) failed: %d\n", err);
+        return err;
+    }
+
+    // register programs with the patcher
+    err = sceGxmShaderPatcherRegisterProgram(data->shaderPatcher, clearVertexProgramGxp, &data->clearVertexProgramId);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "register program (clear vertex) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmShaderPatcherRegisterProgram(data->shaderPatcher, clearFragmentProgramGxp, &data->clearFragmentProgramId);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "register program (clear fragment) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmShaderPatcherRegisterProgram(data->shaderPatcher, colorVertexProgramGxp, &data->colorVertexProgramId);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "register program (color vertex) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmShaderPatcherRegisterProgram(data->shaderPatcher, colorFragmentProgramGxp, &data->colorFragmentProgramId);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "register program (color fragment) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmShaderPatcherRegisterProgram(data->shaderPatcher, textureVertexProgramGxp, &data->textureVertexProgramId);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "register program (texture vertex) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmShaderPatcherRegisterProgram(data->shaderPatcher, textureFragmentProgramGxp, &data->textureFragmentProgramId);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "register program (texture fragment) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmShaderPatcherRegisterProgram(data->shaderPatcher, textureTintFragmentProgramGxp, &data->textureTintFragmentProgramId);
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "register program (texture tint fragment) failed: %d\n", err);
+        return err;
+    }
+
+    // Fill SceGxmBlendInfo
+    static const SceGxmBlendInfo blend_info_none = {
+        .colorFunc = SCE_GXM_BLEND_FUNC_NONE,
+        .alphaFunc = SCE_GXM_BLEND_FUNC_NONE,
+        .colorSrc  = SCE_GXM_BLEND_FACTOR_ZERO,
+        .colorDst  = SCE_GXM_BLEND_FACTOR_ZERO,
+        .alphaSrc  = SCE_GXM_BLEND_FACTOR_ZERO,
+        .alphaDst  = SCE_GXM_BLEND_FACTOR_ZERO,
+        .colorMask = SCE_GXM_COLOR_MASK_ALL
+    };
+
+    static const SceGxmBlendInfo blend_info_blend = {
+        .colorFunc = SCE_GXM_BLEND_FUNC_ADD,
+        .alphaFunc = SCE_GXM_BLEND_FUNC_ADD,
+        .colorSrc  = SCE_GXM_BLEND_FACTOR_SRC_ALPHA,
+        .colorDst  = SCE_GXM_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
+        .alphaSrc  = SCE_GXM_BLEND_FACTOR_ONE,
+        .alphaDst  = SCE_GXM_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
+        .colorMask = SCE_GXM_COLOR_MASK_ALL
+    };
+
+    static const SceGxmBlendInfo blend_info_add = {
+        .colorFunc = SCE_GXM_BLEND_FUNC_ADD,
+        .alphaFunc = SCE_GXM_BLEND_FUNC_ADD,
+        .colorSrc  = SCE_GXM_BLEND_FACTOR_SRC_ALPHA,
+        .colorDst  = SCE_GXM_BLEND_FACTOR_ONE,
+        .alphaSrc  = SCE_GXM_BLEND_FACTOR_ZERO,
+        .alphaDst  = SCE_GXM_BLEND_FACTOR_ONE,
+        .colorMask = SCE_GXM_COLOR_MASK_ALL
+    };
+
+    static const SceGxmBlendInfo blend_info_mod = {
+        .colorFunc = SCE_GXM_BLEND_FUNC_ADD,
+        .alphaFunc = SCE_GXM_BLEND_FUNC_ADD,
+
+        .colorSrc  = SCE_GXM_BLEND_FACTOR_ZERO,
+        .colorDst  = SCE_GXM_BLEND_FACTOR_SRC_COLOR,
+
+        .alphaSrc  = SCE_GXM_BLEND_FACTOR_ZERO,
+        .alphaDst  = SCE_GXM_BLEND_FACTOR_ONE,
+        .colorMask = SCE_GXM_COLOR_MASK_ALL
+    };
+
+    static const SceGxmBlendInfo blend_info_mul = {
+        .colorFunc = SCE_GXM_BLEND_FUNC_ADD,
+        .alphaFunc = SCE_GXM_BLEND_FUNC_ADD,
+        .colorSrc  = SCE_GXM_BLEND_FACTOR_DST_COLOR,
+        .colorDst  = SCE_GXM_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
+        .alphaSrc  = SCE_GXM_BLEND_FACTOR_DST_ALPHA,
+        .alphaDst  = SCE_GXM_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
+        .colorMask = SCE_GXM_COLOR_MASK_ALL
+    };
+
+    // get attributes by name to create vertex format bindings
+    const SceGxmProgramParameter *paramClearPositionAttribute = sceGxmProgramFindParameterByName(clearVertexProgramGxp, "aPosition");
+
+    // create clear vertex format
+    SceGxmVertexAttribute clearVertexAttributes[1];
+    SceGxmVertexStream clearVertexStreams[1];
+    clearVertexAttributes[0].streamIndex    = 0;
+    clearVertexAttributes[0].offset         = 0;
+    clearVertexAttributes[0].format         = SCE_GXM_ATTRIBUTE_FORMAT_F32;
+    clearVertexAttributes[0].componentCount = 2;
+    clearVertexAttributes[0].regIndex       = sceGxmProgramParameterGetResourceIndex(paramClearPositionAttribute);
+    clearVertexStreams[0].stride            = sizeof(clear_vertex);
+    clearVertexStreams[0].indexSource       = SCE_GXM_INDEX_SOURCE_INDEX_16BIT;
+
+    // create clear programs
+    err = sceGxmShaderPatcherCreateVertexProgram(
+        data->shaderPatcher,
+        data->clearVertexProgramId,
+        clearVertexAttributes,
+        1,
+        clearVertexStreams,
+        1,
+        &data->clearVertexProgram
+    );
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "create program (clear vertex) failed: %d\n", err);
+        return err;
+    }
+
+    err = sceGxmShaderPatcherCreateFragmentProgram(
+        data->shaderPatcher,
+        data->clearFragmentProgramId,
+        SCE_GXM_OUTPUT_REGISTER_FORMAT_UCHAR4,
+        0,
+        NULL,
+        clearVertexProgramGxp,
+        &data->clearFragmentProgram
+    );
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "create program (clear fragment) failed: %d\n", err);
+        return err;
+    }
+
+    // create the clear triangle vertex/index data
+    data->clearVertices = (clear_vertex *)mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
+        3*sizeof(clear_vertex),
+        4,
+        SCE_GXM_MEMORY_ATTRIB_READ,
+        &data->clearVerticesUid
+    );
+
+    // Allocate a 64k * 2 bytes = 128 KiB buffer and store all possible
+    // 16-bit indices in linear ascending order, so we can use this for
+    // all drawing operations where we don't want to use indexing.
+    data->linearIndices = (uint16_t *)mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
+        UINT16_MAX*sizeof(uint16_t),
+        sizeof(uint16_t),
+        SCE_GXM_MEMORY_ATTRIB_READ,
+        &data->linearIndicesUid
+    );
+
+    for (uint32_t i=0; i<=UINT16_MAX; ++i)
+    {
+        data->linearIndices[i] = i;
+    }
+
+    data->clearVertices[0].x = -1.0f;
+    data->clearVertices[0].y = -1.0f;
+    data->clearVertices[1].x =  3.0f;
+    data->clearVertices[1].y = -1.0f;
+    data->clearVertices[2].x = -1.0f;
+    data->clearVertices[2].y =  3.0f;
+
+    const SceGxmProgramParameter *paramColorPositionAttribute = sceGxmProgramFindParameterByName(colorVertexProgramGxp, "aPosition");
+
+    const SceGxmProgramParameter *paramColorColorAttribute = sceGxmProgramFindParameterByName(colorVertexProgramGxp, "aColor");
+
+    // create color vertex format
+    SceGxmVertexAttribute colorVertexAttributes[2];
+    SceGxmVertexStream colorVertexStreams[1];
+    /* x,y,z: 3 float 32 bits */
+    colorVertexAttributes[0].streamIndex = 0;
+    colorVertexAttributes[0].offset = 0;
+    colorVertexAttributes[0].format = SCE_GXM_ATTRIBUTE_FORMAT_F32;
+    colorVertexAttributes[0].componentCount = 3; // (x, y, z)
+    colorVertexAttributes[0].regIndex = sceGxmProgramParameterGetResourceIndex(paramColorPositionAttribute);
+    /* color: 4 unsigned char  = 32 bits */
+    colorVertexAttributes[1].streamIndex = 0;
+    colorVertexAttributes[1].offset = 12; // (x, y, z) * 4 = 12 bytes
+    colorVertexAttributes[1].format = SCE_GXM_ATTRIBUTE_FORMAT_U8N;
+    colorVertexAttributes[1].componentCount = 4; // (color)
+    colorVertexAttributes[1].regIndex = sceGxmProgramParameterGetResourceIndex(paramColorColorAttribute);
+    // 16 bit (short) indices
+    colorVertexStreams[0].stride = sizeof(color_vertex);
+    colorVertexStreams[0].indexSource = SCE_GXM_INDEX_SOURCE_INDEX_16BIT;
+
+    // create color shaders
+    err = sceGxmShaderPatcherCreateVertexProgram(
+        data->shaderPatcher,
+        data->colorVertexProgramId,
+        colorVertexAttributes,
+        2,
+        colorVertexStreams,
+        1,
+        &data->colorVertexProgram
+    );
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "create program (color vertex) failed: %d\n", err);
+        return err;
+    }
+
+    const SceGxmProgramParameter *paramTexturePositionAttribute = sceGxmProgramFindParameterByName(textureVertexProgramGxp, "aPosition");
+    const SceGxmProgramParameter *paramTextureTexcoordAttribute = sceGxmProgramFindParameterByName(textureVertexProgramGxp, "aTexcoord");
+
+    // create texture vertex format
+    SceGxmVertexAttribute textureVertexAttributes[2];
+    SceGxmVertexStream textureVertexStreams[1];
+    /* x,y,z: 3 float 32 bits */
+    textureVertexAttributes[0].streamIndex = 0;
+    textureVertexAttributes[0].offset = 0;
+    textureVertexAttributes[0].format = SCE_GXM_ATTRIBUTE_FORMAT_F32;
+    textureVertexAttributes[0].componentCount = 3; // (x, y, z)
+    textureVertexAttributes[0].regIndex = sceGxmProgramParameterGetResourceIndex(paramTexturePositionAttribute);
+    /* u,v: 2 floats 32 bits */
+    textureVertexAttributes[1].streamIndex = 0;
+    textureVertexAttributes[1].offset = 12; // (x, y, z) * 4 = 12 bytes
+    textureVertexAttributes[1].format = SCE_GXM_ATTRIBUTE_FORMAT_F32;
+    textureVertexAttributes[1].componentCount = 2; // (u, v)
+    textureVertexAttributes[1].regIndex = sceGxmProgramParameterGetResourceIndex(paramTextureTexcoordAttribute);
+    // 16 bit (short) indices
+    textureVertexStreams[0].stride = sizeof(texture_vertex);
+    textureVertexStreams[0].indexSource = SCE_GXM_INDEX_SOURCE_INDEX_16BIT;
+
+    // create texture shaders
+    err = sceGxmShaderPatcherCreateVertexProgram(
+        data->shaderPatcher,
+        data->textureVertexProgramId,
+        textureVertexAttributes,
+        2,
+        textureVertexStreams,
+        1,
+        &data->textureVertexProgram
+    );
+    if (err != SCE_OK) {
+        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "create program (texture vertex) failed: %d\n", err);
+        return err;
+    }
+
+    // Create variations of the fragment program based on blending mode
+    make_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_none, &blend_info_none);
+    make_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_blend, &blend_info_blend);
+    make_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_add, &blend_info_add);
+    make_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_mod, &blend_info_mod);
+    make_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_mul, &blend_info_mul);
+
+    // Default to blend blending mode
+    fragment_programs *in = &data->blendFragmentPrograms.blend_mode_blend;
+
+    data->colorFragmentProgram = in->color;
+    data->textureFragmentProgram = in->texture;
+    data->textureTintFragmentProgram = in->textureTint;
+
+    // find vertex uniforms by name and cache parameter information
+    data->clearClearColorParam = (SceGxmProgramParameter *)sceGxmProgramFindParameterByName(clearFragmentProgramGxp, "uClearColor");
+    data->colorWvpParam = (SceGxmProgramParameter *)sceGxmProgramFindParameterByName(colorVertexProgramGxp, "wvp");
+    data->textureWvpParam = (SceGxmProgramParameter *)sceGxmProgramFindParameterByName(textureVertexProgramGxp, "wvp");
+    data->textureTintColorParam = (SceGxmProgramParameter *)sceGxmProgramFindParameterByName(textureTintFragmentProgramGxp, "uTintColor");
+
+    // Allocate memory for the memory pool
+    data->pool_addr[0] = mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW,
+        VITA_GXM_POOL_SIZE,
+        sizeof(void *),
+        SCE_GXM_MEMORY_ATTRIB_READ,
+        &data->poolUid[0]
+    );
+
+    data->pool_addr[1] = mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW,
+        VITA_GXM_POOL_SIZE,
+        sizeof(void *),
+        SCE_GXM_MEMORY_ATTRIB_READ,
+        &data->poolUid[1]
+    );
+
+    init_orthographic_matrix(data->ortho_matrix, 0.0f, VITA_GXM_SCREEN_WIDTH, VITA_GXM_SCREEN_HEIGHT, 0.0f, 0.0f, 1.0f);
+
+    data->backBufferIndex = 0;
+    data->frontBufferIndex = 0;
+    data->pool_index = 0;
+    data->current_pool = 0;
+    data->currentBlendMode = SDL_BLENDMODE_BLEND;
+
+    return 0;
+}
+
+void gxm_finish(SDL_Renderer *renderer)
+{
+    VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
+
+    // wait until rendering is done
+    sceGxmFinish(data->gxm_context);
+
+    // clean up allocations
+    sceGxmShaderPatcherReleaseFragmentProgram(data->shaderPatcher, data->clearFragmentProgram);
+    sceGxmShaderPatcherReleaseVertexProgram(data->shaderPatcher, data->clearVertexProgram);
+    sceGxmShaderPatcherReleaseVertexProgram(data->shaderPatcher, data->colorVertexProgram);
+    sceGxmShaderPatcherReleaseVertexProgram(data->shaderPatcher, data->textureVertexProgram);
+
+
+    free_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_none);
+    free_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_blend);
+    free_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_add);
+    free_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_mod);
+    free_fragment_programs(data, &data->blendFragmentPrograms.blend_mode_mul);
+
+    mem_gpu_free(data->linearIndicesUid);
+    mem_gpu_free(data->clearVerticesUid);
+
+    // wait until display queue is finished before deallocating display buffers
+    sceGxmDisplayQueueFinish();
+
+    // clean up display queue
+    mem_gpu_free(data->depthBufferUid);
+
+    for (size_t i = 0; i < VITA_GXM_BUFFERS; i++)
+    {
+        // clear the buffer then deallocate
+        SDL_memset(data->displayBufferData[i], 0, VITA_GXM_SCREEN_HEIGHT * VITA_GXM_SCREEN_STRIDE * 4);
+        mem_gpu_free(data->displayBufferUid[i]);
+
+        // destroy the sync object
+        sceGxmSyncObjectDestroy(data->displayBufferSync[i]);
+    }
+
+    // free the depth and stencil buffer
+    mem_gpu_free(data->depthBufferUid);
+    mem_gpu_free(data->stencilBufferUid);
+
+    // unregister programs and destroy shader patcher
+    sceGxmShaderPatcherUnregisterProgram(data->shaderPatcher, data->clearFragmentProgramId);
+    sceGxmShaderPatcherUnregisterProgram(data->shaderPatcher, data->clearVertexProgramId);
+    sceGxmShaderPatcherUnregisterProgram(data->shaderPatcher, data->colorFragmentProgramId);
+    sceGxmShaderPatcherUnregisterProgram(data->shaderPatcher, data->colorVertexProgramId);
+    sceGxmShaderPatcherUnregisterProgram(data->shaderPatcher, data->textureFragmentProgramId);
+    sceGxmShaderPatcherUnregisterProgram(data->shaderPatcher, data->textureTintFragmentProgramId);
+    sceGxmShaderPatcherUnregisterProgram(data->shaderPatcher, data->textureVertexProgramId);
+
+    sceGxmShaderPatcherDestroy(data->shaderPatcher);
+    mem_fragment_usse_free(data->patcherFragmentUsseUid);
+    mem_vertex_usse_free(data->patcherVertexUsseUid);
+    mem_gpu_free(data->patcherBufferUid);
+
+    // destroy the render target
+    sceGxmDestroyRenderTarget(data->renderTarget);
+
+    // destroy the gxm context
+    sceGxmDestroyContext(data->gxm_context);
+    mem_fragment_usse_free(data->fragmentUsseRingBufferUid);
+    mem_gpu_free(data->fragmentRingBufferUid);
+    mem_gpu_free(data->vertexRingBufferUid);
+    mem_gpu_free(data->vdmRingBufferUid);
+    SDL_free(data->contextParams.hostMem);
+
+    mem_gpu_free(data->poolUid[0]);
+    mem_gpu_free(data->poolUid[1]);
+
+    // terminate libgxm
+    sceGxmTerminate();
+}
+
+// textures
+
+void
+free_gxm_texture(gxm_texture *texture)
+{
+    if (texture) {
+        if (texture->gxm_rendertarget) {
+            sceGxmDestroyRenderTarget(texture->gxm_rendertarget);
+        }
+        if (texture->depth_UID) {
+            mem_gpu_free(texture->depth_UID);
+        }
+        if (texture->palette_UID) {
+            mem_gpu_free(texture->palette_UID);
+        }
+        mem_gpu_free(texture->data_UID);
+        SDL_free(texture);
+    }
+}
+
+SceGxmTextureFormat
+gxm_texture_get_format(const gxm_texture *texture)
+{
+    return sceGxmTextureGetFormat(&texture->gxm_tex);
+}
+
+unsigned int
+gxm_texture_get_width(const gxm_texture *texture)
+{
+    return sceGxmTextureGetWidth(&texture->gxm_tex);
+}
+
+unsigned int
+gxm_texture_get_height(const gxm_texture *texture)
+{
+    return sceGxmTextureGetHeight(&texture->gxm_tex);
+}
+
+unsigned int
+gxm_texture_get_stride(const gxm_texture *texture)
+{
+    return ((gxm_texture_get_width(texture) + 7) & ~7)
+        * tex_format_to_bytespp(gxm_texture_get_format(texture));
+}
+
+void *
+gxm_texture_get_datap(const gxm_texture *texture)
+{
+    return sceGxmTextureGetData(&texture->gxm_tex);
+}
+
+gxm_texture *
+create_gxm_texture(VITA_GXM_RenderData *data, unsigned int w, unsigned int h, SceGxmTextureFormat format, unsigned int isRenderTarget)
+{
+    format = SCE_GXM_TEXTURE_FORMAT_A8B8G8R8;
+    gxm_texture *texture = SDL_malloc(sizeof(gxm_texture));
+    if (!texture)
+        return NULL;
+
+    const int tex_size =  ((w + 7) & ~ 7) * h * tex_format_to_bytespp(format);
+
+    /* Allocate a GPU buffer for the texture */
+    void *texture_data = mem_gpu_alloc(
+        SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_RW,
+        tex_size,
+        SCE_GXM_TEXTURE_ALIGNMENT,
+        SCE_GXM_MEMORY_ATTRIB_READ | SCE_GXM_MEMORY_ATTRIB_WRITE,
+        &texture->data_UID
+    );
+
+    if (!texture_data) {
+        free(texture);
+        return NULL;
+    }
+
+    /* Clear the texture */
+    SDL_memset(texture_data, 0, tex_size);
+
+    /* Create the gxm texture */
+    sceGxmTextureInitLinear( &texture->gxm_tex, texture_data, format, w, h, 0);
+
+    if ((format & 0x9f000000U) == SCE_GXM_TEXTURE_BASE_FORMAT_P8) {
+        const int pal_size = 256 * sizeof(uint32_t);
+
+        void *texture_palette = mem_gpu_alloc(
+            SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_RW,
+            pal_size,
+            SCE_GXM_PALETTE_ALIGNMENT,
+            SCE_GXM_MEMORY_ATTRIB_READ,
+            &texture->palette_UID);
+
+        if (!texture_palette) {
+            texture->palette_UID = 0;
+            free_gxm_texture(texture);
+            return NULL;
+        }
+
+        SDL_memset(texture_palette, 0, pal_size);
+
+        sceGxmTextureSetPalette(&texture->gxm_tex, texture_palette);
+    } else {
+        texture->palette_UID = 0;
+    }
+
+    if (isRenderTarget) {
+
+        int err = sceGxmColorSurfaceInit(
+            &texture->gxm_colorsurface,
+            SCE_GXM_COLOR_FORMAT_A8B8G8R8,
+            SCE_GXM_COLOR_SURFACE_LINEAR,
+            SCE_GXM_COLOR_SURFACE_SCALE_NONE,
+            SCE_GXM_OUTPUT_REGISTER_SIZE_32BIT,
+            w,
+            h,
+            w,
+            texture_data
+        );
+
+        if (err < 0) {
+            free_gxm_texture(texture);
+            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "color surface init failed: %d\n", err);
+            return NULL;
+        }
+
+        // create the depth/stencil surface
+        const uint32_t alignedWidth = ALIGN(w, SCE_GXM_TILE_SIZEX);
+        const uint32_t alignedHeight = ALIGN(h, SCE_GXM_TILE_SIZEY);
+        uint32_t sampleCount = alignedWidth*alignedHeight;
+        uint32_t depthStrideInSamples = alignedWidth;
+
+        // allocate it
+        void *depthBufferData = mem_gpu_alloc(
+            SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
+            4*sampleCount,
+            SCE_GXM_DEPTHSTENCIL_SURFACE_ALIGNMENT,
+            SCE_GXM_MEMORY_ATTRIB_READ | SCE_GXM_MEMORY_ATTRIB_WRITE,
+            &texture->depth_UID);
+
+        // create the SceGxmDepthStencilSurface structure
+        err = sceGxmDepthStencilSurfaceInit(
+            &texture->gxm_depthstencil,
+            SCE_GXM_DEPTH_STENCIL_FORMAT_S8D24,
+            SCE_GXM_DEPTH_STENCIL_SURFACE_TILED,
+            depthStrideInSamples,
+            depthBufferData,
+            NULL);
+
+        if (err < 0) {
+            free_gxm_texture(texture);
+            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "depth stencil init failed: %d\n", err);
+            return NULL;
+        }
+
+        SceGxmRenderTarget *tgt = NULL;
+
+        // set up parameters
+        SceGxmRenderTargetParams renderTargetParams;
+        memset(&renderTargetParams, 0, sizeof(SceGxmRenderTargetParams));
+        renderTargetParams.flags = 0;
+        renderTargetParams.width = w;
+        renderTargetParams.height = h;
+        renderTargetParams.scenesPerFrame = 1;
+        renderTargetParams.multisampleMode = SCE_GXM_MULTISAMPLE_NONE;
+        renderTargetParams.multisampleLocations = 0;
+        renderTargetParams.driverMemBlock = -1;
+
+        // create the render target
+        err = sceGxmCreateRenderTarget(&renderTargetParams, &tgt);
+
+        texture->gxm_rendertarget = tgt;
+
+        if (err < 0) {
+            free_gxm_texture(texture);
+            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "create render target failed: %d\n", err);
+            return NULL;
+        }
+
+    }
+
+    return texture;
+}
+
+void
+gxm_texture_set_filters(gxm_texture *texture, SceGxmTextureFilter min_filter, SceGxmTextureFilter mag_filter)
+{
+    sceGxmTextureSetMinFilter(&texture->gxm_tex, min_filter);
+    sceGxmTextureSetMagFilter(&texture->gxm_tex, mag_filter);
+}
+
+#endif /* SDL_VIDEO_RENDER_VITA_GXM */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagxm/SDL_render_vita_gxm_tools.h b/src/render/vitagxm/SDL_render_vita_gxm_tools.h
new file mode 100644
index 000000000..c1dfc6c0e
--- /dev/null
+++ b/src/render/vitagxm/SDL_render_vita_gxm_tools.h
@@ -0,0 +1,64 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_RENDER_VITA_GXM_TOOLS_H
+#define SDL_RENDER_VITA_GXM_TOOLS_H
+
+#include "../../SDL_internal.h"
+
+#include "SDL_hints.h"
+#include "../SDL_sysrender.h"
+
+#include <psp2/kernel/processmgr.h>
+#include <psp2/appmgr.h>
+#include <psp2/display.h>
+#include <psp2/gxm.h>
+#include <psp2/types.h>
+#include <psp2/kernel/sysmem.h>
+
+#include "SDL_render_vita_gxm_types.h"
+
+void
+init_orthographic_matrix(float *m, float left, float right, float bottom, float top, float near, float far);
+
+void *pool_malloc(VITA_GXM_RenderData *data, unsigned int size);
+void *pool_memalign(VITA_GXM_RenderData *data, unsigned int size, unsigned int alignment);
+
+void set_clip_rectangle(VITA_GXM_RenderData *data, int x_min, int y_min, int x_max, int y_max);
+void unset_clip_rectangle(VITA_GXM_RenderData *data);
+
+int gxm_init(SDL_Renderer *renderer);
+void gxm_finish(SDL_Renderer *renderer);
+
+gxm_texture *create_gxm_texture(VITA_GXM_RenderData *data, unsigned int w, unsigned int h, SceGxmTextureFormat format, unsigned int isRenderTarget);
+void free_gxm_texture(gxm_texture *texture);
+
+void gxm_texture_set_filters(gxm_texture *texture, SceGxmTextureFilter min_filter, SceGxmTextureFilter mag_filter);
+SceGxmTextureFormat gxm_texture_get_format(const gxm_texture *texture);
+
+unsigned int gxm_texture_get_width(const gxm_texture *texture);
+unsigned int gxm_texture_get_height(const gxm_texture *texture);
+unsigned int gxm_texture_get_stride(const gxm_texture *texture);
+void *gxm_texture_get_datap(const gxm_texture *texture);
+
+#endif /* SDL_RENDER_VITA_GXM_TOOLS_H */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagxm/SDL_render_vita_gxm_types.h b/src/render/vitagxm/SDL_render_vita_gxm_types.h
new file mode 100644
index 000000000..fa146acb4
--- /dev/null
+++ b/src/render/vitagxm/SDL_render_vita_gxm_types.h
@@ -0,0 +1,208 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_RENDER_VITA_GXM_TYPES_H
+#define SDL_RENDER_VITA_GXM_TYPES_H
+
+#include "../../SDL_internal.h"
+
+#include "SDL_hints.h"
+#include "../SDL_sysrender.h"
+
+#include <psp2/kernel/processmgr.h>
+#include <psp2/appmgr.h>
+#include <psp2/display.h>
+#include <psp2/gxm.h>
+#include <psp2/types.h>
+#include <psp2/kernel/sysmem.h>
+
+#include <string.h>
+
+#define VITA_GXM_SCREEN_WIDTH     960
+#define VITA_GXM_SCREEN_HEIGHT    544
+#define VITA_GXM_SCREEN_STRIDE    960
+
+#define VITA_GXM_COLOR_FORMAT    SCE_GXM_COLOR_FORMAT_A8B8G8R8
+#define VITA_GXM_PIXEL_FORMAT    SCE_DISPLAY_PIXELFORMAT_A8B8G8R8
+
+#define VITA_GXM_BUFFERS          3
+#define VITA_GXM_PENDING_SWAPS    2
+#define VITA_GXM_POOL_SIZE        2 * 1024 * 1024
+
+typedef struct
+{
+    void     *address;
+    Uint8    wait_vblank;
+} VITA_GXM_DisplayData;
+
+typedef struct clear_vertex {
+    float x;
+    float y;
+} clear_vertex;
+
+typedef struct color_vertex {
+    float x;
+    float y;
+    float z;
+    unsigned int color;
+} color_vertex;
+
+typedef struct texture_vertex {
+    float x;
+    float y;
+    float z;
+    float u;
+    float v;
+} texture_vertex;
+
+typedef struct gxm_texture {
+    SceGxmTexture gxm_tex;
+    SceUID data_UID;
+    SceUID palette_UID;
+    SceGxmRenderTarget *gxm_rendertarget;
+    SceGxmColorSurface gxm_colorsurface;
+    SceGxmDepthStencilSurface gxm_depthstencil;
+    SceUID depth_UID;
+} gxm_texture;
+
+typedef struct fragment_programs {
+    SceGxmFragmentProgram *color;
+    SceGxmFragmentProgram *texture;
+    SceGxmFragmentProgram *textureTint;
+} fragment_programs;
+
+typedef struct blend_fragment_programs {
+    fragment_programs blend_mode_none;
+    fragment_programs blend_mode_blend;
+    fragment_programs blend_mode_add;
+    fragment_programs blend_mode_mod;
+    fragment_programs blend_mode_mul;
+} blend_fragment_programs;
+
+typedef struct
+{
+    SDL_Rect viewport;
+    SDL_bool viewport_dirty;
+    SDL_Texture *texture;
+    SDL_Texture *target;
+    Uint32 color;
+    Uint32 texture_color;
+    SceGxmFragmentProgram *fragment_program;
+    SceGxmVertexProgram *vertex_program;
+    int last_command;
+
+    SDL_bool cliprect_enabled_dirty;
+    SDL_bool cliprect_enabled;
+    SDL_bool cliprect_dirty;
+    SDL_Rect cliprect;
+    SDL_bool texturing;
+    Uint32 clear_color;
+    int drawablew;
+    int drawableh;
+} gxm_drawstate_cache;
+
+typedef struct
+{
+    SDL_bool      initialized;
+    SDL_bool      drawing;
+
+    unsigned int  psm;
+    unsigned int  bpp;
+
+    int           currentBlendMode;
+
+    VITA_GXM_DisplayData displayData;
+
+    SceUID vdmRingBufferUid;
+    SceUID vertexRingBufferUid;
+    SceUID fragmentRingBufferUid;
+    SceUID fragmentUsseRingBufferUid;
+    SceGxmContextParams contextParams;
+    SceGxmContext *gxm_context;
+    SceGxmRenderTarget *renderTarget;
+    SceUID displayBufferUid[VITA_GXM_BUFFERS];
+    void *displayBufferData[VITA_GXM_BUFFERS];
+    SceGxmColorSurface displaySurface[VITA_GXM_BUFFERS];
+    SceGxmSyncObject *displayBufferSync[VITA_GXM_BUFFERS];
+
+    SceUID depthBufferUid;
+    SceUID stencilBufferUid;
+    SceGxmDepthStencilSurface depthSurface;
+    void *depthBufferData;
+    void *stencilBufferData;
+
+    unsigned int backBufferIndex;
+    unsigned int frontBufferIndex;
+
+    void* pool_addr[2];
+    SceUID poolUid[2];
+    unsigned int pool_index;
+    unsigned int current_pool;
+
+    float ortho_matrix[4*4];
+
+    SceGxmVertexProgram *colorVertexProgram;
+    SceGxmFragmentProgram *colorFragmentProgram;
+    SceGxmVertexProgram *textureVertexProgram;
+    SceGxmFragmentProgram *textureFragmentProgram;
+    SceGxmFragmentProgram *textureTintFragmentProgram;
+    SceGxmProgramParameter *clearClearColorParam;
+    SceGxmProgramParameter *colorWvpParam;
+    SceGxmProgramParameter *textureWvpParam;
+    SceGxmProgramParameter *textureTintColorParam;
+
+    SceGxmShaderPatcher *shaderPatcher;
+    SceGxmVertexProgram *clearVertexProgram;
+    SceGxmFragmentProgram *clearFragmentProgram;
+
+    SceGxmShaderPatcherId clearVertexProgramId;
+    SceGxmShaderPatcherId clearFragmentProgramId;
+    SceGxmShaderPatcherId colorVertexProgramId;
+    SceGxmShaderPatcherId colorFragmentProgramId;
+    SceGxmShaderPatcherId textureVertexProgramId;
+    SceGxmShaderPatcherId textureFragmentProgramId;
+    SceGxmShaderPatcherId textureTintFragmentProgramId;
+
+    SceUID patcherBufferUid;
+    SceUID patcherVertexUsseUid;
+    SceUID patcherFragmentUsseUid;
+
+    SceUID clearVerticesUid;
+    SceUID linearIndicesUid;
+    clear_vertex *clearVertices;
+    uint16_t *linearIndices;
+
+    blend_fragment_programs blendFragmentPrograms;
+
+    gxm_drawstate_cache drawstate;
+} VITA_GXM_RenderData;
+
+typedef struct
+{
+    gxm_texture  *tex;
+    unsigned int    pitch;
+    unsigned int    w;
+    unsigned int    h;
+} VITA_GXM_TextureData;
+
+#endif /* SDL_RENDER_VITA_GXM_TYPES_H */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/vitagxm/shader_src/clear_f.cg b/src/render/vitagxm/shader_src/clear_f.cg
new file mode 100644
index 000000000..6d8fb3b72
--- /dev/null
+++ b/src/render/vitagxm/shader_src/clear_f.cg
@@ -0,0 +1,4 @@
+float4 main( uniform float4 uClearColor) : COLOR
+{
+    return uClearColor;
+}
diff --git a/src/render/vitagxm/shader_src/clear_v.cg b/src/render/vitagxm/shader_src/clear_v.cg
new file mode 100644
index 000000000..ee5aa9fce
--- /dev/null
+++ b/src/render/vitagxm/shader_src/clear_v.cg
@@ -0,0 +1,4 @@
+float4 main(float2 aPosition) : POSITION
+{
+    return float4(aPosition, 1.f, 1.f);
+}
diff --git a/src/render/vitagxm/shader_src/color_f.cg b/src/render/vitagxm/shader_src/color_f.cg
new file mode 100644
index 000000000..dc87c2a11
--- /dev/null
+++ b/src/render/vitagxm/shader_src/color_f.cg
@@ -0,0 +1,4 @@
+float4 main(float4 vColor : COLOR)
+{
+    return vColor;
+}
diff --git a/src/render/vitagxm/shader_src/color_v.cg b/src/render/vitagxm/shader_src/color_v.cg
new file mode 100644
index 000000000..f60879783
--- /dev/null
+++ b/src/render/vitagxm/shader_src/color_v.cg
@@ -0,0 +1,11 @@
+void main(
+    float3 aPosition,
+    float4 aColor,
+    uniform float4x4 wvp,
+    float4 out vPosition : POSITION,
+    float4 out vColor : COLOR
+)
+{
+    vPosition = mul(float4(aPosition, 1.f), wvp);
+    vColor = aColor;
+}
diff --git a/src/render/vitagxm/shader_src/texture_f.cg b/src/render/vitagxm/shader_src/texture_f.cg
new file mode 100644
index 000000000..232ee8585
--- /dev/null
+++ b/src/render/vitagxm/shader_src/texture_f.cg
@@ -0,0 +1,4 @@
+float4 main(float2 vTexcoord : TEXCOORD0, uniform sampler2D tex)
+{
+    return tex2D(tex, vTexcoord);
+}
diff --git a/src/render/vitagxm/shader_src/texture_tint_f.cg b/src/render/vitagxm/shader_src/texture_tint_f.cg
new file mode 100644
index 000000000..8b12a8067
--- /dev/null
+++ b/src/render/vitagxm/shader_src/texture_tint_f.cg
@@ -0,0 +1,4 @@
+float4 main( float2 vTexcoord : TEXCOORD0, uniform sampler2D tex, uniform float4 uTintColor)
+{
+    return tex2D(tex, vTexcoord) * uTintColor;
+}
diff --git a/src/render/vitagxm/shader_src/texture_v.cg b/src/render/vitagxm/shader_src/texture_v.cg
new file mode 100644
index 000000000..42e7df9ca
--- /dev/null
+++ b/src/render/vitagxm/shader_src/texture_v.cg
@@ -0,0 +1,11 @@
+void main(
+    float3 aPosition,
+    float2 aTexcoord,
+    uniform float4x4 wvp,
+    float4 out vPosition : POSITION,
+    float2 out vTexcoord : TEXCOORD0
+)
+{
+    vPosition = mul(float4(aPosition, 1.f), wvp);
+    vTexcoord = aTexcoord;
+}
diff --git a/src/sensor/SDL_sensor.c b/src/sensor/SDL_sensor.c
index 68c3b1fc7..0b2bc086a 100644
--- a/src/sensor/SDL_sensor.c
+++ b/src/sensor/SDL_sensor.c
@@ -42,6 +42,9 @@ static SDL_SensorDriver *SDL_sensor_drivers[] = {
 #if defined(SDL_SENSOR_DUMMY) || defined(SDL_SENSOR_DISABLED)
     &SDL_DUMMY_SensorDriver
 #endif
+#if defined(SDL_SENSOR_VITA)
+    &SDL_VITA_SensorDriver
+#endif
 };
 static SDL_Sensor *SDL_sensors = NULL;
 static SDL_bool SDL_updating_sensor = SDL_FALSE;
diff --git a/src/sensor/SDL_syssensor.h b/src/sensor/SDL_syssensor.h
index 394c68b56..ae50bd2f4 100644
--- a/src/sensor/SDL_syssensor.h
+++ b/src/sensor/SDL_syssensor.h
@@ -99,6 +99,7 @@ typedef struct _SDL_SensorDriver
 extern SDL_SensorDriver SDL_ANDROID_SensorDriver;
 extern SDL_SensorDriver SDL_COREMOTION_SensorDriver;
 extern SDL_SensorDriver SDL_DUMMY_SensorDriver;
+extern SDL_SensorDriver SDL_VITA_SensorDriver;
 
 #endif /* SDL_syssensor_c_h_ */
 
diff --git a/src/sensor/vita/SDL_vitasensor.c b/src/sensor/vita/SDL_vitasensor.c
new file mode 100644
index 000000000..e54d279aa
--- /dev/null
+++ b/src/sensor/vita/SDL_vitasensor.c
@@ -0,0 +1,216 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "SDL_config.h"
+
+#if defined(SDL_SENSOR_VITA)
+
+#include "SDL_error.h"
+#include "SDL_sensor.h"
+#include "SDL_vitasensor.h"
+#include "../SDL_syssensor.h"
+#include <psp2/motion.h>
+#include <psp2/error.h>
+
+typedef struct
+{
+    SDL_SensorType type;
+    SDL_SensorID instance_id;
+} SDL_VitaSensor;
+
+static SDL_VitaSensor *SDL_sensors;
+static int SDL_sensors_count;
+
+static int
+SDL_VITA_SensorInit(void)
+{
+    sceMotionReset();
+    sceMotionStartSampling();
+    // not sure if these are needed, we are reading unfiltered state
+    sceMotionSetAngleThreshold(0);
+    sceMotionSetDeadband(SCE_FALSE);
+    sceMotionSetTiltCorrection(SCE_FALSE);
+
+    SDL_sensors_count = 2;
+
+    SDL_sensors = (SDL_VitaSensor *)SDL_calloc(SDL_sensors_count, sizeof(*SDL_sensors));
+    if (!SDL_sensors) {
+        return SDL_OutOfMemory();
+    }
+
+    SDL_sensors[0].type = SDL_SENSOR_ACCEL;
+    SDL_sensors[0].instance_id = SDL_GetNextSensorInstanceID();
+    SDL_sensors[1].type = SDL_SENSOR_GYRO;
+    SDL_sensors[1].instance_id = SDL_GetNextSensorInstanceID();
+
+    return 0;
+}
+
+static int
+SDL_VITA_SensorGetCount(void)
+{
+    return SDL_sensors_count;
+}
+
+static void
+SDL_VITA_SensorDetect(void)
+{
+}
+
+static const char *
+SDL_VITA_SensorGetDeviceName(int device_index)
+{
+    if (device_index < SDL_sensors_count) {
+        switch (SDL_sensors[device_index].type) {
+            case SDL_SENSOR_ACCEL:
+                return "Accelerometer";
+            case SDL_SENSOR_GYRO:
+                return "Gyro";
+            default:
+                return "Unknown";
+        }
+    }
+
+    return NULL;
+}
+
+static SDL_SensorType
+SDL_VITA_SensorGetDeviceType(int device_index)
+{
+    if (device_index < SDL_sensors_count) {
+        return SDL_sensors[device_index].type;
+    }
+
+    return SDL_SENSOR_INVALID;
+}
+
+static int
+SDL_VITA_SensorGetDeviceNonPortableType(int device_index)
+{
+    if (device_index < SDL_sensors_count) {
+        return SDL_sensors[device_index].type;
+    }
+    return -1;
+}
+
+static SDL_SensorID
+SDL_VITA_SensorGetDeviceInstanceID(int device_index)
+{
+    if (device_index < SDL_sensors_count) {
+        return SDL_sensors[device_index].instance_id;
+    }
+    return -1;
+}
+
+static int
+SDL_VITA_SensorOpen(SDL_Sensor *sensor, int device_index)
+{
+    struct sensor_hwdata *hwdata;
+
+    hwdata = (struct sensor_hwdata *)SDL_calloc(1, sizeof(*hwdata));
+    if (hwdata == NULL) {
+        return SDL_OutOfMemory();
+    }
+    sensor->hwdata = hwdata;
+
+    return 0;
+}
+
+static void
+SDL_VITA_SensorUpdate(SDL_Sensor *sensor)
+{
+    SceMotionSensorState motionState[SCE_MOTION_MAX_NUM_STATES];
+    SDL_memset(motionState, 0, sizeof(motionState));
+
+    int err = SCE_OK;
+    err = sceMotionGetSensorState(motionState, SCE_MOTION_MAX_NUM_STATES);
+    if (err != SCE_OK)
+    {
+        return;
+    }
+
+    for (int i = 0; i < SCE_MOTION_MAX_NUM_STATES; i++)
+    {
+        if (sensor->hwdata->counter < motionState[i].counter)
+        {
+            sensor->hwdata->counter = motionState[i].counter;
+            switch (sensor->type)
+            {
+                case SDL_SENSOR_ACCEL:
+                {
+                    float data[3];
+                    data[0] = motionState[i].accelerometer.x * SDL_STANDARD_GRAVITY;
+                    data[1] = motionState[i].accelerometer.y * SDL_STANDARD_GRAVITY;
+                    data[2] = motionState[i].accelerometer.z * SDL_STANDARD_GRAVITY;
+                    if (SDL_memcmp(data, sensor->hwdata->data, sizeof(data)) != 0) {
+                       SDL_PrivateSensorUpdate(sensor, data, SDL_arraysize(data));
+                       SDL_memcpy(sensor->hwdata->data, data, sizeof(data));
+                    }
+                }
+                break;
+                case SDL_SENSOR_GYRO:
+                {
+                    float data[3];
+                    data[0] = motionState[i].gyro.x;
+                    data[1] = motionState[i].gyro.y;
+                    data[2] = motionState[i].gyro.z;
+                    if (SDL_memcmp(data, sensor->hwdata->data, sizeof(data)) != 0) {
+                       SDL_PrivateSensorUpdate(sensor, data, SDL_arraysize(data));
+                       SDL_memcpy(sensor->hwdata->data, data, sizeof(data));
+                    }
+                }
+                break;
+                default:
+                break;
+            }
+        }
+    }
+}
+
+static void
+SDL_VITA_SensorClose(SDL_Sensor *sensor)
+{
+}
+
+static void
+SDL_VITA_SensorQuit(void)
+{
+    sceMotionStopSampling();
+}
+
+SDL_SensorDriver SDL_VITA_SensorDriver =
+{
+    SDL_VITA_SensorInit,
+    SDL_VITA_SensorGetCount,
+    SDL_VITA_SensorDetect,
+    SDL_VITA_SensorGetDeviceName,
+    SDL_VITA_SensorGetDeviceType,
+    SDL_VITA_SensorGetDeviceNonPortableType,
+    SDL_VITA_SensorGetDeviceInstanceID,
+    SDL_VITA_SensorOpen,
+    SDL_VITA_SensorUpdate,
+    SDL_VITA_SensorClose,
+    SDL_VITA_SensorQuit,
+};
+
+#endif /* SDL_SENSOR_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/sensor/vita/SDL_vitasensor.h b/src/sensor/vita/SDL_vitasensor.h
new file mode 100644
index 000000000..b10384231
--- /dev/null
+++ b/src/sensor/vita/SDL_vitasensor.h
@@ -0,0 +1,30 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "SDL_config.h"
+
+/* The private structure used to keep track of a sensor */
+struct sensor_hwdata
+{
+    float data[3];
+    Uint32 counter;
+};
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 9cc52af1a..0d8b434ac 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -34,6 +34,8 @@
 #include "windows/SDL_systhread_c.h"
 #elif SDL_THREAD_PSP
 #include "psp/SDL_systhread_c.h"
+#elif SDL_THREAD_VITA
+#include "vita/SDL_systhread_c.h"
 #elif SDL_THREAD_STDCPP
 #include "stdcpp/SDL_systhread_c.h"
 #else
diff --git a/src/thread/vita/SDL_syscond.c b/src/thread/vita/SDL_syscond.c
new file mode 100644
index 000000000..ad2391d02
--- /dev/null
+++ b/src/thread/vita/SDL_syscond.c
@@ -0,0 +1,224 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_VITA
+
+/* An implementation of condition variables using semaphores and mutexes */
+/*
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+ */
+
+#include "SDL_thread.h"
+
+struct SDL_cond
+{
+    SDL_mutex *lock;
+    int waiting;
+    int signals;
+    SDL_sem *wait_sem;
+    SDL_sem *wait_done;
+};
+
+/* Create a condition variable */
+SDL_cond *
+SDL_CreateCond(void)
+{
+    SDL_cond *cond;
+
+    cond = (SDL_cond *) SDL_malloc(sizeof(SDL_cond));
+    if (cond) {
+        cond->lock = SDL_CreateMutex();
+        cond->wait_sem = SDL_CreateSemaphore(0);
+        cond->wait_done = SDL_CreateSemaphore(0);
+        cond->waiting = cond->signals = 0;
+        if (!cond->lock || !cond->wait_sem || !cond->wait_done) {
+            SDL_DestroyCond(cond);
+            cond = NULL;
+        }
+    } else {
+        SDL_OutOfMemory();
+    }
+    return (cond);
+}
+
+/* Destroy a condition variable */
+void
+SDL_DestroyCond(SDL_cond * cond)
+{
+    if (cond) {
+        if (cond->wait_sem) {
+            SDL_DestroySemaphore(cond->wait_sem);
+        }
+        if (cond->wait_done) {
+            SDL_DestroySemaphore(cond->wait_done);
+        }
+        if (cond->lock) {
+            SDL_DestroyMutex(cond->lock);
+        }
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int
+SDL_CondSignal(SDL_cond * cond)
+{
+    if (!cond) {
+        return SDL_SetError("Passed a NULL condition variable");
+    }
+
+    /* If there are waiting threads not already signalled, then
+       signal the condition and wait for the thread to respond.
+     */
+    SDL_LockMutex(cond->lock);
+    if (cond->waiting > cond->signals) {
+        ++cond->signals;
+        SDL_SemPost(cond->wait_sem);
+        SDL_UnlockMutex(cond->lock);
+        SDL_SemWait(cond->wait_done);
+    } else {
+        SDL_UnlockMutex(cond->lock);
+    }
+
+    return 0;
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int
+SDL_CondBroadcast(SDL_cond * cond)
+{
+    if (!cond) {
+        return SDL_SetError("Passed a NULL condition variable");
+    }
+
+    /* If there are waiting threads not already signalled, then
+       signal the condition and wait for the thread to respond.
+     */
+    SDL_LockMutex(cond->lock);
+    if (cond->waiting > cond->signals) {
+        int i, num_waiting;
+
+        num_waiting = (cond->waiting - cond->signals);
+        cond->signals = cond->waiting;
+        for (i = 0; i < num_waiting; ++i) {
+            SDL_SemPost(cond->wait_sem);
+        }
+        /* Now all released threads are blocked here, waiting for us.
+           Collect them all (and win fabulous prizes!) :-)
+         */
+        SDL_UnlockMutex(cond->lock);
+        for (i = 0; i < num_waiting; ++i) {
+            SDL_SemWait(cond->wait_done);
+        }
+    } else {
+        SDL_UnlockMutex(cond->lock);
+    }
+
+    return 0;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+    SDL_LockMutex(lock);
+    while ( ! condition ) {
+        SDL_CondWait(cond, lock);
+    }
+    SDL_UnlockMutex(lock);
+
+Thread B:
+    SDL_LockMutex(lock);
+    ...
+    condition = true;
+    ...
+    SDL_CondSignal(cond);
+    SDL_UnlockMutex(lock);
+ */
+int
+SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
+{
+    int retval;
+
+    if (!cond) {
+        return SDL_SetError("Passed a NULL condition variable");
+    }
+
+    /* Obtain the protection mutex, and increment the number of waiters.
+       This allows the signal mechanism to only perform a signal if there
+       are waiting threads.
+     */
+    SDL_LockMutex(cond->lock);
+    ++cond->waiting;
+    SDL_UnlockMutex(cond->lock);
+
+    /* Unlock the mutex, as is required by condition variable semantics */
+    SDL_UnlockMutex(mutex);
+
+    /* Wait for a signal */
+    if (ms == SDL_MUTEX_MAXWAIT) {
+        retval = SDL_SemWait(cond->wait_sem);
+    } else {
+        retval = SDL_SemWaitTimeout(cond->wait_sem, ms);
+    }
+
+    /* Let the signaler know we have completed the wait, otherwise
+       the signaler can race ahead and get the condition semaphore
+       if we are stopped between the mutex unlock and semaphore wait,
+       giving a deadlock.  See the following URL for details:
+       http://www-classic.be.com/aboutbe/benewsletter/volume_III/Issue40.html
+     */
+    SDL_LockMutex(cond->lock);
+    if (cond->signals > 0) {
+        /* If we timed out, we need to eat a condition signal */
+        if (retval > 0) {
+            SDL_SemWait(cond->wait_sem);
+        }
+        /* We always notify the signal thread that we are done */
+        SDL_SemPost(cond->wait_done);
+
+        /* Signal handshake complete */
+        --cond->signals;
+    }
+    --cond->waiting;
+    SDL_UnlockMutex(cond->lock);
+
+    /* Lock the mutex, as is required by condition variable semantics */
+    SDL_LockMutex(mutex);
+
+    return retval;
+}
+
+/* Wait on the condition variable forever */
+int
+SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex)
+{
+    return SDL_CondWaitTimeout(cond, mutex, SDL_MUTEX_MAXWAIT);
+}
+
+#endif /* SDL_THREAD_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/vita/SDL_sysmutex.c b/src/thread/vita/SDL_sysmutex.c
new file mode 100644
index 000000000..6584fb2bf
--- /dev/null
+++ b/src/thread/vita/SDL_sysmutex.c
@@ -0,0 +1,136 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_VITA
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+
+struct SDL_mutex
+{
+    int recursive;
+    SDL_threadID owner;
+    SDL_sem *sem;
+};
+
+/* Create a mutex */
+SDL_mutex *
+SDL_CreateMutex(void)
+{
+    SDL_mutex *mutex;
+
+    /* Allocate mutex memory */
+    mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+    if (mutex) {
+        /* Create the mutex semaphore, with initial value 1 */
+        mutex->sem = SDL_CreateSemaphore(1);
+        mutex->recursive = 0;
+        mutex->owner = 0;
+        if (!mutex->sem) {
+            SDL_free(mutex);
+            mutex = NULL;
+        }
+    } else {
+        SDL_OutOfMemory();
+    }
+    return mutex;
+}
+
+/* Free the mutex */
+void
+SDL_DestroyMutex(SDL_mutex * mutex)
+{
+    if (mutex) {
+        if (mutex->sem) {
+            SDL_DestroySemaphore(mutex->sem);
+        }
+        SDL_free(mutex);
+    }
+}
+
+/* Lock the semaphore */
+int
+SDL_mutexP(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    SDL_threadID this_thread;
+
+    if (mutex == NULL) {
+        return SDL_SetError("Passed a NULL mutex");
+    }
+
+    this_thread = SDL_ThreadID();
+    if (mutex->owner == this_thread) {
+        ++mutex->recursive;
+    } else {
+        /* The order of operations is important.
+           We set the locking thread id after we obtain the lock
+           so unlocks from other threads will fail.
+         */
+        SDL_SemWait(mutex->sem);
+        mutex->owner = this_thread;
+        mutex->recursive = 0;
+    }
+
+    return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+/* Unlock the mutex */
+int
+SDL_mutexV(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL) {
+        return SDL_SetError("Passed a NULL mutex");
+    }
+
+    /* If we don't own the mutex, we can't unlock it */
+    if (SDL_ThreadID() != mutex->owner) {
+        return SDL_SetError("mutex not owned by this thread");
+    }
+
+    if (mutex->recursive) {
+        --mutex->recursive;
+    } else {
+        /* The order of operations is important.
+           First reset the owner so another thread doesn't lock
+           the mutex and set the ownership before we reset it,
+           then release the lock semaphore.
+         */
+        mutex->owner = 0;
+        SDL_SemPost(mutex->sem);
+    }
+    return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+#endif /* SDL_THREAD_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/vita/SDL_sysmutex_c.h b/src/thread/vita/SDL_sysmutex_c.h
new file mode 100644
index 000000000..7481b6656
--- /dev/null
+++ b/src/thread/vita/SDL_sysmutex_c.h
@@ -0,0 +1,22 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/vita/SDL_syssem.c b/src/thread/vita/SDL_syssem.c
new file mode 100644
index 000000000..073ba096c
--- /dev/null
+++ b/src/thread/vita/SDL_syssem.c
@@ -0,0 +1,163 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_VITA
+
+/* Semaphore functions for the VITA. */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+
+#include <psp2/types.h>
+#include <psp2/kernel/error.h>
+#include <psp2/kernel/threadmgr.h>
+
+struct SDL_semaphore {
+    SceUID  semid;
+};
+
+
+/* Create a semaphore */
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_sem *sem;
+
+    sem = (SDL_sem *) malloc(sizeof(*sem));
+    if (sem != NULL) {
+        /* TODO: Figure out the limit on the maximum value. */
+        sem->semid = sceKernelCreateSema("SDL sema", 0, initial_value, 255, NULL);
+        if (sem->semid < 0) {
+            SDL_SetError("Couldn't create semaphore");
+            free(sem);
+            sem = NULL;
+        }
+    } else {
+        SDL_OutOfMemory();
+    }
+
+    return sem;
+}
+
+/* Free the semaphore */
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+    if (sem != NULL) {
+        if (sem->semid > 0) {
+            sceKernelDeleteSema(sem->semid);
+            sem->semid = 0;
+        }
+
+        free(sem);
+    }
+}
+
+/* TODO: This routine is a bit overloaded.
+ * If the timeout is 0 then just poll the semaphore; if it's SDL_MUTEX_MAXWAIT, pass
+ * NULL to sceKernelWaitSema() so that it waits indefinitely; and if the timeout
+ * is specified, convert it to microseconds. */
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+    Uint32 *pTimeout;
+       unsigned int res;
+
+    if (sem == NULL) {
+        SDL_SetError("Passed a NULL sem");
+        return 0;
+    }
+
+    if (timeout == 0) {
+        res = sceKernelPollSema(sem->semid, 1);
+        if (res < 0) {
+            return SDL_MUTEX_TIMEDOUT;
+        }
+        return 0;
+    }
+
+    if (timeout == SDL_MUTEX_MAXWAIT) {
+        pTimeout = NULL;
+    } else {
+        timeout *= 1000;  /* Convert to microseconds. */
+        pTimeout = &timeout;
+    }
+
+    res = sceKernelWaitSema(sem->semid, 1, pTimeout);
+       switch (res) {
+               case SCE_KERNEL_OK:
+                       return 0;
+               case SCE_KERNEL_ERROR_WAIT_TIMEOUT:
+                       return SDL_MUTEX_TIMEDOUT;
+               default:
+                       return SDL_SetError("WaitForSingleObject() failed");
+    }
+}
+
+int SDL_SemTryWait(SDL_sem *sem)
+{
+    return SDL_SemWaitTimeout(sem, 0);
+}
+
+int SDL_SemWait(SDL_sem *sem)
+{
+    return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+/* Returns the current count of the semaphore */
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+    SceKernelSemaInfo info;
+	info.size = sizeof(info);
+
+    if (sem == NULL) {
+        SDL_SetError("Passed a NULL sem");
+        return 0;
+    }
+
+    if (sceKernelGetSemaInfo(sem->semid, &info) >= 0) {
+        return info.currentCount;
+    }
+
+    return 0;
+}
+
+int SDL_SemPost(SDL_sem *sem)
+{
+    int res;
+
+    if (sem == NULL) {
+        return SDL_SetError("Passed a NULL sem");
+    }
+
+    res = sceKernelSignalSema(sem->semid, 1);
+    if (res < 0) {
+        return SDL_SetError("sceKernelSignalSema() failed");
+    }
+
+    return 0;
+}
+
+#endif /* SDL_THREAD_VITA */
+
+/* vim: ts=4 sw=4
+ */
diff --git a/src/thread/vita/SDL_systhread.c b/src/thread/vita/SDL_systhread.c
new file mode 100644
index 000000000..d2375fd9c
--- /dev/null
+++ b/src/thread/vita/SDL_systhread.c
@@ -0,0 +1,112 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_VITA
+
+/* VITA thread management routines for SDL */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+#include "../SDL_thread_c.h"
+#include <psp2/types.h>
+#include <psp2/kernel/threadmgr.h>
+
+
+static int ThreadEntry(SceSize args, void *argp)
+{
+    SDL_RunThread(*(void **) argp);
+    return 0;
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
+{
+    SceKernelThreadInfo info;
+    int priority = 32;
+
+    /* Set priority of new thread to the same as the current thread */
+    info.size = sizeof(SceKernelThreadInfo);
+    if (sceKernelGetThreadInfo(sceKernelGetThreadId(), &info) == 0) {
+        priority = info.currentPriority;
+    }
+
+    thread->handle = sceKernelCreateThread("SDL thread", ThreadEntry,
+                           priority, 0x10000, 0, 0, NULL);
+
+    if (thread->handle < 0) {
+        return SDL_SetError("sceKernelCreateThread() failed");
+    }
+
+    sceKernelStartThread(thread->handle, 4, &args);
+    return 0;
+}
+
+void SDL_SYS_SetupThread(const char *name)
+{
+    /* Do nothing. */
+}
+
+SDL_threadID SDL_ThreadID(void)
+{
+    return (SDL_threadID) sceKernelGetThreadId();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+    sceKernelWaitThreadEnd(thread->handle, NULL, NULL);
+    sceKernelDeleteThread(thread->handle);
+}
+
+void SDL_SYS_DetachThread(SDL_Thread *thread)
+{
+    /* !!! FIXME: is this correct? */
+    sceKernelDeleteThread(thread->handle);
+}
+
+void SDL_SYS_KillThread(SDL_Thread *thread)
+{
+    sceKernelDeleteThread(thread->handle);
+}
+
+int SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+    int value;
+
+    if (priority == SDL_THREAD_PRIORITY_LOW) {
+        value = 19;
+    } else if (priority == SDL_THREAD_PRIORITY_HIGH) {
+        value = -20;
+    } else {
+        value = 0;
+    }
+
+    return sceKernelChangeThreadPriority(sceKernelGetThreadId(),value);
+
+}
+
+#endif /* SDL_THREAD_VITA */
+
+/* vim: ts=4 sw=4
+ */
diff --git a/src/thread/vita/SDL_systhread_c.h b/src/thread/vita/SDL_systhread_c.h
new file mode 100644
index 000000000..80bf49d17
--- /dev/null
+++ b/src/thread/vita/SDL_systhread_c.h
@@ -0,0 +1,24 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <psp2/types.h>
+
+typedef SceUID SYS_ThreadHandle;
diff --git a/src/timer/vita/SDL_systimer.c b/src/timer/vita/SDL_systimer.c
new file mode 100644
index 000000000..91902d9fc
--- /dev/null
+++ b/src/timer/vita/SDL_systimer.c
@@ -0,0 +1,91 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_TIMERS_VITA
+
+#include "SDL_thread.h"
+#include "SDL_timer.h"
+#include "SDL_error.h"
+#include "../SDL_timer_c.h"
+#include <stdlib.h>
+#include <time.h>
+#include <sys/time.h>
+#include <psp2/kernel/processmgr.h>
+
+static uint64_t start;
+static SDL_bool ticks_started = SDL_FALSE;
+
+void
+SDL_TicksInit(void)
+{
+    if (ticks_started) {
+        return;
+    }
+    ticks_started = SDL_TRUE;
+
+    start = sceKernelGetProcessTimeWide();
+}
+
+void
+SDL_TicksQuit(void)
+{
+    ticks_started = SDL_FALSE;
+}
+
+Uint32 SDL_GetTicks(void)
+{
+    if (!ticks_started) {
+        SDL_TicksInit();
+    }
+
+    uint64_t now;
+    Uint32 ticks;
+
+    now = sceKernelGetProcessTimeWide();
+    ticks = (now - start)/1000;
+    return (ticks);
+}
+
+Uint64
+SDL_GetPerformanceCounter(void)
+{
+    return sceKernelGetProcessTimeWide();
+}
+
+Uint64
+SDL_GetPerformanceFrequency(void)
+{
+    return 1000000;
+}
+
+void SDL_Delay(Uint32 ms)
+{
+    const Uint32 max_delay = 0xffffffffUL / 1000;
+    if(ms > max_delay)
+        ms = max_delay;
+    sceKernelDelayThreadCB(ms * 1000);
+}
+
+#endif /* SDL_TIMERS_VITA */
+
+/* vim: ts=4 sw=4
+ */
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index 38ed97157..ba757b015 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -421,6 +421,7 @@ extern VideoBootStrap PND_bootstrap;
 extern VideoBootStrap UIKIT_bootstrap;
 extern VideoBootStrap Android_bootstrap;
 extern VideoBootStrap PSP_bootstrap;
+extern VideoBootStrap VITA_bootstrap;
 extern VideoBootStrap RPI_bootstrap;
 extern VideoBootStrap KMSDRM_bootstrap;
 extern VideoBootStrap DUMMY_bootstrap;
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index de0bc1cbc..d5c8827af 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -94,6 +94,9 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_PSP
     &PSP_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_VITA
+    &VITA_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_KMSDRM
     &KMSDRM_bootstrap,
 #endif
diff --git a/src/video/vita/SDL_vitagl.c b/src/video/vita/SDL_vitagl.c
new file mode 100644
index 000000000..c457e0f22
--- /dev/null
+++ b/src/video/vita/SDL_vitagl.c
@@ -0,0 +1,214 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_VITA
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "SDL_error.h"
+#include "SDL_log.h"
+#include "SDL_vitavideo.h"
+#include "SDL_vitagl_c.h"
+
+/*****************************************************************************/
+/* SDL OpenGL/OpenGL ES functions                                            */
+/*****************************************************************************/
+#define EGLCHK(stmt)                            \
+    do {                                        \
+        EGLint err;                             \
+                                                \
+        stmt;                                   \
+        err = eglGetError();                    \
+        if (err != EGL_SUCCESS) {               \
+            SDL_SetError("EGL error %d", err);  \
+            return 0;                           \
+        }                                       \
+    } while (0)
+
+int
+VITA_GL_LoadLibrary(_THIS, const char *path)
+{
+  pibInit(PIB_SHACCCG | PIB_GET_PROC_ADDR_CORE);
+  return 0;
+}
+
+void *
+VITA_GL_GetProcAddress(_THIS, const char *proc)
+{
+    return eglGetProcAddress(proc);
+}
+
+void
+VITA_GL_UnloadLibrary(_THIS)
+{
+    eglTerminate(_this->gl_data->display);
+}
+
+static EGLint width = 960;
+static EGLint height = 544;
+
+SDL_GLContext
+VITA_GL_CreateContext(_THIS, SDL_Window * window)
+{
+
+    SDL_WindowData *wdata = (SDL_WindowData *) window->driverdata;
+
+    EGLint attribs[32];
+    EGLDisplay display;
+    EGLContext context;
+    EGLSurface surface;
+    EGLConfig config;
+    EGLint num_configs;
+    int i;
+
+    EGLCHK(display = eglGetDisplay(0));
+
+    EGLCHK(eglInitialize(display, NULL, NULL));
+    wdata->uses_gles = SDL_TRUE;
+    window->flags |= SDL_WINDOW_FULLSCREEN;
+
+    EGLCHK(eglBindAPI(EGL_OPENGL_ES_API));
+
+    i = 0;
+    attribs[i++] = EGL_RED_SIZE;
+    attribs[i++] = 8;
+    attribs[i++] = EGL_GREEN_SIZE;
+    attribs[i++] = 8;
+    attribs[i++] = EGL_BLUE_SIZE;
+    attribs[i++] = 8;
+    attribs[i++] = EGL_DEPTH_SIZE;
+    attribs[i++] = 0;
+    attribs[i++] = EGL_ALPHA_SIZE;
+    attribs[i++] = 8;
+    attribs[i++] = EGL_STENCIL_SIZE;
+    attribs[i++] = 0;;
+
+    attribs[i++] = EGL_SURFACE_TYPE;
+    attribs[i++] = 5;
+
+    attribs[i++] = EGL_RENDERABLE_TYPE;
+    attribs[i++] = EGL_OPENGL_ES2_BIT;
+
+    attribs[i++] = EGL_CONFORMANT;
+    attribs[i++] = EGL_OPENGL_ES2_BIT;
+
+    attribs[i++] = EGL_NONE;
+
+    EGLCHK(eglChooseConfig(display, attribs, &config, 1, &num_configs));
+
+    if (num_configs == 0)
+    {
+        SDL_SetError("No valid EGL configs for requested mode");
+        return 0;
+    }
+
+    const EGLint contextAttribs[] = {
+        EGL_CONTEXT_CLIENT_VERSION, 2,
+        EGL_NONE
+    };
+
+    EGLCHK(surface = eglCreateWindowSurface(display, config, VITA_WINDOW_960X544, NULL));
+
+    EGLCHK(context = eglCreateContext(display, config, EGL_NO_CONTEXT, contextAttribs));
+
+    EGLCHK(eglMakeCurrent(display, surface, surface, context));
+
+    EGLCHK(eglQuerySurface(display, surface, EGL_WIDTH, &width));
+    EGLCHK(eglQuerySurface(display, surface, EGL_HEIGHT, &height));
+
+    _this->gl_data->display = display;
+    _this->gl_data->context = context;
+    _this->gl_data->surface = surface;
+
+    return context;
+}
+
+int
+VITA_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context)
+{
+        if (!eglMakeCurrent(_this->gl_data->display, _this->gl_data->surface,
+                          _this->gl_data->surface, _this->gl_data->context))
+        {
+            return SDL_SetError("Unable to make EGL context current");
+        }
+    return 0;
+}
+
+int
+VITA_GL_SetSwapInterval(_THIS, int interval)
+{
+    EGLBoolean status;
+    status = eglSwapInterval(_this->gl_data->display, interval);
+    if (status == EGL_TRUE) {
+        /* Return success to upper level */
+        _this->gl_data->swapinterval = interval;
+        return 0;
+    }
+    /* Failed to set swap interval */
+    return SDL_SetError("Unable to set the EGL swap interval");
+}
+
+int
+VITA_GL_GetSwapInterval(_THIS)
+{
+    return _this->gl_data->swapinterval;
+}
+
+int
+VITA_GL_SwapWindow(_THIS, SDL_Window * window)
+{
+    if (!eglSwapBuffers(_this->gl_data->display, _this->gl_data->surface)) {
+        return SDL_SetError("eglSwapBuffers() failed");
+    }
+    return 0;
+}
+
+void
+VITA_GL_DeleteContext(_THIS, SDL_GLContext context)
+{
+    SDL_VideoData *phdata = (SDL_VideoData *) _this->driverdata;
+    EGLBoolean status;
+
+    if (phdata->egl_initialized != SDL_TRUE) {
+        SDL_SetError("VITA: GLES initialization failed, no OpenGL ES support");
+        return;
+    }
+
+    /* Check if OpenGL ES connection has been initialized */
+    if (_this->gl_data->display != EGL_NO_DISPLAY) {
+        if (context != EGL_NO_CONTEXT) {
+            status = eglDestroyContext(_this->gl_data->display, context);
+            if (status != EGL_TRUE) {
+                /* Error during OpenGL ES context destroying */
+                SDL_SetError("VITA: OpenGL ES context destroy error");
+                return;
+            }
+        }
+    }
+
+    return;
+}
+
+#endif /* SDL_VIDEO_DRIVER_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/vita/SDL_vitagl_c.h b/src/video/vita/SDL_vitagl_c.h
new file mode 100644
index 000000000..61d44e412
--- /dev/null
+++ b/src/video/vita/SDL_vitagl_c.h
@@ -0,0 +1,56 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_vitagl_c_h_
+#define SDL_vitagl_c_h_
+
+
+#include <pib.h>
+#include <EGL/egl.h>
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+
+#include "SDL_vitavideo.h"
+
+
+typedef struct SDL_GLDriverData {
+        EGLDisplay display;
+        EGLContext context;
+        EGLSurface surface;
+    uint32_t swapinterval;
+}SDL_GLDriverData;
+
+extern void * VITA_GL_GetProcAddress(_THIS, const char *proc);
+extern int VITA_GL_MakeCurrent(_THIS,SDL_Window * window, SDL_GLContext context);
+extern void VITA_GL_SwapBuffers(_THIS);
+
+extern int VITA_GL_SwapWindow(_THIS, SDL_Window * window);
+extern SDL_GLContext VITA_GL_CreateContext(_THIS, SDL_Window * window);
+
+extern int VITA_GL_LoadLibrary(_THIS, const char *path);
+extern void VITA_GL_UnloadLibrary(_THIS);
+extern int VITA_GL_SetSwapInterval(_THIS, int interval);
+extern int VITA_GL_GetSwapInterval(_THIS);
+
+
+#endif /* SDL_vitagl_c_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/vita/SDL_vitakeyboard.c b/src/video/vita/SDL_vitakeyboard.c
new file mode 100644
index 000000000..efa407f03
--- /dev/null
+++ b/src/video/vita/SDL_vitakeyboard.c
@@ -0,0 +1,198 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_VITA
+
+#include <psp2/kernel/processmgr.h>
+#include <psp2/ctrl.h>
+#include <psp2/hid.h>
+
+#include "SDL_events.h"
+#include "SDL_log.h"
+#include "SDL_vitavideo.h"
+#include "SDL_vitakeyboard.h"
+#include "../../events/SDL_keyboard_c.h"
+
+SceHidKeyboardReport k_reports[SCE_HID_MAX_REPORT];
+int keyboard_hid_handle = 0;
+Uint8 prev_keys[6] = {0};
+Uint8 prev_modifiers = 0;
+Uint8 locks = 0;
+Uint8 lock_key_down = 0;
+
+void 
+VITA_InitKeyboard(void)
+{
+	sceHidKeyboardEnumerate(&keyboard_hid_handle, 1);
+}
+
+void 
+VITA_PollKeyboard(void)
+{
+	// We skip polling keyboard if no window is created
+	if (Vita_Window == NULL)
+		return;
+
+	if (keyboard_hid_handle > 0)
+	{
+		int numReports = sceHidKeyboardRead(keyboard_hid_handle, (SceHidKeyboardReport**)&k_reports, SCE_HID_MAX_REPORT);
+
+		if (numReports < 0) {
+			keyboard_hid_handle = 0;
+		}
+		else if (numReports) {
+			// Numlock and Capslock state changes only on a SDL_PRESSED event
+			// The k_report only reports the state of the LED
+			if (k_reports[numReports - 1].modifiers[1] & 0x1) {
+				if (!(locks & 0x1)) {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_NUMLOCKCLEAR);
+					locks |= 0x1;
+				}
+			}
+			else {
+				if (locks & 0x1) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_NUMLOCKCLEAR);
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_NUMLOCKCLEAR);
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_NUMLOCKCLEAR);
+					locks &= ~0x1;
+				}
+			}
+
+			if (k_reports[numReports - 1].modifiers[1] & 0x2) {
+				if (!(locks & 0x2)) {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_CAPSLOCK);
+					locks |= 0x2;
+				}
+			}
+			else {
+				if (locks & 0x2) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_CAPSLOCK);
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_CAPSLOCK);
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_CAPSLOCK);
+					locks &= ~0x2;
+				}
+			}
+
+			if (k_reports[numReports - 1].modifiers[1] & 0x4) {
+				if (!(locks & 0x4)) {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_SCROLLLOCK);
+					locks |= 0x4;
+				}
+			}
+			else {
+				if (locks & 0x4) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_SCROLLLOCK);
+					locks &= ~0x4;
+				}
+			}
+
+			Uint8 changed_modifiers = k_reports[numReports - 1].modifiers[0] ^ prev_modifiers;
+
+			if (changed_modifiers & 0x01) {
+				if (prev_modifiers & 0x01) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_LCTRL);
+				}
+				else {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_LCTRL);
+				}
+			}
+			if (changed_modifiers & 0x02) {
+				if (prev_modifiers & 0x02) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_LSHIFT);
+				}
+				else {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_LSHIFT);
+				}
+			}
+			if (changed_modifiers & 0x04) {
+				if (prev_modifiers & 0x04) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_LALT);
+				}
+				else {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_LALT);
+				}
+			}
+			if (changed_modifiers & 0x08) {
+				if (prev_modifiers & 0x08) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_LGUI);
+				}
+				else {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_LGUI);
+				}
+			}
+			if (changed_modifiers & 0x10) {
+				if (prev_modifiers & 0x10) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_RCTRL);
+				}
+				else {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_RCTRL);
+				}
+			}
+			if (changed_modifiers & 0x20) {
+				if (prev_modifiers & 0x20) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_RSHIFT);
+				}
+				else {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_RSHIFT);
+				}
+			}
+			if (changed_modifiers & 0x40) {
+				if (prev_modifiers & 0x40) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_RALT);
+				}
+				else {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_RALT);
+				}
+			}
+			if (changed_modifiers & 0x80) {
+				if (prev_modifiers & 0x80) {
+					SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_RGUI);
+				}
+				else {
+					SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_RGUI);
+				}
+			}
+
+			prev_modifiers = k_reports[numReports - 1].modifiers[0];
+
+			for (int i = 0; i < 6; i++) {
+
+				int keyCode = k_reports[numReports - 1].keycodes[i];
+
+				if (keyCode != prev_keys[i]) {
+
+					if (prev_keys[i]) {
+						SDL_SendKeyboardKey(SDL_RELEASED, prev_keys[i]);
+					}
+					if (keyCode) {
+						SDL_SendKeyboardKey(SDL_PRESSED, keyCode);
+					}
+					prev_keys[i] = keyCode;
+				}
+			}
+		}
+	}
+}
+
+#endif /* SDL_VIDEO_DRIVER_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/vita/SDL_vitakeyboard.h b/src/video/vita/SDL_vitakeyboard.h
new file mode 100644
index 000000000..b0ff5ffde
--- /dev/null
+++ b/src/video/vita/SDL_vitakeyboard.h
@@ -0,0 +1,33 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_vitakeyboard_h
+#define _SDL_vitakeyboard_h
+
+#include "../../SDL_internal.h"
+
+/* Keyboard functions */
+extern void VITA_InitKeyboard(void);
+extern void VITA_PollKeyboard(void);
+
+#endif /* _SDL_vitakeyboard_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/vita/SDL_vitamouse.c b/src/video/vita/SDL_vitamouse.c
new file mode 100644
index 000000000..d5af6bf23
--- /dev/null
+++ b/src/video/vita/SDL_vitamouse.c
@@ -0,0 +1,94 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_VITA
+
+#include <psp2/kernel/processmgr.h>
+#include <psp2/ctrl.h>
+#include <psp2/hid.h>
+
+#include "SDL_events.h"
+#include "SDL_log.h"
+#include "SDL_mouse.h"
+#include "SDL_vitavideo.h"
+#include "SDL_vitamouse_c.h"
+#include "../../events/SDL_mouse_c.h"
+
+SceHidMouseReport m_reports[SCE_HID_MAX_REPORT];
+int mouse_hid_handle = 0;
+Uint8 prev_buttons = 0;
+
+void 
+VITA_InitMouse(void)
+{
+	sceHidMouseEnumerate(&mouse_hid_handle, 1);
+}
+
+void 
+VITA_PollMouse(void)
+{
+	// We skip polling mouse if no window is created
+	if (Vita_Window == NULL)
+		return;
+
+	if (mouse_hid_handle > 0)
+	{
+		int numReports = sceHidMouseRead(mouse_hid_handle, (SceHidMouseReport**)&m_reports, SCE_HID_MAX_REPORT);
+		if (numReports > 0)
+		{	
+			for (int i = 0; i <= numReports - 1; i++)
+			{
+				Uint8 changed_buttons = m_reports[i].buttons ^ prev_buttons;
+
+				if (changed_buttons & 0x1) {
+					if (prev_buttons & 0x1)
+						SDL_SendMouseButton(Vita_Window, 0, SDL_RELEASED, SDL_BUTTON_LEFT);
+					else
+						SDL_SendMouseButton(Vita_Window, 0, SDL_PRESSED, SDL_BUTTON_LEFT);
+				}
+				if (changed_buttons & 0x2) {
+					if (prev_buttons & 0x2)
+						SDL_SendMouseButton(Vita_Window, 0, SDL_RELEASED, SDL_BUTTON_RIGHT);
+					else
+						SDL_SendMouseButton(Vita_Window, 0, SDL_PRESSED, SDL_BUTTON_RIGHT);
+				}
+				if (changed_buttons & 0x4) {
+					if (prev_buttons & 0x4)
+						SDL_SendMouseButton(Vita_Window, 0, SDL_RELEASED, SDL_BUTTON_MIDDLE);
+					else
+						SDL_SendMouseButton(Vita_Window, 0, SDL_PRESSED, SDL_BUTTON_MIDDLE);
+				}
+
+				prev_buttons = m_reports[i].buttons;
+
+				if (m_reports[i].rel_x || m_reports[i].rel_y)
+				{
+					SDL_SendMouseMotion(Vita_Window, 0, 1, m_reports[i].rel_x, m_reports[i].rel_y);
+				}
+			}
+		}
+	}
+}
+
+#endif /* SDL_VIDEO_DRIVER_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/vita/SDL_vitamouse_c.h b/src/video/vita/SDL_vitamouse_c.h
new file mode 100644
index 000000000..ea8648c17
--- /dev/null
+++ b/src/video/vita/SDL_vitamouse_c.h
@@ -0,0 +1,33 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_vitamouse_h
+#define _SDL_vitamouse_h
+
+#include "../../SDL_internal.h"
+
+/* mouse functions */
+extern void VITA_InitMouse(void);
+extern void VITA_PollMouse(void);
+
+#endif /* _SDL_vitamouse_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/vita/SDL_vitatouch.c b/src/video/vita/SDL_vitatouch.c
new file mode 100644
index 000000000..5913db5b0
--- /dev/null
+++ b/src/video/vita/SDL_vitatouch.c
@@ -0,0 +1,171 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_VITA
+
+#include <psp2/kernel/processmgr.h>
+#include <psp2/touch.h>
+
+#include "SDL_events.h"
+#include "SDL_log.h"
+#include "SDL_vitavideo.h"
+#include "SDL_vitatouch.h"
+#include "../../events/SDL_mouse_c.h"
+#include "../../events/SDL_touch_c.h"
+
+SceTouchData touch_old[SCE_TOUCH_PORT_MAX_NUM];
+SceTouchData touch[SCE_TOUCH_PORT_MAX_NUM];
+
+SDL_FRect area_info[SCE_TOUCH_PORT_MAX_NUM];
+
+struct{
+    float min;
+    float range;
+} force_info[SCE_TOUCH_PORT_MAX_NUM];
+
+void 
+VITA_InitTouch(void)
+{
+	sceTouchSetSamplingState(SCE_TOUCH_PORT_FRONT, SCE_TOUCH_SAMPLING_STATE_START);
+	sceTouchSetSamplingState(SCE_TOUCH_PORT_BACK, SCE_TOUCH_SAMPLING_STATE_START);
+	sceTouchEnableTouchForce(SCE_TOUCH_PORT_FRONT);
+	sceTouchEnableTouchForce(SCE_TOUCH_PORT_BACK);
+
+	for(int port = 0; port < SCE_TOUCH_PORT_MAX_NUM; port++) {
+		SceTouchPanelInfo panelinfo;
+		sceTouchGetPanelInfo(port, &panelinfo);
+
+		area_info[port].x  = (float)panelinfo.minAaX;
+		area_info[port].y  = (float)panelinfo.minAaY;
+		area_info[port].w  = (float)(panelinfo.maxAaX - panelinfo.minAaX);
+		area_info[port].h  = (float)(panelinfo.maxAaY - panelinfo.minAaY);
+
+		force_info[port].min = (float)panelinfo.minForce;
+		force_info[port].range = (float)(panelinfo.maxForce - panelinfo.minForce);
+	}
+
+	// Support passing both front and back touch devices in events
+	SDL_AddTouch((SDL_TouchID)0, SDL_TOUCH_DEVICE_DIRECT, "Front");
+	SDL_AddTouch((SDL_TouchID)1, SDL_TOUCH_DEVICE_DIRECT,  "Back");
+}
+
+void 
+VITA_QuitTouch(void){
+	sceTouchDisableTouchForce(SCE_TOUCH_PORT_FRONT);
+	sceTouchDisableTouchForce(SCE_TOUCH_PORT_BACK);
+}
+
+void 
+VITA_PollTouch(void)
+{
+	// We skip polling touch if no window is created
+	if (Vita_Window == NULL)
+		return;
+
+	SDL_FingerID finger_id = 0;
+	int port;
+
+	memcpy(touch_old, touch, sizeof(touch_old));
+
+	for(port = 0; port < SCE_TOUCH_PORT_MAX_NUM; port++) {
+		sceTouchPeek(port, &touch[port], 1);
+		if (touch[port].reportNum > 0) {
+			for (int i = 0; i < touch[port].reportNum; i++)
+			{
+				// adjust coordinates and forces to return normalized values
+				// for the front, screen area is used as a reference (for direct touch)
+				// e.g. touch_x = 1.0 corresponds to screen_x = 960
+				// for the back panel, the active touch area is used as reference
+				float x = 0;
+				float y = 0;
+				VITA_ConvertTouchXYToSDLXY(&x, &y, touch[port].report[i].x, touch[port].report[i].y, port);
+				float force = (touch[port].report[i].force - force_info[port].min) / force_info[port].range;
+				finger_id = (SDL_FingerID) touch[port].report[i].id;
+
+				// Send an initial touch
+				SDL_SendTouch((SDL_TouchID)port,
+					finger_id,
+					Vita_Window,
+					SDL_TRUE,
+					x,
+					y,
+					force);
+
+				// Always send the motion
+				SDL_SendTouchMotion((SDL_TouchID)port,
+					finger_id,
+					Vita_Window,
+					x,
+					y,
+					force);
+			}
+		}
+
+		// some fingers might have been let go
+		if (touch_old[port].reportNum > 0) {
+			for (int i = 0; i < touch_old[port].reportNum; i++) {
+				int finger_up = 1;
+				if (touch[port].reportNum > 0) {
+					for (int j = 0; j < touch[port].reportNum; j++) {
+						if (touch[port].report[j].id == touch_old[port].report[i].id ) {
+							finger_up = 0;
+						}
+					}
+				}
+				if (finger_up == 1) {
+					float x = 0;
+					float y = 0;
+					VITA_ConvertTouchXYToSDLXY(&x, &y, touch_old[port].report[i].x, touch_old[port].report[i].y, port);
+					float force = (touch_old[port].report[i].force - force_info[port].min) / force_info[port].range;
+					finger_id = (SDL_FingerID) touch_old[port].report[i].id;
+					// Finger released from screen
+					SDL_SendTouch((SDL_TouchID)port,
+						finger_id,
+						Vita_Window,
+						SDL_FALSE,
+						x,
+						y,
+						force);
+				}
+			}
+		}
+	}
+}
+
+void VITA_ConvertTouchXYToSDLXY(float *sdl_x, float *sdl_y, int vita_x, int vita_y, int port) {
+	float x = (vita_x - area_info[port].x) / area_info[port].w;
+	float y = (vita_y - area_info[port].y) / area_info[port].h;
+
+	x = SDL_max(x, 0.0);
+	x = SDL_min(x, 1.0);
+
+	y = SDL_max(y, 0.0);
+	y = SDL_min(y, 1.0);
+
+	*sdl_x = x;
+	*sdl_y = y;
+}
+
+
+#endif /* SDL_VIDEO_DRIVER_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/vita/SDL_vitatouch.h b/src/video/vita/SDL_vitatouch.h
new file mode 100644
index 000000000..1de0dea08
--- /dev/null
+++ b/src/video/vita/SDL_vitatouch.h
@@ -0,0 +1,35 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_vitatouch_h
+#define _SDL_vitatouch_h
+
+#include "../../SDL_internal.h"
+
+/* Touch functions */
+extern void VITA_InitTouch(void);
+extern void VITA_QuitTouch(void);
+extern void VITA_PollTouch(void);
+void VITA_ConvertTouchXYToSDLXY(float *sdl_x, float *sdl_y, int vita_x, int vita_y, int port);
+
+#endif /* _SDL_vitatouch_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/vita/SDL_vitavideo.c b/src/video/vita/SDL_vitavideo.c
new file mode 100644
index 000000000..e639305fc
--- /dev/null
+++ b/src/video/vita/SDL_vitavideo.c
@@ -0,0 +1,437 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_VITA
+
+/* SDL internals */
+#include "../SDL_sysvideo.h"
+#include "SDL_version.h"
+#include "SDL_syswm.h"
+#include "SDL_loadso.h"
+#include "SDL_events.h"
+#include "../../events/SDL_mouse_c.h"
+#include "../../events/SDL_keyboard_c.h"
+
+/* VITA declarations */
+#include "SDL_vitavideo.h"
+#include "SDL_vitatouch.h"
+#include "SDL_vitakeyboard.h"
+#include "SDL_vitamouse_c.h"
+#include "SDL_vitagl_c.h"
+
+#include <psp2/ime_dialog.h>
+
+SDL_Window *Vita_Window;
+
+static int
+VITA_Available(void)
+{
+    return 1;
+}
+
+static void
+VITA_Destroy(SDL_VideoDevice * device)
+{
+/*    SDL_VideoData *phdata = (SDL_VideoData *) device->driverdata; */
+
+    SDL_free(device->driverdata);
+    SDL_free(device);
+//    if (device->driverdata != NULL) {
+//        device->driverdata = NULL;
+//    }
+}
+
+static SDL_VideoDevice *
+VITA_Create()
+{
+    SDL_VideoDevice *device;
+    SDL_VideoData *phdata;
+    SDL_GLDriverData *gldata;
+
+    /* Initialize SDL_VideoDevice structure */
+    device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
+    if (device == NULL) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    /* Initialize internal VITA specific data */
+    phdata = (SDL_VideoData *) SDL_calloc(1, sizeof(SDL_VideoData));
+    if (phdata == NULL) {
+        SDL_OutOfMemory();
+        SDL_free(device);
+        return NULL;
+    }
+
+    gldata = (SDL_GLDriverData *) SDL_calloc(1, sizeof(SDL_GLDriverData));
+    if (gldata == NULL) {
+        SDL_OutOfMemory();
+        SDL_free(device);
+        SDL_free(phdata);
+        return NULL;
+    }
+    device->gl_data = gldata;
+    phdata->egl_initialized = SDL_TRUE;
+    phdata->ime_active = SDL_FALSE;
+
+    device->driverdata = phdata;
+
+    /* Setup amount of available displays and current display */
+    device->num_displays = 0;
+
+    /* Set device free function */
+    device->free = VITA_Destroy;
+
+    /* Setup all functions which we can handle */
+    device->VideoInit = VITA_VideoInit;
+    device->VideoQuit = VITA_VideoQuit;
+    device->GetDisplayModes = VITA_GetDisplayModes;
+    device->SetDisplayMode = VITA_SetDisplayMode;
+    device->CreateSDLWindow = VITA_CreateWindow;
+    device->CreateSDLWindowFrom = VITA_CreateWindowFrom;
+    device->SetWindowTitle = VITA_SetWindowTitle;
+    device->SetWindowIcon = VITA_SetWindowIcon;
+    device->SetWindowPosition = VITA_SetWindowPosition;
+    device->SetWindowSize = VITA_SetWindowSize;
+    device->ShowWindow = VITA_ShowWindow;
+    device->HideWindow = VITA_HideWindow;
+    device->RaiseWindow = VITA_RaiseWindow;
+    device->MaximizeWindow = VITA_MaximizeWindow;
+    device->MinimizeWindow = VITA_MinimizeWindow;
+    device->RestoreWindow = VITA_RestoreWindow;
+    device->SetWindowGrab = VITA_SetWindowGrab;
+    device->DestroyWindow = VITA_DestroyWindow;
+    device->GetWindowWMInfo = VITA_GetWindowWMInfo;
+
+    device->GL_LoadLibrary = VITA_GL_LoadLibrary;
+    device->GL_GetProcAddress = VITA_GL_GetProcAddress;
+    device->GL_UnloadLibrary = VITA_GL_UnloadLibrary;
+    device->GL_CreateContext = VITA_GL_CreateContext;
+    device->GL_MakeCurrent = VITA_GL_MakeCurrent;
+    device->GL_SetSwapInterval = VITA_GL_SetSwapInterval;
+    device->GL_GetSwapInterval = VITA_GL_GetSwapInterval;
+    device->GL_SwapWindow = VITA_GL_SwapWindow;
+    device->GL_DeleteContext = VITA_GL_DeleteContext;
+
+    device->HasScreenKeyboardSupport = VITA_HasScreenKeyboardSupport;
+    device->ShowScreenKeyboard = VITA_ShowScreenKeyboard;
+    device->HideScreenKeyboard = VITA_HideScreenKeyboard;
+    device->IsScreenKeyboardShown = VITA_IsScreenKeyboardShown;
+
+    device->PumpEvents = VITA_PumpEvents;
+
+    return device;
+}
+
+VideoBootStrap VITA_bootstrap = {
+    "VITA",
+    "VITA Video Driver",
+    VITA_Available,
+    VITA_Create
+};
+
+/*****************************************************************************/
+/* SDL Video and Display initialization/handling functions                   */
+/*****************************************************************************/
+int
+VITA_VideoInit(_THIS)
+{
+    SDL_VideoDisplay display;
+    SDL_DisplayMode current_mode;
+
+    SDL_zero(current_mode);
+
+    current_mode.w = 960;
+    current_mode.h = 544;
+
+    current_mode.refresh_rate = 60;
+    /* 32 bpp for default */
+    current_mode.format = SDL_PIXELFORMAT_ABGR8888;
+
+    current_mode.driverdata = NULL;
+
+    SDL_zero(display);
+    display.desktop_mode = current_mode;
+    display.current_mode = current_mode;
+    display.driverdata = NULL;
+
+    SDL_AddVideoDisplay(&display);
+    VITA_InitTouch();
+    VITA_InitKeyboard();
+    VITA_InitMouse();
+
+    return 1;
+}
+
+void
+VITA_VideoQuit(_THIS)
+{
+    VITA_QuitTouch();
+}
+
+void
+VITA_GetDisplayModes(_THIS, SDL_VideoDisplay * display)
+{
+
+}
+
+int
+VITA_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode)
+{
+    return 0;
+}
+
+int
+VITA_CreateWindow(_THIS, SDL_Window * window)
+{
+    SDL_WindowData *wdata;
+
+    /* Allocate window internal data */
+    wdata = (SDL_WindowData *) SDL_calloc(1, sizeof(SDL_WindowData));
+    if (wdata == NULL) {
+        return SDL_OutOfMemory();
+    }
+
+    /* Setup driver data for this window */
+    window->driverdata = wdata;
+
+    // Vita can only have one window
+    if (Vita_Window != NULL)
+    {
+        SDL_SetError("Only one window supported");
+        return -1;
+    }
+
+    Vita_Window = window;
+
+    // fix input, we need to find a better way
+    SDL_SetKeyboardFocus(window);
+
+    /* Window has been successfully created */
+    return 0;
+}
+
+int
+VITA_CreateWindowFrom(_THIS, SDL_Window * window, const void *data)
+{
+    return -1;
+}
+
+void
+VITA_SetWindowTitle(_THIS, SDL_Window * window)
+{
+}
+void
+VITA_SetWindowIcon(_THIS, SDL_Window * window, SDL_Surface * icon)
+{
+}
+void
+VITA_SetWindowPosition(_THIS, SDL_Window * window)
+{
+}
+void
+VITA_SetWindowSize(_THIS, SDL_Window * window)
+{
+}
+void
+VITA_ShowWindow(_THIS, SDL_Window * window)
+{
+}
+void
+VITA_HideWindow(_THIS, SDL_Window * window)
+{
+}
+void
+VITA_RaiseWindow(_THIS, SDL_Window * window)
+{
+}
+void
+VITA_MaximizeWindow(_THIS, SDL_Window * window)
+{
+}
+void
+VITA_MinimizeWindow(_THIS, SDL_Window * window)
+{
+}
+void
+VITA_RestoreWindow(_THIS, SDL_Window * window)
+{
+}
+void
+VITA_SetWindowGrab(_THIS, SDL_Window * window, SDL_bool grabbed)
+{
+
+}
+void
+VITA_DestroyWindow(_THIS, SDL_Window * window)
+{
+//    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+    SDL_WindowData *data;
+
+    data = window->driverdata;
+    if (data) {
+        // TODO: should we destroy egl context? No one sane should recreate ogl window as non-ogl
+        SDL_free(data);
+    }
+
+    window->driverdata = NULL;
+    Vita_Window = NULL;
+}
+
+/*****************************************************************************/
+/* SDL Window Manager function                                               */
+/*****************************************************************************/
+SDL_bool
+VITA_GetWindowWMInfo(_THIS, SDL_Window * window, struct SDL_SysWMinfo *info)
+{
+    if (info->version.major <= SDL_MAJOR_VERSION) {
+        return SDL_TRUE;
+    } else {
+        SDL_SetError("application not compiled with SDL %d.%d\n",
+                     SDL_MAJOR_VERSION, SDL_MINOR_VERSION);
+        return SDL_FALSE;
+    }
+
+    /* Failed to get window manager information */
+    return SDL_FALSE;
+}
+
+SDL_bool VITA_HasScreenKeyboardSupport(_THIS)
+{
+    return SDL_TRUE;
+}
+
+void VITA_ShowScreenKeyboard(_THIS, SDL_Window *window)
+{
+    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+
+    wchar_t *title = L"";
+    wchar_t *text = L"";
+
+    SceImeDialogParam param;
+    sceImeDialogParamInit(&param);
+
+    param.supportedLanguages = SCE_IME_LANGUAGE_ENGLISH_US;
+    param.languagesForced = SCE_FALSE;
+    param.type = SCE_IME_TYPE_DEFAULT;
+    param.option = 0;
+    param.textBoxMode = SCE_IME_DIALOG_TEXTBOX_MODE_WITH_CLEAR;
+    param.maxTextLength = SCE_IME_DIALOG_MAX_TEXT_LENGTH;
+
+    param.title = title;
+    param.initialText = text;
+    param.inputTextBuffer = videodata->ime_buffer;
+
+    SceInt32 res = sceImeDialogInit(&param);
+    if (res < 0) {
+        SDL_SetError("Failed to init IME dialog");
+        return;
+    }
+
+    videodata->ime_active = SDL_TRUE;
+}
+
+void VITA_HideScreenKeyboard(_THIS, SDL_Window *window)
+{
+    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+
+    SceCommonDialogStatus dialogStatus = sceImeDialogGetStatus();
+
+    switch (dialogStatus) {
+        default:
+        case SCE_COMMON_DIALOG_STATUS_NONE:
+        case SCE_COMMON_DIALOG_STATUS_RUNNING:
+                break;
+        case SCE_COMMON_DIALOG_STATUS_FINISHED:
+                sceImeDialogTerm();
+                break;
+    }
+
+    videodata->ime_active = SDL_FALSE;
+}
+
+SDL_bool VITA_IsScreenKeyboardShown(_THIS, SDL_Window *window)
+{
+    SceCommonDialogStatus dialogStatus = sceImeDialogGetStatus();
+    return (dialogStatus == SCE_COMMON_DIALOG_STATUS_RUNNING);
+}
+
+
+static void utf16_to_utf8(const uint16_t *src, uint8_t *dst) {
+  int i;
+  for (i = 0; src[i]; i++) {
+    if ((src[i] & 0xFF80) == 0) {
+      *(dst++) = src[i] & 0xFF;
+    } else if((src[i] & 0xF800) == 0) {
+      *(dst++) = ((src[i] >> 6) & 0xFF) | 0xC0;
+      *(dst++) = (src[i] & 0x3F) | 0x80;
+    } else if((src[i] & 0xFC00) == 0xD800 && (src[i + 1] & 0xFC00) == 0xDC00) {
+      *(dst++) = (((src[i] + 64) >> 8) & 0x3) | 0xF0;
+      *(dst++) = (((src[i] >> 2) + 16) & 0x3F) | 0x80;
+      *(dst++) = ((src[i] >> 4) & 0x30) | 0x80 | ((src[i + 1] << 2) & 0xF);
+      *(dst++) = (src[i + 1] & 0x3F) | 0x80;
+      i += 1;
+    } else {
+      *(dst++) = ((src[i] >> 12) & 0xF) | 0xE0;
+      *(dst++) = ((src[i] >> 6) & 0x3F) | 0x80;
+      *(dst++) = (src[i] & 0x3F) | 0x80;
+    }
+  }
+
+  *dst = '\0';
+}
+
+void VITA_PumpEvents(_THIS)
+{
+    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+
+    VITA_PollTouch();
+    VITA_PollKeyboard();
+    VITA_PollMouse();
+
+    if (videodata->ime_active == SDL_TRUE) {
+        // update IME status. Terminate, if finished
+        SceCommonDialogStatus dialogStatus = sceImeDialogGetStatus();
+         if (dialogStatus == SCE_COMMON_DIALOG_STATUS_FINISHED) {
+
+            SceImeDialogResult result;
+            SDL_memset(&result, 0, sizeof(SceImeDialogResult));
+            sceImeDialogGetResult(&result);
+
+            // Convert UTF16 to UTF8
+            uint8_t utf8_buffer[SCE_IME_DIALOG_MAX_TEXT_LENGTH];
+            utf16_to_utf8(videodata->ime_buffer, utf8_buffer);
+            // send sdl event
+            SDL_SendKeyboardText((const char*)utf8_buffer);
+
+            sceImeDialogTerm();
+
+            videodata->ime_active = SDL_FALSE;
+        }
+
+    }
+}
+
+#endif /* SDL_VIDEO_DRIVER_VITA */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/vita/SDL_vitavideo.h b/src/video/vita/SDL_vitavideo.h
new file mode 100644
index 000000000..8f02e9680
--- /dev/null
+++ b/src/video/vita/SDL_vitavideo.h
@@ -0,0 +1,106 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_vitavideo_h
+#define _SDL_vitavideo_h
+
+#include "../../SDL_internal.h"
+#include "../SDL_sysvideo.h"
+
+#include <psp2/ime_dialog.h>
+
+typedef struct SDL_VideoData
+{
+	SDL_bool egl_initialized;   /* OpenGL device initialization status */
+	uint32_t egl_refcount;      /* OpenGL reference count              */
+
+	wchar_t ime_buffer[SCE_IME_DIALOG_MAX_TEXT_LENGTH];
+	SDL_bool ime_active;
+} SDL_VideoData;
+
+
+typedef struct SDL_DisplayData
+{
+
+} SDL_DisplayData;
+
+
+typedef struct SDL_WindowData
+{
+    SDL_bool uses_gles;
+
+} SDL_WindowData;
+
+extern SDL_Window * Vita_Window;
+
+
+/****************************************************************************/
+/* SDL_VideoDevice functions declaration                                    */
+/****************************************************************************/
+
+/* Display and window functions */
+int VITA_VideoInit(_THIS);
+void VITA_VideoQuit(_THIS);
+void VITA_GetDisplayModes(_THIS, SDL_VideoDisplay * display);
+int VITA_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode);
+int VITA_CreateWindow(_THIS, SDL_Window * window);
+int VITA_CreateWindowFrom(_THIS, SDL_Window * window, const void *data);
+void VITA_SetWindowTitle(_THIS, SDL_Window * window);
+void VITA_SetWindowIcon(_THIS, SDL_Window * window, SDL_Surface * icon);
+void VITA_SetWindowPosition(_THIS, SDL_Window * window);
+void VITA_SetWindowSize(_THIS, SDL_Window * window);
+void VITA_ShowWindow(_THIS, SDL_Window * window);
+void VITA_HideWindow(_THIS, SDL_Window * window);
+void VITA_RaiseWindow(_THIS, SDL_Window * window);
+void VITA_MaximizeWindow(_THIS, SDL_Window * window);
+void VITA_MinimizeWindow(_THIS, SDL_Window * window);
+void VITA_RestoreWindow(_THIS, SDL_Window * window);
+void VITA_SetWindowGrab(_THIS, SDL_Window * window, SDL_bool grabbed);
+void VITA_DestroyWindow(_THIS, SDL_Window * window);
+
+/* Window manager function */
+SDL_bool VITA_GetWindowWMInfo(_THIS, SDL_Window * window,
+                             struct SDL_SysWMinfo *info);
+
+#if SDL_VIDEO_DRIVER_VITA
+/* OpenGL functions */
+int VITA_GL_LoadLibrary(_THIS, const char *path);
+void *VITA_GL_GetProcAddress(_THIS, const char *proc);
+void VITA_GL_UnloadLibrary(_THIS);
+SDL_GLContext VITA_GL_CreateContext(_THIS, SDL_Window * window);
+int VITA_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context);
+int VITA_GL_SetSwapInterval(_THIS, int interval);
+int VITA_GL_GetSwapInterval(_THIS);
+int VITA_GL_SwapWindow(_THIS, SDL_Window * window);
+void VITA_GL_DeleteContext(_THIS, SDL_GLContext context);
+#endif
+
+/* VITA on screen keyboard */
+SDL_bool VITA_HasScreenKeyboardSupport(_THIS);
+void VITA_ShowScreenKeyboard(_THIS, SDL_Window *window);
+void VITA_HideScreenKeyboard(_THIS, SDL_Window *window);
+SDL_bool VITA_IsScreenKeyboardShown(_THIS, SDL_Window *window);
+
+void VITA_PumpEvents(_THIS);
+
+#endif /* _SDL_pspvideo_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
